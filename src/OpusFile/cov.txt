/home/fyu/Workspace/hapi-client/test/test-api/opusfile/include/opusfile.h:
    1|       |/********************************************************************
    2|       | *                                                                  *
    3|       | * THIS FILE IS PART OF THE libopusfile SOFTWARE CODEC SOURCE CODE. *
    4|       | * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
    5|       | * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
    6|       | * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
    7|       | *                                                                  *
    8|       | * THE libopusfile SOURCE CODE IS (C) COPYRIGHT 1994-2012           *
    9|       | * by the Xiph.Org Foundation and contributors https://xiph.org/    *
   10|       | *                                                                  *
   11|       | ********************************************************************
   12|       |
   13|       | function: stdio-based convenience library for opening/seeking/decoding
   14|       | last mod: $Id: vorbisfile.h 17182 2010-04-29 03:48:32Z xiphmont $
   15|       |
   16|       | ********************************************************************/
   17|       |#if !defined(_opusfile_h)
   18|       |# define _opusfile_h (1)
   19|       |
   20|       |/**\mainpage
   21|       |   \section Introduction
   22|       |
   23|       |   This is the documentation for the <tt>libopusfile</tt> C API.
   24|       |
   25|       |   The <tt>libopusfile</tt> package provides a convenient high-level API for
   26|       |    decoding and basic manipulation of all Ogg Opus audio streams.
   27|       |   <tt>libopusfile</tt> is implemented as a layer on top of Xiph.Org's
   28|       |    reference
   29|       |    <tt><a href="https://www.xiph.org/ogg/doc/libogg/reference.html">libogg</a></tt>
   30|       |    and
   31|       |    <tt><a href="https://opus-codec.org/docs/opus_api-1.3.1/">libopus</a></tt>
   32|       |    libraries.
   33|       |
   34|       |   <tt>libopusfile</tt> provides several sets of built-in routines for
   35|       |    file/stream access, and may also use custom stream I/O routines provided by
   36|       |    the embedded environment.
   37|       |   There are built-in I/O routines provided for ANSI-compliant
   38|       |    <code>stdio</code> (<code>FILE *</code>), memory buffers, and URLs
   39|       |    (including <file:> URLs, plus optionally <http:> and <https:> URLs).
   40|       |
   41|       |   \section Organization
   42|       |
   43|       |   The main API is divided into several sections:
   44|       |   - \ref stream_open_close
   45|       |   - \ref stream_info
   46|       |   - \ref stream_decoding
   47|       |   - \ref stream_seeking
   48|       |
   49|       |   Several additional sections are not tied to the main API.
   50|       |   - \ref stream_callbacks
   51|       |   - \ref header_info
   52|       |   - \ref error_codes
   53|       |
   54|       |   \section Overview
   55|       |
   56|       |   The <tt>libopusfile</tt> API always decodes files to 48&nbsp;kHz.
   57|       |   The original sample rate is not preserved by the lossy compression, though
   58|       |    it is stored in the header to allow you to resample to it after decoding
   59|       |    (the <tt>libopusfile</tt> API does not currently provide a resampler,
   60|       |    but the
   61|       |    <a href="https://www.speex.org/docs/manual/speex-manual/node7.html#SECTION00760000000000000000">the
   62|       |    Speex resampler</a> is a good choice if you need one).
   63|       |   In general, if you are playing back the audio, you should leave it at
   64|       |    48&nbsp;kHz, provided your audio hardware supports it.
   65|       |   When decoding to a file, it may be worth resampling back to the original
   66|       |    sample rate, so as not to surprise users who might not expect the sample
   67|       |    rate to change after encoding to Opus and decoding.
   68|       |
   69|       |   Opus files can contain anywhere from 1 to 255 channels of audio.
   70|       |   The channel mappings for up to 8 channels are the same as the
   71|       |    <a href="https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-810004.3.9">Vorbis
   72|       |    mappings</a>.
   73|       |   A special stereo API can convert everything to 2 channels, making it simple
   74|       |    to support multichannel files in an application which only has stereo
   75|       |    output.
   76|       |   Although the <tt>libopusfile</tt> ABI provides support for the theoretical
   77|       |    maximum number of channels, the current implementation does not support
   78|       |    files with more than 8 channels, as they do not have well-defined channel
   79|       |    mappings.
   80|       |
   81|       |   Like all Ogg files, Opus files may be "chained".
   82|       |   That is, multiple Opus files may be combined into a single, longer file just
   83|       |    by concatenating the original files.
   84|       |   This is commonly done in internet radio streaming, as it allows the title
   85|       |    and artist to be updated each time the song changes, since each link in the
   86|       |    chain includes its own set of metadata.
   87|       |
   88|       |   <tt>libopusfile</tt> fully supports chained files.
   89|       |   It will decode the first Opus stream found in each link of a chained file
   90|       |    (ignoring any other streams that might be concurrently multiplexed with it,
   91|       |    such as a video stream).
   92|       |
   93|       |   The channel count can also change between links.
   94|       |   If your application is not prepared to deal with this, it can use the stereo
   95|       |    API to ensure the audio from all links will always get decoded into a
   96|       |    common format.
   97|       |   Since <tt>libopusfile</tt> always decodes to 48&nbsp;kHz, you do not have to
   98|       |    worry about the sample rate changing between links (as was possible with
   99|       |    Vorbis).
  100|       |   This makes application support for chained files with <tt>libopusfile</tt>
  101|       |    very easy.*/
  102|       |
  103|       |# if defined(__cplusplus)
  104|       |extern "C" {
  105|       |# endif
  106|       |
  107|       |# include <stdarg.h>
  108|       |# include <stdio.h>
  109|       |# include <ogg/ogg.h>
  110|       |# include <opus_multistream.h>
  111|       |
  112|       |/**@cond PRIVATE*/
  113|       |
  114|       |/*Enable special features for gcc and gcc-compatible compilers.*/
  115|       |# if !defined(OP_GNUC_PREREQ)
  116|       |#  if defined(__GNUC__)&&defined(__GNUC_MINOR__)
  117|       |#   define OP_GNUC_PREREQ(_maj,_min) \
  118|       | ((__GNUC__<<16)+__GNUC_MINOR__>=((_maj)<<16)+(_min))
  119|       |#  else
  120|       |#   define OP_GNUC_PREREQ(_maj,_min) 0
  121|       |#  endif
  122|       |# endif
  123|       |
  124|       |# if OP_GNUC_PREREQ(4,0)
  125|       |#  pragma GCC visibility push(default)
  126|       |# endif
  127|       |
  128|       |typedef struct OpusHead          OpusHead;
  129|       |typedef struct OpusTags          OpusTags;
  130|       |typedef struct OpusPictureTag    OpusPictureTag;
  131|       |typedef struct OpusServerInfo    OpusServerInfo;
  132|       |typedef struct OpusFileCallbacks OpusFileCallbacks;
  133|       |typedef struct OggOpusFile       OggOpusFile;
  134|       |
  135|       |/*Warning attributes for libopusfile functions.*/
  136|       |# if OP_GNUC_PREREQ(3,4)
  137|       |#  define OP_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
  138|       |# else
  139|       |#  define OP_WARN_UNUSED_RESULT
  140|       |# endif
  141|       |# if OP_GNUC_PREREQ(3,4)
  142|       |#  define OP_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))
  143|       |# else
  144|       |#  define OP_ARG_NONNULL(_x)
  145|       |# endif
  146|       |
  147|       |/**@endcond*/
  148|       |
  149|       |/**\defgroup error_codes Error Codes*/
  150|       |/*@{*/
  151|       |/**\name List of possible error codes
  152|       |   Many of the functions in this library return a negative error code when a
  153|       |    function fails.
  154|       |   This list provides a brief explanation of the common errors.
  155|       |   See each individual function for more details on what a specific error code
  156|       |    means in that context.*/
  157|       |/*@{*/
  158|       |
  159|       |/**A request did not succeed.*/
  160|     16|#define OP_FALSE         (-1)
  161|       |/*Currently not used externally.*/
  162|      0|#define OP_EOF           (-2)
  163|       |/**There was a hole in the page sequence numbers (e.g., a page was corrupt or
  164|       |    missing).*/
  165|      0|#define OP_HOLE          (-3)
  166|       |/**An underlying read, seek, or tell operation failed when it should have
  167|       |    succeeded.*/
  168|      0|#define OP_EREAD         (-128)
  169|       |/**A <code>NULL</code> pointer was passed where one was unexpected, or an
  170|       |    internal memory allocation failed, or an internal library error was
  171|       |    encountered.*/
  172|      4|#define OP_EFAULT        (-129)
  173|       |/**The stream used a feature that is not implemented, such as an unsupported
  174|       |    channel family.*/
  175|      0|#define OP_EIMPL         (-130)
  176|       |/**One or more parameters to a function were invalid.*/
  177|      0|#define OP_EINVAL        (-131)
  178|       |/**A purported Ogg Opus stream did not begin with an Ogg page, a purported
  179|       |    header packet did not start with one of the required strings, "OpusHead" or
  180|       |    "OpusTags", or a link in a chained file was encountered that did not
  181|       |    contain any logical Opus streams.*/
  182|      2|#define OP_ENOTFORMAT    (-132)
  183|       |/**A required header packet was not properly formatted, contained illegal
  184|       |    values, or was missing altogether.*/
  185|      0|#define OP_EBADHEADER    (-133)
  186|       |/**The ID header contained an unrecognized version number.*/
  187|      0|#define OP_EVERSION      (-134)
  188|       |/*Currently not used at all.*/
  189|       |#define OP_ENOTAUDIO     (-135)
  190|       |/**An audio packet failed to decode properly.
  191|       |   This is usually caused by a multistream Ogg packet where the durations of
  192|       |    the individual Opus packets contained in it are not all the same.*/
  193|      0|#define OP_EBADPACKET    (-136)
  194|       |/**We failed to find data we had seen before, or the bitstream structure was
  195|       |    sufficiently malformed that seeking to the target destination was
  196|       |    impossible.*/
  197|      2|#define OP_EBADLINK      (-137)
  198|       |/**An operation that requires seeking was requested on an unseekable stream.*/
  199|      0|#define OP_ENOSEEK       (-138)
  200|       |/**The first or last granule position of a link failed basic validity checks.*/
  201|      0|#define OP_EBADTIMESTAMP (-139)
  202|       |
  203|       |/*@}*/
  204|       |/*@}*/
  205|       |
  206|       |/**\defgroup header_info Header Information*/
  207|       |/*@{*/
  208|       |
  209|       |/**The maximum number of channels in an Ogg Opus stream.*/
  210|       |#define OPUS_CHANNEL_COUNT_MAX (255)
  211|       |
  212|       |/**Ogg Opus bitstream information.
  213|       |   This contains the basic playback parameters for a stream, and corresponds to
  214|       |    the initial ID header packet of an Ogg Opus stream.*/
  215|       |struct OpusHead{
  216|       |  /**The Ogg Opus format version, in the range 0...255.
  217|       |     The top 4 bits represent a "major" version, and the bottom four bits
  218|       |      represent backwards-compatible "minor" revisions.
  219|       |     The current specification describes version 1.
  220|       |     This library will recognize versions up through 15 as backwards compatible
  221|       |      with the current specification.
  222|       |     An earlier draft of the specification described a version 0, but the only
  223|       |      difference between version 1 and version 0 is that version 0 did
  224|       |      not specify the semantics for handling the version field.*/
  225|       |  int           version;
  226|       |  /**The number of channels, in the range 1...255.*/
  227|       |  int           channel_count;
  228|       |  /**The number of samples that should be discarded from the beginning of the
  229|       |      stream.*/
  230|       |  unsigned      pre_skip;
  231|       |  /**The sampling rate of the original input.
  232|       |     All Opus audio is coded at 48 kHz, and should also be decoded at 48 kHz
  233|       |      for playback (unless the target hardware does not support this sampling
  234|       |      rate).
  235|       |     However, this field may be used to resample the audio back to the original
  236|       |      sampling rate, for example, when saving the output to a file.*/
  237|       |  opus_uint32   input_sample_rate;
  238|       |  /**The gain to apply to the decoded output, in dB, as a Q8 value in the range
  239|       |      -32768...32767.
  240|       |     The <tt>libopusfile</tt> API will automatically apply this gain to the
  241|       |      decoded output before returning it, scaling it by
  242|       |      <code>pow(10,output_gain/(20.0*256))</code>.
  243|       |     You can adjust this behavior with op_set_gain_offset().*/
  244|       |  int           output_gain;
  245|       |  /**The channel mapping family, in the range 0...255.
  246|       |     Channel mapping family 0 covers mono or stereo in a single stream.
  247|       |     Channel mapping family 1 covers 1 to 8 channels in one or more streams,
  248|       |      using the Vorbis speaker assignments.
  249|       |     Channel mapping family 255 covers 1 to 255 channels in one or more
  250|       |      streams, but without any defined speaker assignment.*/
  251|       |  int           mapping_family;
  252|       |  /**The number of Opus streams in each Ogg packet, in the range 1...255.*/
  253|       |  int           stream_count;
  254|       |  /**The number of coupled Opus streams in each Ogg packet, in the range
  255|       |      0...127.
  256|       |     This must satisfy <code>0 <= coupled_count <= stream_count</code> and
  257|       |      <code>coupled_count + stream_count <= 255</code>.
  258|       |     The coupled streams appear first, before all uncoupled streams, in an Ogg
  259|       |      Opus packet.*/
  260|       |  int           coupled_count;
  261|       |  /**The mapping from coded stream channels to output channels.
  262|       |     Let <code>index=mapping[k]</code> be the value for channel <code>k</code>.
  263|       |     If <code>index<2*coupled_count</code>, then it refers to the left channel
  264|       |      from stream <code>(index/2)</code> if even, and the right channel from
  265|       |      stream <code>(index/2)</code> if odd.
  266|       |     Otherwise, it refers to the output of the uncoupled stream
  267|       |      <code>(index-coupled_count)</code>.*/
  268|       |  unsigned char mapping[OPUS_CHANNEL_COUNT_MAX];
  269|       |};
  270|       |
  271|       |/**The metadata from an Ogg Opus stream.
  272|       |
  273|       |   This structure holds the in-stream metadata corresponding to the 'comment'
  274|       |    header packet of an Ogg Opus stream.
  275|       |   The comment header is meant to be used much like someone jotting a quick
  276|       |    note on the label of a CD.
  277|       |   It should be a short, to the point text note that can be more than a couple
  278|       |    words, but not more than a short paragraph.
  279|       |
  280|       |   The metadata is stored as a series of (tag, value) pairs, in length-encoded
  281|       |    string vectors, using the same format as Vorbis (without the final "framing
  282|       |    bit"), Theora, and Speex, except for the packet header.
  283|       |   The first occurrence of the '=' character delimits the tag and value.
  284|       |   A particular tag may occur more than once, and order is significant.
  285|       |   The character set encoding for the strings is always UTF-8, but the tag
  286|       |    names are limited to ASCII, and treated as case-insensitive.
  287|       |   See <a href="https://www.xiph.org/vorbis/doc/v-comment.html">the Vorbis
  288|       |    comment header specification</a> for details.
  289|       |
  290|       |   In filling in this structure, <tt>libopusfile</tt> will null-terminate the
  291|       |    #user_comments strings for safety.
  292|       |   However, the bitstream format itself treats them as 8-bit clean vectors,
  293|       |    possibly containing NUL characters, so the #comment_lengths array should be
  294|       |    treated as their authoritative length.
  295|       |
  296|       |   This structure is binary and source-compatible with a
  297|       |    <code>vorbis_comment</code>, and pointers to it may be freely cast to
  298|       |    <code>vorbis_comment</code> pointers, and vice versa.
  299|       |   It is provided as a separate type to avoid introducing a compile-time
  300|       |    dependency on the libvorbis headers.*/
  301|       |struct OpusTags{
  302|       |  /**The array of comment string vectors.*/
  303|       |  char **user_comments;
  304|       |  /**An array of the corresponding length of each vector, in bytes.*/
  305|       |  int   *comment_lengths;
  306|       |  /**The total number of comment streams.*/
  307|       |  int    comments;
  308|       |  /**The null-terminated vendor string.
  309|       |     This identifies the software used to encode the stream.*/
  310|       |  char  *vendor;
  311|       |};
  312|       |
  313|       |/**\name Picture tag image formats*/
  314|       |/*@{*/
  315|       |
  316|       |/**The MIME type was not recognized, or the image data did not match the
  317|       |    declared MIME type.*/
  318|      0|#define OP_PIC_FORMAT_UNKNOWN (-1)
  319|       |/**The MIME type indicates the image data is really a URL.*/
  320|      0|#define OP_PIC_FORMAT_URL     (0)
  321|       |/**The image is a JPEG.*/
  322|      0|#define OP_PIC_FORMAT_JPEG    (1)
  323|       |/**The image is a PNG.*/
  324|      0|#define OP_PIC_FORMAT_PNG     (2)
  325|       |/**The image is a GIF.*/
  326|      0|#define OP_PIC_FORMAT_GIF     (3)
  327|       |
  328|       |/*@}*/
  329|       |
  330|       |/**The contents of a METADATA_BLOCK_PICTURE tag.*/
  331|       |struct OpusPictureTag{
  332|       |  /**The picture type according to the ID3v2 APIC frame:
  333|       |     <ol start="0">
  334|       |     <li>Other</li>
  335|       |     <li>32x32 pixels 'file icon' (PNG only)</li>
  336|       |     <li>Other file icon</li>
  337|       |     <li>Cover (front)</li>
  338|       |     <li>Cover (back)</li>
  339|       |     <li>Leaflet page</li>
  340|       |     <li>Media (e.g. label side of CD)</li>
  341|       |     <li>Lead artist/lead performer/soloist</li>
  342|       |     <li>Artist/performer</li>
  343|       |     <li>Conductor</li>
  344|       |     <li>Band/Orchestra</li>
  345|       |     <li>Composer</li>
  346|       |     <li>Lyricist/text writer</li>
  347|       |     <li>Recording Location</li>
  348|       |     <li>During recording</li>
  349|       |     <li>During performance</li>
  350|       |     <li>Movie/video screen capture</li>
  351|       |     <li>A bright colored fish</li>
  352|       |     <li>Illustration</li>
  353|       |     <li>Band/artist logotype</li>
  354|       |     <li>Publisher/Studio logotype</li>
  355|       |     </ol>
  356|       |     Others are reserved and should not be used.
  357|       |     There may only be one each of picture type 1 and 2 in a file.*/
  358|       |  opus_int32     type;
  359|       |  /**The MIME type of the picture, in printable ASCII characters 0x20-0x7E.
  360|       |     The MIME type may also be <code>"-->"</code> to signify that the data part
  361|       |      is a URL pointing to the picture instead of the picture data itself.
  362|       |     In this case, a terminating NUL is appended to the URL string in #data,
  363|       |      but #data_length is set to the length of the string excluding that
  364|       |      terminating NUL.*/
  365|       |  char          *mime_type;
  366|       |  /**The description of the picture, in UTF-8.*/
  367|       |  char          *description;
  368|       |  /**The width of the picture in pixels.*/
  369|       |  opus_uint32    width;
  370|       |  /**The height of the picture in pixels.*/
  371|       |  opus_uint32    height;
  372|       |  /**The color depth of the picture in bits-per-pixel (<em>not</em>
  373|       |      bits-per-channel).*/
  374|       |  opus_uint32    depth;
  375|       |  /**For indexed-color pictures (e.g., GIF), the number of colors used, or 0
  376|       |      for non-indexed pictures.*/
  377|       |  opus_uint32    colors;
  378|       |  /**The length of the picture data in bytes.*/
  379|       |  opus_uint32    data_length;
  380|       |  /**The binary picture data.*/
  381|       |  unsigned char *data;
  382|       |  /**The format of the picture data, if known.
  383|       |     One of
  384|       |     <ul>
  385|       |     <li>#OP_PIC_FORMAT_UNKNOWN,</li>
  386|       |     <li>#OP_PIC_FORMAT_URL,</li>
  387|       |     <li>#OP_PIC_FORMAT_JPEG,</li>
  388|       |     <li>#OP_PIC_FORMAT_PNG, or</li>
  389|       |     <li>#OP_PIC_FORMAT_GIF.</li>
  390|       |     </ul>*/
  391|       |  int            format;
  392|       |};
  393|       |
  394|       |/**\name Functions for manipulating header data
  395|       |
  396|       |   These functions manipulate the #OpusHead and #OpusTags structures,
  397|       |    which describe the audio parameters and tag-value metadata, respectively.
  398|       |   These can be used to query the headers returned by <tt>libopusfile</tt>, or
  399|       |    to parse Opus headers from sources other than an Ogg Opus stream, provided
  400|       |    they use the same format.*/
  401|       |/*@{*/
  402|       |
  403|       |/**Parses the contents of the ID header packet of an Ogg Opus stream.
  404|       |   \param[out] _head Returns the contents of the parsed packet.
  405|       |                     The contents of this structure are untouched on error.
  406|       |                     This may be <code>NULL</code> to merely test the header
  407|       |                      for validity.
  408|       |   \param[in]  _data The contents of the ID header packet.
  409|       |   \param      _len  The number of bytes of data in the ID header packet.
  410|       |   \return 0 on success or a negative value on error.
  411|       |   \retval #OP_ENOTFORMAT If the data does not start with the "OpusHead"
  412|       |                           string.
  413|       |   \retval #OP_EVERSION   If the version field signaled a version this library
  414|       |                           does not know how to parse.
  415|       |   \retval #OP_EIMPL      If the channel mapping family was 255, which general
  416|       |                           purpose players should not attempt to play.
  417|       |   \retval #OP_EBADHEADER If the contents of the packet otherwise violate the
  418|       |                           Ogg Opus specification:
  419|       |                          <ul>
  420|       |                           <li>Insufficient data,</li>
  421|       |                           <li>Too much data for the known minor versions,</li>
  422|       |                           <li>An unrecognized channel mapping family,</li>
  423|       |                           <li>Zero channels or too many channels,</li>
  424|       |                           <li>Zero coded streams,</li>
  425|       |                           <li>Too many coupled streams, or</li>
  426|       |                           <li>An invalid channel mapping index.</li>
  427|       |                          </ul>*/
  428|       |OP_WARN_UNUSED_RESULT int opus_head_parse(OpusHead *_head,
  429|       | const unsigned char *_data,size_t _len) OP_ARG_NONNULL(2);
  430|       |
  431|       |/**Converts a granule position to a sample offset for a given Ogg Opus stream.
  432|       |   The sample offset is simply <code>_gp-_head->pre_skip</code>.
  433|       |   Granule position values smaller than OpusHead#pre_skip correspond to audio
  434|       |    that should never be played, and thus have no associated sample offset.
  435|       |   This function returns -1 for such values.
  436|       |   This function also correctly handles extremely large granule positions,
  437|       |    which may have wrapped around to a negative number when stored in a signed
  438|       |    ogg_int64_t value.
  439|       |   \param _head The #OpusHead information from the ID header of the stream.
  440|       |   \param _gp   The granule position to convert.
  441|       |   \return The sample offset associated with the given granule position
  442|       |            (counting at a 48 kHz sampling rate), or the special value -1 on
  443|       |            error (i.e., the granule position was smaller than the pre-skip
  444|       |            amount).*/
  445|       |ogg_int64_t opus_granule_sample(const OpusHead *_head,ogg_int64_t _gp)
  446|       | OP_ARG_NONNULL(1);
  447|       |
  448|       |/**Parses the contents of the 'comment' header packet of an Ogg Opus stream.
  449|       |   \param[out] _tags An uninitialized #OpusTags structure.
  450|       |                     This returns the contents of the parsed packet.
  451|       |                     The contents of this structure are untouched on error.
  452|       |                     This may be <code>NULL</code> to merely test the header
  453|       |                      for validity.
  454|       |   \param[in]  _data The contents of the 'comment' header packet.
  455|       |   \param      _len  The number of bytes of data in the 'info' header packet.
  456|       |   \retval 0              Success.
  457|       |   \retval #OP_ENOTFORMAT If the data does not start with the "OpusTags"
  458|       |                           string.
  459|       |   \retval #OP_EBADHEADER If the contents of the packet otherwise violate the
  460|       |                           Ogg Opus specification.
  461|       |   \retval #OP_EFAULT     If there wasn't enough memory to store the tags.*/
  462|       |OP_WARN_UNUSED_RESULT int opus_tags_parse(OpusTags *_tags,
  463|       | const unsigned char *_data,size_t _len) OP_ARG_NONNULL(2);
  464|       |
  465|       |/**Performs a deep copy of an #OpusTags structure.
  466|       |   \param _dst The #OpusTags structure to copy into.
  467|       |               If this function fails, the contents of this structure remain
  468|       |                untouched.
  469|       |   \param _src The #OpusTags structure to copy from.
  470|       |   \retval 0          Success.
  471|       |   \retval #OP_EFAULT If there wasn't enough memory to copy the tags.*/
  472|       |int opus_tags_copy(OpusTags *_dst,const OpusTags *_src) OP_ARG_NONNULL(1);
  473|       |
  474|       |/**Initializes an #OpusTags structure.
  475|       |   This should be called on a freshly allocated #OpusTags structure before
  476|       |    attempting to use it.
  477|       |   \param _tags The #OpusTags structure to initialize.*/
  478|       |void opus_tags_init(OpusTags *_tags) OP_ARG_NONNULL(1);
  479|       |
  480|       |/**Add a (tag, value) pair to an initialized #OpusTags structure.
  481|       |   \note Neither opus_tags_add() nor opus_tags_add_comment() support values
  482|       |    containing embedded NULs, although the bitstream format does support them.
  483|       |   To add such tags, you will need to manipulate the #OpusTags structure
  484|       |    directly.
  485|       |   \param _tags  The #OpusTags structure to add the (tag, value) pair to.
  486|       |   \param _tag   A NUL-terminated, case-insensitive, ASCII string containing
  487|       |                  the tag to add (without an '=' character).
  488|       |   \param _value A NUL-terminated UTF-8 containing the corresponding value.
  489|       |   \return 0 on success, or a negative value on failure.
  490|       |   \retval #OP_EFAULT An internal memory allocation failed.*/
  491|       |int opus_tags_add(OpusTags *_tags,const char *_tag,const char *_value)
  492|       | OP_ARG_NONNULL(1) OP_ARG_NONNULL(2) OP_ARG_NONNULL(3);
  493|       |
  494|       |/**Add a comment to an initialized #OpusTags structure.
  495|       |   \note Neither opus_tags_add_comment() nor opus_tags_add() support comments
  496|       |    containing embedded NULs, although the bitstream format does support them.
  497|       |   To add such tags, you will need to manipulate the #OpusTags structure
  498|       |    directly.
  499|       |   \param _tags    The #OpusTags structure to add the comment to.
  500|       |   \param _comment A NUL-terminated UTF-8 string containing the comment in
  501|       |                    "TAG=value" form.
  502|       |   \return 0 on success, or a negative value on failure.
  503|       |   \retval #OP_EFAULT An internal memory allocation failed.*/
  504|       |int opus_tags_add_comment(OpusTags *_tags,const char *_comment)
  505|       | OP_ARG_NONNULL(1) OP_ARG_NONNULL(2);
  506|       |
  507|       |/**Replace the binary suffix data at the end of the packet (if any).
  508|       |   \param _tags An initialized #OpusTags structure.
  509|       |   \param _data A buffer of binary data to append after the encoded user
  510|       |                 comments.
  511|       |                The least significant bit of the first byte of this data must
  512|       |                 be set (to ensure the data is preserved by other editors).
  513|       |   \param _len  The number of bytes of binary data to append.
  514|       |                This may be zero to remove any existing binary suffix data.
  515|       |   \return 0 on success, or a negative value on error.
  516|       |   \retval #OP_EINVAL \a _len was negative, or \a _len was positive but
  517|       |                       \a _data was <code>NULL</code> or the least significant
  518|       |                       bit of the first byte was not set.
  519|       |   \retval #OP_EFAULT An internal memory allocation failed.*/
  520|       |int opus_tags_set_binary_suffix(OpusTags *_tags,
  521|       | const unsigned char *_data,int _len) OP_ARG_NONNULL(1);
  522|       |
  523|       |/**Look up a comment value by its tag.
  524|       |   \param _tags  An initialized #OpusTags structure.
  525|       |   \param _tag   The tag to look up.
  526|       |   \param _count The instance of the tag.
  527|       |                 The same tag can appear multiple times, each with a distinct
  528|       |                  value, so an index is required to retrieve them all.
  529|       |                 The order in which these values appear is significant and
  530|       |                  should be preserved.
  531|       |                 Use opus_tags_query_count() to get the legal range for the
  532|       |                  \a _count parameter.
  533|       |   \return A pointer to the queried tag's value.
  534|       |           This points directly to data in the #OpusTags structure.
  535|       |           It should not be modified or freed by the application, and
  536|       |            modifications to the structure may invalidate the pointer.
  537|       |   \retval NULL If no matching tag is found.*/
  538|       |const char *opus_tags_query(const OpusTags *_tags,const char *_tag,int _count)
  539|       | OP_ARG_NONNULL(1) OP_ARG_NONNULL(2);
  540|       |
  541|       |/**Look up the number of instances of a tag.
  542|       |   Call this first when querying for a specific tag and then iterate over the
  543|       |    number of instances with separate calls to opus_tags_query() to retrieve
  544|       |    all the values for that tag in order.
  545|       |   \param _tags An initialized #OpusTags structure.
  546|       |   \param _tag  The tag to look up.
  547|       |   \return The number of instances of this particular tag.*/
  548|       |int opus_tags_query_count(const OpusTags *_tags,const char *_tag)
  549|       | OP_ARG_NONNULL(1) OP_ARG_NONNULL(2);
  550|       |
  551|       |/**Retrieve the binary suffix data at the end of the packet (if any).
  552|       |   \param      _tags An initialized #OpusTags structure.
  553|       |   \param[out] _len  Returns the number of bytes of binary suffix data returned.
  554|       |   \return A pointer to the binary suffix data, or <code>NULL</code> if none
  555|       |            was present.*/
  556|       |const unsigned char *opus_tags_get_binary_suffix(const OpusTags *_tags,
  557|       | int *_len) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2);
  558|       |
  559|       |/**Get the album gain from an R128_ALBUM_GAIN tag, if one was specified.
  560|       |   This searches for the first R128_ALBUM_GAIN tag with a valid signed,
  561|       |    16-bit decimal integer value and returns the value.
  562|       |   This routine is exposed merely for convenience for applications which wish
  563|       |    to do something special with the album gain (i.e., display it).
  564|       |   If you simply wish to apply the album gain instead of the header gain, you
  565|       |    can use op_set_gain_offset() with an #OP_ALBUM_GAIN type and no offset.
  566|       |   \param      _tags    An initialized #OpusTags structure.
  567|       |   \param[out] _gain_q8 The album gain, in 1/256ths of a dB.
  568|       |                        This will lie in the range [-32768,32767], and should
  569|       |                         be applied in <em>addition</em> to the header gain.
  570|       |                        On error, no value is returned, and the previous
  571|       |                         contents remain unchanged.
  572|       |   \return 0 on success, or a negative value on error.
  573|       |   \retval #OP_FALSE There was no album gain available in the given tags.*/
  574|       |int opus_tags_get_album_gain(const OpusTags *_tags,int *_gain_q8)
  575|       | OP_ARG_NONNULL(1) OP_ARG_NONNULL(2);
  576|       |
  577|       |/**Get the track gain from an R128_TRACK_GAIN tag, if one was specified.
  578|       |   This searches for the first R128_TRACK_GAIN tag with a valid signed,
  579|       |    16-bit decimal integer value and returns the value.
  580|       |   This routine is exposed merely for convenience for applications which wish
  581|       |    to do something special with the track gain (i.e., display it).
  582|       |   If you simply wish to apply the track gain instead of the header gain, you
  583|       |    can use op_set_gain_offset() with an #OP_TRACK_GAIN type and no offset.
  584|       |   \param      _tags    An initialized #OpusTags structure.
  585|       |   \param[out] _gain_q8 The track gain, in 1/256ths of a dB.
  586|       |                        This will lie in the range [-32768,32767], and should
  587|       |                         be applied in <em>addition</em> to the header gain.
  588|       |                        On error, no value is returned, and the previous
  589|       |                         contents remain unchanged.
  590|       |   \return 0 on success, or a negative value on error.
  591|       |   \retval #OP_FALSE There was no track gain available in the given tags.*/
  592|       |int opus_tags_get_track_gain(const OpusTags *_tags,int *_gain_q8)
  593|       | OP_ARG_NONNULL(1) OP_ARG_NONNULL(2);
  594|       |
  595|       |/**Clears the #OpusTags structure.
  596|       |   This should be called on an #OpusTags structure after it is no longer
  597|       |    needed.
  598|       |   It will free all memory used by the structure members.
  599|       |   \param _tags The #OpusTags structure to clear.*/
  600|       |void opus_tags_clear(OpusTags *_tags) OP_ARG_NONNULL(1);
  601|       |
  602|       |/**Check if \a _comment is an instance of a \a _tag_name tag.
  603|       |   \see opus_tagncompare
  604|       |   \param _tag_name A NUL-terminated, case-insensitive, ASCII string containing
  605|       |                     the name of the tag to check for (without the terminating
  606|       |                     '=' character).
  607|       |   \param _comment  The comment string to check.
  608|       |   \return An integer less than, equal to, or greater than zero if \a _comment
  609|       |            is found respectively, to be less than, to match, or be greater
  610|       |            than a "tag=value" string whose tag matches \a _tag_name.*/
  611|       |int opus_tagcompare(const char *_tag_name,const char *_comment);
  612|       |
  613|       |/**Check if \a _comment is an instance of a \a _tag_name tag.
  614|       |   This version is slightly more efficient than opus_tagcompare() if the length
  615|       |    of the tag name is already known (e.g., because it is a constant).
  616|       |   \see opus_tagcompare
  617|       |   \param _tag_name A case-insensitive ASCII string containing the name of the
  618|       |                     tag to check for (without the terminating '=' character).
  619|       |   \param _tag_len  The number of characters in the tag name.
  620|       |                    This must be non-negative.
  621|       |   \param _comment  The comment string to check.
  622|       |   \return An integer less than, equal to, or greater than zero if \a _comment
  623|       |            is found respectively, to be less than, to match, or be greater
  624|       |            than a "tag=value" string whose tag matches the first \a _tag_len
  625|       |            characters of \a _tag_name.*/
  626|       |int opus_tagncompare(const char *_tag_name,int _tag_len,const char *_comment);
  627|       |
  628|       |/**Parse a single METADATA_BLOCK_PICTURE tag.
  629|       |   This decodes the BASE64-encoded content of the tag and returns a structure
  630|       |    with the MIME type, description, image parameters (if known), and the
  631|       |    compressed image data.
  632|       |   If the MIME type indicates the presence of an image format we recognize
  633|       |    (JPEG, PNG, or GIF) and the actual image data contains the magic signature
  634|       |    associated with that format, then the OpusPictureTag::format field will be
  635|       |    set to the corresponding format.
  636|       |   This is provided as a convenience to avoid requiring applications to parse
  637|       |    the MIME type and/or do their own format detection for the commonly used
  638|       |    formats.
  639|       |   In this case, we also attempt to extract the image parameters directly from
  640|       |    the image data (overriding any that were present in the tag, which the
  641|       |    specification says applications are not meant to rely on).
  642|       |   The application must still provide its own support for actually decoding the
  643|       |    image data and, if applicable, retrieving that data from URLs.
  644|       |   \param[out] _pic Returns the parsed picture data.
  645|       |                    No sanitation is done on the type, MIME type, or
  646|       |                     description fields, so these might return invalid values.
  647|       |                    The contents of this structure are left unmodified on
  648|       |                     failure.
  649|       |   \param      _tag The METADATA_BLOCK_PICTURE tag contents.
  650|       |                    The leading "METADATA_BLOCK_PICTURE=" portion is optional,
  651|       |                     to allow the function to be used on either directly on the
  652|       |                     values in OpusTags::user_comments or on the return value
  653|       |                     of opus_tags_query().
  654|       |   \return 0 on success or a negative value on error.
  655|       |   \retval #OP_ENOTFORMAT The METADATA_BLOCK_PICTURE contents were not valid.
  656|       |   \retval #OP_EFAULT     There was not enough memory to store the picture tag
  657|       |                           contents.*/
  658|       |OP_WARN_UNUSED_RESULT int opus_picture_tag_parse(OpusPictureTag *_pic,
  659|       | const char *_tag) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2);
  660|       |
  661|       |/**Initializes an #OpusPictureTag structure.
  662|       |   This should be called on a freshly allocated #OpusPictureTag structure
  663|       |    before attempting to use it.
  664|       |   \param _pic The #OpusPictureTag structure to initialize.*/
  665|       |void opus_picture_tag_init(OpusPictureTag *_pic) OP_ARG_NONNULL(1);
  666|       |
  667|       |/**Clears the #OpusPictureTag structure.
  668|       |   This should be called on an #OpusPictureTag structure after it is no longer
  669|       |    needed.
  670|       |   It will free all memory used by the structure members.
  671|       |   \param _pic The #OpusPictureTag structure to clear.*/
  672|       |void opus_picture_tag_clear(OpusPictureTag *_pic) OP_ARG_NONNULL(1);
  673|       |
  674|       |/*@}*/
  675|       |
  676|       |/*@}*/
  677|       |
  678|       |/**\defgroup url_options URL Reading Options*/
  679|       |/*@{*/
  680|       |/**\name URL reading options
  681|       |   Options for op_url_stream_create() and associated functions.
  682|       |   These allow you to provide proxy configuration parameters, skip SSL
  683|       |    certificate checks, etc.
  684|       |   Options are processed in order, and if the same option is passed multiple
  685|       |    times, only the value specified by the last occurrence has an effect
  686|       |    (unless otherwise specified).
  687|       |   They may be expanded in the future.*/
  688|       |/*@{*/
  689|       |
  690|       |/**@cond PRIVATE*/
  691|       |
  692|       |/*These are the raw numbers used to define the request codes.
  693|       |  They should not be used directly.*/
  694|       |#define OP_SSL_SKIP_CERTIFICATE_CHECK_REQUEST (6464)
  695|       |#define OP_HTTP_PROXY_HOST_REQUEST            (6528)
  696|       |#define OP_HTTP_PROXY_PORT_REQUEST            (6592)
  697|       |#define OP_HTTP_PROXY_USER_REQUEST            (6656)
  698|       |#define OP_HTTP_PROXY_PASS_REQUEST            (6720)
  699|       |#define OP_GET_SERVER_INFO_REQUEST            (6784)
  700|       |
  701|       |#define OP_URL_OPT(_request) ((char *)(_request))
  702|       |
  703|       |/*These macros trigger compilation errors or warnings if the wrong types are
  704|       |   provided to one of the URL options.*/
  705|       |#define OP_CHECK_INT(_x) ((void)((_x)==(opus_int32)0),(opus_int32)(_x))
  706|       |#define OP_CHECK_CONST_CHAR_PTR(_x) ((_x)+((_x)-(const char *)(_x)))
  707|       |#define OP_CHECK_SERVER_INFO_PTR(_x) ((_x)+((_x)-(OpusServerInfo *)(_x)))
  708|       |
  709|       |/**@endcond*/
  710|       |
  711|       |/**HTTP/Shoutcast/Icecast server information associated with a URL.*/
  712|       |struct OpusServerInfo{
  713|       |  /**The name of the server (icy-name/ice-name).
  714|       |     This is <code>NULL</code> if there was no <code>icy-name</code> or
  715|       |      <code>ice-name</code> header.*/
  716|       |  char        *name;
  717|       |  /**A short description of the server (icy-description/ice-description).
  718|       |     This is <code>NULL</code> if there was no <code>icy-description</code> or
  719|       |      <code>ice-description</code> header.*/
  720|       |  char        *description;
  721|       |  /**The genre the server falls under (icy-genre/ice-genre).
  722|       |     This is <code>NULL</code> if there was no <code>icy-genre</code> or
  723|       |      <code>ice-genre</code> header.*/
  724|       |  char        *genre;
  725|       |  /**The homepage for the server (icy-url/ice-url).
  726|       |     This is <code>NULL</code> if there was no <code>icy-url</code> or
  727|       |      <code>ice-url</code> header.*/
  728|       |  char        *url;
  729|       |  /**The software used by the origin server (Server).
  730|       |     This is <code>NULL</code> if there was no <code>Server</code> header.*/
  731|       |  char        *server;
  732|       |  /**The media type of the entity sent to the recepient (Content-Type).
  733|       |     This is <code>NULL</code> if there was no <code>Content-Type</code>
  734|       |      header.*/
  735|       |  char        *content_type;
  736|       |  /**The nominal stream bitrate in kbps (icy-br/ice-bitrate).
  737|       |     This is <code>-1</code> if there was no <code>icy-br</code> or
  738|       |      <code>ice-bitrate</code> header.*/
  739|       |  opus_int32   bitrate_kbps;
  740|       |  /**Flag indicating whether the server is public (<code>1</code>) or not
  741|       |      (<code>0</code>) (icy-pub/ice-public).
  742|       |     This is <code>-1</code> if there was no <code>icy-pub</code> or
  743|       |      <code>ice-public</code> header.*/
  744|       |  int          is_public;
  745|       |  /**Flag indicating whether the server is using HTTPS instead of HTTP.
  746|       |     This is <code>0</code> unless HTTPS is being used.
  747|       |     This may not match the protocol used in the original URL if there were
  748|       |      redirections.*/
  749|       |  int          is_ssl;
  750|       |};
  751|       |
  752|       |/**Initializes an #OpusServerInfo structure.
  753|       |   All fields are set as if the corresponding header was not available.
  754|       |   \param _info The #OpusServerInfo structure to initialize.
  755|       |   \note If you use this function, you must link against <tt>libopusurl</tt>.*/
  756|       |void opus_server_info_init(OpusServerInfo *_info) OP_ARG_NONNULL(1);
  757|       |
  758|       |/**Clears the #OpusServerInfo structure.
  759|       |   This should be called on an #OpusServerInfo structure after it is no longer
  760|       |    needed.
  761|       |   It will free all memory used by the structure members.
  762|       |   \param _info The #OpusServerInfo structure to clear.
  763|       |   \note If you use this function, you must link against <tt>libopusurl</tt>.*/
  764|       |void opus_server_info_clear(OpusServerInfo *_info) OP_ARG_NONNULL(1);
  765|       |
  766|       |/**Skip the certificate check when connecting via TLS/SSL (https).
  767|       |   \param _b <code>opus_int32</code>: Whether or not to skip the certificate
  768|       |              check.
  769|       |             The check will be skipped if \a _b is non-zero, and will not be
  770|       |              skipped if \a _b is zero.
  771|       |   \hideinitializer*/
  772|       |#define OP_SSL_SKIP_CERTIFICATE_CHECK(_b) \
  773|       | OP_URL_OPT(OP_SSL_SKIP_CERTIFICATE_CHECK_REQUEST),OP_CHECK_INT(_b)
  774|       |
  775|       |/**Proxy connections through the given host.
  776|       |   If no port is specified via #OP_HTTP_PROXY_PORT, the port number defaults
  777|       |    to 8080 (http-alt).
  778|       |   All proxy parameters are ignored for non-http and non-https URLs.
  779|       |   \param _host <code>const char *</code>: The proxy server hostname.
  780|       |                This may be <code>NULL</code> to disable the use of a proxy
  781|       |                 server.
  782|       |   \hideinitializer*/
  783|       |#define OP_HTTP_PROXY_HOST(_host) \
  784|       | OP_URL_OPT(OP_HTTP_PROXY_HOST_REQUEST),OP_CHECK_CONST_CHAR_PTR(_host)
  785|       |
  786|       |/**Use the given port when proxying connections.
  787|       |   This option only has an effect if #OP_HTTP_PROXY_HOST is specified with a
  788|       |    non-<code>NULL</code> \a _host.
  789|       |   If this option is not provided, the proxy port number defaults to 8080
  790|       |    (http-alt).
  791|       |   All proxy parameters are ignored for non-http and non-https URLs.
  792|       |   \param _port <code>opus_int32</code>: The proxy server port.
  793|       |                This must be in the range 0...65535 (inclusive), or the
  794|       |                 URL function this is passed to will fail.
  795|       |   \hideinitializer*/
  796|       |#define OP_HTTP_PROXY_PORT(_port) \
  797|       | OP_URL_OPT(OP_HTTP_PROXY_PORT_REQUEST),OP_CHECK_INT(_port)
  798|       |
  799|       |/**Use the given user name for authentication when proxying connections.
  800|       |   All proxy parameters are ignored for non-http and non-https URLs.
  801|       |   \param _user const char *: The proxy server user name.
  802|       |                              This may be <code>NULL</code> to disable proxy
  803|       |                               authentication.
  804|       |                              A non-<code>NULL</code> value only has an effect
  805|       |                               if #OP_HTTP_PROXY_HOST and #OP_HTTP_PROXY_PASS
  806|       |                               are also specified with non-<code>NULL</code>
  807|       |                               arguments.
  808|       |   \hideinitializer*/
  809|       |#define OP_HTTP_PROXY_USER(_user) \
  810|       | OP_URL_OPT(OP_HTTP_PROXY_USER_REQUEST),OP_CHECK_CONST_CHAR_PTR(_user)
  811|       |
  812|       |/**Use the given password for authentication when proxying connections.
  813|       |   All proxy parameters are ignored for non-http and non-https URLs.
  814|       |   \param _pass const char *: The proxy server password.
  815|       |                              This may be <code>NULL</code> to disable proxy
  816|       |                               authentication.
  817|       |                              A non-<code>NULL</code> value only has an effect
  818|       |                               if #OP_HTTP_PROXY_HOST and #OP_HTTP_PROXY_USER
  819|       |                               are also specified with non-<code>NULL</code>
  820|       |                               arguments.
  821|       |   \hideinitializer*/
  822|       |#define OP_HTTP_PROXY_PASS(_pass) \
  823|       | OP_URL_OPT(OP_HTTP_PROXY_PASS_REQUEST),OP_CHECK_CONST_CHAR_PTR(_pass)
  824|       |
  825|       |/**Parse information about the streaming server (if any) and return it.
  826|       |   Very little validation is done.
  827|       |   In particular, OpusServerInfo::url may not be a valid URL,
  828|       |    OpusServerInfo::bitrate_kbps may not really be in kbps, and
  829|       |    OpusServerInfo::content_type may not be a valid MIME type.
  830|       |   The character set of the string fields is not specified anywhere, and should
  831|       |    not be assumed to be valid UTF-8.
  832|       |   \param _info OpusServerInfo *: Returns information about the server.
  833|       |                                  If there is any error opening the stream, the
  834|       |                                   contents of this structure remain
  835|       |                                   unmodified.
  836|       |                                  On success, fills in the structure with the
  837|       |                                   server information that was available, if
  838|       |                                   any.
  839|       |                                  After a successful return, the contents of
  840|       |                                   this structure should be freed by calling
  841|       |                                   opus_server_info_clear().
  842|       |   \hideinitializer*/
  843|       |#define OP_GET_SERVER_INFO(_info) \
  844|       | OP_URL_OPT(OP_GET_SERVER_INFO_REQUEST),OP_CHECK_SERVER_INFO_PTR(_info)
  845|       |
  846|       |/*@}*/
  847|       |/*@}*/
  848|       |
  849|       |/**\defgroup stream_callbacks Abstract Stream Reading Interface*/
  850|       |/*@{*/
  851|       |/**\name Functions for reading from streams
  852|       |   These functions define the interface used to read from and seek in a stream
  853|       |    of data.
  854|       |   A stream does not need to implement seeking, but the decoder will not be
  855|       |    able to seek if it does not do so.
  856|       |   These functions also include some convenience routines for working with
  857|       |    standard <code>FILE</code> pointers, complete streams stored in a single
  858|       |    block of memory, or URLs.*/
  859|       |/*@{*/
  860|       |
  861|       |/**Reads up to \a _nbytes bytes of data from \a _stream.
  862|       |   \param      _stream The stream to read from.
  863|       |   \param[out] _ptr    The buffer to store the data in.
  864|       |   \param      _nbytes The maximum number of bytes to read.
  865|       |                       This function may return fewer, though it will not
  866|       |                        return zero unless it reaches end-of-file.
  867|       |   \return The number of bytes successfully read, or a negative value on
  868|       |            error.*/
  869|       |typedef int (*op_read_func)(void *_stream,unsigned char *_ptr,int _nbytes);
  870|       |
  871|       |/**Sets the position indicator for \a _stream.
  872|       |   The new position, measured in bytes, is obtained by adding \a _offset
  873|       |    bytes to the position specified by \a _whence.
  874|       |   If \a _whence is set to <code>SEEK_SET</code>, <code>SEEK_CUR</code>, or
  875|       |    <code>SEEK_END</code>, the offset is relative to the start of the stream,
  876|       |    the current position indicator, or end-of-file, respectively.
  877|       |   \retval 0  Success.
  878|       |   \retval -1 Seeking is not supported or an error occurred.
  879|       |              <code>errno</code> need not be set.*/
  880|       |typedef int (*op_seek_func)(void *_stream,opus_int64 _offset,int _whence);
  881|       |
  882|       |/**Obtains the current value of the position indicator for \a _stream.
  883|       |   \return The current position indicator.*/
  884|       |typedef opus_int64 (*op_tell_func)(void *_stream);
  885|       |
  886|       |/**Closes the underlying stream.
  887|       |   \retval 0   Success.
  888|       |   \retval EOF An error occurred.
  889|       |               <code>errno</code> need not be set.*/
  890|       |typedef int (*op_close_func)(void *_stream);
  891|       |
  892|       |/**The callbacks used to access non-<code>FILE</code> stream resources.
  893|       |   The function prototypes are basically the same as for the stdio functions
  894|       |    <code>fread()</code>, <code>fseek()</code>, <code>ftell()</code>, and
  895|       |    <code>fclose()</code>.
  896|       |   The differences are that the <code>FILE *</code> arguments have been
  897|       |    replaced with a <code>void *</code>, which is to be used as a pointer to
  898|       |    whatever internal data these functions might need, that #seek and #tell
  899|       |    take and return 64-bit offsets, and that #seek <em>must</em> return -1 if
  900|       |    the stream is unseekable.*/
  901|       |struct OpusFileCallbacks{
  902|       |  /**Used to read data from the stream.
  903|       |     This must not be <code>NULL</code>.*/
  904|       |  op_read_func  read;
  905|       |  /**Used to seek in the stream.
  906|       |     This may be <code>NULL</code> if seeking is not implemented.*/
  907|       |  op_seek_func  seek;
  908|       |  /**Used to return the current read position in the stream.
  909|       |     This may be <code>NULL</code> if seeking is not implemented.*/
  910|       |  op_tell_func  tell;
  911|       |  /**Used to close the stream when the decoder is freed.
  912|       |     This may be <code>NULL</code> to leave the stream open.*/
  913|       |  op_close_func close;
  914|       |};
  915|       |
  916|       |/**Opens a stream with <code>fopen()</code> and fills in a set of callbacks
  917|       |    that can be used to access it.
  918|       |   This is useful to avoid writing your own portable 64-bit seeking wrappers,
  919|       |    and also avoids cross-module linking issues on Windows, where a
  920|       |    <code>FILE *</code> must be accessed by routines defined in the same module
  921|       |    that opened it.
  922|       |   \param[out] _cb   The callbacks to use for this file.
  923|       |                     If there is an error opening the file, nothing will be
  924|       |                      filled in here.
  925|       |   \param      _path The path to the file to open.
  926|       |                     On Windows, this string must be UTF-8 (to allow access to
  927|       |                      files whose names cannot be represented in the current
  928|       |                      MBCS code page).
  929|       |                     All other systems use the native character encoding.
  930|       |   \param      _mode The mode to open the file in.
  931|       |   \return A stream handle to use with the callbacks, or <code>NULL</code> on
  932|       |            error.*/
  933|       |OP_WARN_UNUSED_RESULT void *op_fopen(OpusFileCallbacks *_cb,
  934|       | const char *_path,const char *_mode) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2)
  935|       | OP_ARG_NONNULL(3);
  936|       |
  937|       |/**Opens a stream with <code>fdopen()</code> and fills in a set of callbacks
  938|       |    that can be used to access it.
  939|       |   This is useful to avoid writing your own portable 64-bit seeking wrappers,
  940|       |    and also avoids cross-module linking issues on Windows, where a
  941|       |    <code>FILE *</code> must be accessed by routines defined in the same module
  942|       |    that opened it.
  943|       |   \param[out] _cb   The callbacks to use for this file.
  944|       |                     If there is an error opening the file, nothing will be
  945|       |                      filled in here.
  946|       |   \param      _fd   The file descriptor to open.
  947|       |   \param      _mode The mode to open the file in.
  948|       |   \return A stream handle to use with the callbacks, or <code>NULL</code> on
  949|       |            error.*/
  950|       |OP_WARN_UNUSED_RESULT void *op_fdopen(OpusFileCallbacks *_cb,
  951|       | int _fd,const char *_mode) OP_ARG_NONNULL(1) OP_ARG_NONNULL(3);
  952|       |
  953|       |/**Opens a stream with <code>freopen()</code> and fills in a set of callbacks
  954|       |    that can be used to access it.
  955|       |   This is useful to avoid writing your own portable 64-bit seeking wrappers,
  956|       |    and also avoids cross-module linking issues on Windows, where a
  957|       |    <code>FILE *</code> must be accessed by routines defined in the same module
  958|       |    that opened it.
  959|       |   \param[out] _cb     The callbacks to use for this file.
  960|       |                       If there is an error opening the file, nothing will be
  961|       |                        filled in here.
  962|       |   \param      _path   The path to the file to open.
  963|       |                       On Windows, this string must be UTF-8 (to allow access
  964|       |                        to files whose names cannot be represented in the
  965|       |                        current MBCS code page).
  966|       |                       All other systems use the native character encoding.
  967|       |   \param      _mode   The mode to open the file in.
  968|       |   \param      _stream A stream previously returned by op_fopen(), op_fdopen(),
  969|       |                        or op_freopen().
  970|       |   \return A stream handle to use with the callbacks, or <code>NULL</code> on
  971|       |            error.*/
  972|       |OP_WARN_UNUSED_RESULT void *op_freopen(OpusFileCallbacks *_cb,
  973|       | const char *_path,const char *_mode,void *_stream) OP_ARG_NONNULL(1)
  974|       | OP_ARG_NONNULL(2) OP_ARG_NONNULL(3) OP_ARG_NONNULL(4);
  975|       |
  976|       |/**Creates a stream that reads from the given block of memory.
  977|       |   This block of memory must contain the complete stream to decode.
  978|       |   This is useful for caching small streams (e.g., sound effects) in RAM.
  979|       |   \param[out] _cb   The callbacks to use for this stream.
  980|       |                     If there is an error creating the stream, nothing will be
  981|       |                      filled in here.
  982|       |   \param      _data The block of memory to read from.
  983|       |   \param      _size The size of the block of memory.
  984|       |   \return A stream handle to use with the callbacks, or <code>NULL</code> on
  985|       |            error.*/
  986|       |OP_WARN_UNUSED_RESULT void *op_mem_stream_create(OpusFileCallbacks *_cb,
  987|       | const unsigned char *_data,size_t _size) OP_ARG_NONNULL(1);
  988|       |
  989|       |/**Creates a stream that reads from the given URL.
  990|       |   This function behaves identically to op_url_stream_create(), except that it
  991|       |    takes a va_list instead of a variable number of arguments.
  992|       |   It does not call the <code>va_end</code> macro, and because it invokes the
  993|       |    <code>va_arg</code> macro, the value of \a _ap is undefined after the call.
  994|       |   \note If you use this function, you must link against <tt>libopusurl</tt>.
  995|       |   \param[out]    _cb  The callbacks to use for this stream.
  996|       |                       If there is an error creating the stream, nothing will
  997|       |                        be filled in here.
  998|       |   \param         _url The URL to read from.
  999|       |                       Currently only the <file:>, <http:>, and <https:>
 1000|       |                        schemes are supported.
 1001|       |                       Both <http:> and <https:> may be disabled at compile
 1002|       |                        time, in which case opening such URLs will always fail.
 1003|       |                       Currently this only supports URIs.
 1004|       |                       IRIs should be converted to UTF-8 and URL-escaped, with
 1005|       |                        internationalized domain names encoded in punycode,
 1006|       |                        before passing them to this function.
 1007|       |   \param[in,out] _ap  A list of the \ref url_options "optional flags" to use.
 1008|       |                       This is a variable-length list of options terminated
 1009|       |                        with <code>NULL</code>.
 1010|       |   \return A stream handle to use with the callbacks, or <code>NULL</code> on
 1011|       |            error.*/
 1012|       |OP_WARN_UNUSED_RESULT void *op_url_stream_vcreate(OpusFileCallbacks *_cb,
 1013|       | const char *_url,va_list _ap) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2);
 1014|       |
 1015|       |/**Creates a stream that reads from the given URL.
 1016|       |   \note If you use this function, you must link against <tt>libopusurl</tt>.
 1017|       |   \param[out] _cb  The callbacks to use for this stream.
 1018|       |                    If there is an error creating the stream, nothing will be
 1019|       |                     filled in here.
 1020|       |   \param      _url The URL to read from.
 1021|       |                    Currently only the <file:>, <http:>, and <https:> schemes
 1022|       |                     are supported.
 1023|       |                    Both <http:> and <https:> may be disabled at compile time,
 1024|       |                     in which case opening such URLs will always fail.
 1025|       |                    Currently this only supports URIs.
 1026|       |                    IRIs should be converted to UTF-8 and URL-escaped, with
 1027|       |                     internationalized domain names encoded in punycode, before
 1028|       |                     passing them to this function.
 1029|       |   \param      ...  The \ref url_options "optional flags" to use.
 1030|       |                    This is a variable-length list of options terminated with
 1031|       |                     <code>NULL</code>.
 1032|       |   \return A stream handle to use with the callbacks, or <code>NULL</code> on
 1033|       |            error.*/
 1034|       |OP_WARN_UNUSED_RESULT void *op_url_stream_create(OpusFileCallbacks *_cb,
 1035|       | const char *_url,...) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2);
 1036|       |
 1037|       |/*@}*/
 1038|       |/*@}*/
 1039|       |
 1040|       |/**\defgroup stream_open_close Opening and Closing*/
 1041|       |/*@{*/
 1042|       |/**\name Functions for opening and closing streams
 1043|       |
 1044|       |   These functions allow you to test a stream to see if it is Opus, open it,
 1045|       |    and close it.
 1046|       |   Several flavors are provided for each of the built-in stream types, plus a
 1047|       |    more general version which takes a set of application-provided callbacks.*/
 1048|       |/*@{*/
 1049|       |
 1050|       |/**Test to see if this is an Opus stream.
 1051|       |   For good results, you will need at least 57 bytes (for a pure Opus-only
 1052|       |    stream).
 1053|       |   Something like 512 bytes will give more reliable results for multiplexed
 1054|       |    streams.
 1055|       |   This function is meant to be a quick-rejection filter.
 1056|       |   Its purpose is not to guarantee that a stream is a valid Opus stream, but to
 1057|       |    ensure that it looks enough like Opus that it isn't going to be recognized
 1058|       |    as some other format (except possibly an Opus stream that is also
 1059|       |    multiplexed with other codecs, such as video).
 1060|       |   \param[out] _head     The parsed ID header contents.
 1061|       |                         You may pass <code>NULL</code> if you do not need
 1062|       |                          this information.
 1063|       |                         If the function fails, the contents of this structure
 1064|       |                          remain untouched.
 1065|       |   \param _initial_data  An initial buffer of data from the start of the
 1066|       |                          stream.
 1067|       |   \param _initial_bytes The number of bytes in \a _initial_data.
 1068|       |   \return 0 if the data appears to be Opus, or a negative value on error.
 1069|       |   \retval #OP_FALSE      There was not enough data to tell if this was an Opus
 1070|       |                           stream or not.
 1071|       |   \retval #OP_EFAULT     An internal memory allocation failed.
 1072|       |   \retval #OP_EIMPL      The stream used a feature that is not implemented,
 1073|       |                           such as an unsupported channel family.
 1074|       |   \retval #OP_ENOTFORMAT If the data did not contain a recognizable ID
 1075|       |                           header for an Opus stream.
 1076|       |   \retval #OP_EVERSION   If the version field signaled a version this library
 1077|       |                           does not know how to parse.
 1078|       |   \retval #OP_EBADHEADER The ID header was not properly formatted or contained
 1079|       |                           illegal values.*/
 1080|       |int op_test(OpusHead *_head,
 1081|       | const unsigned char *_initial_data,size_t _initial_bytes);
 1082|       |
 1083|       |/**Open a stream from the given file path.
 1084|       |   \param      _path  The path to the file to open.
 1085|       |   \param[out] _error Returns 0 on success, or a failure code on error.
 1086|       |                      You may pass in <code>NULL</code> if you don't want the
 1087|       |                       failure code.
 1088|       |                      The failure code will be #OP_EFAULT if the file could not
 1089|       |                       be opened, or one of the other failure codes from
 1090|       |                       op_open_callbacks() otherwise.
 1091|       |   \return A freshly opened \c OggOpusFile, or <code>NULL</code> on error.*/
 1092|       |OP_WARN_UNUSED_RESULT OggOpusFile *op_open_file(const char *_path,int *_error)
 1093|       | OP_ARG_NONNULL(1);
 1094|       |
 1095|       |/**Open a stream from a memory buffer.
 1096|       |   \param      _data  The memory buffer to open.
 1097|       |   \param      _size  The number of bytes in the buffer.
 1098|       |   \param[out] _error Returns 0 on success, or a failure code on error.
 1099|       |                      You may pass in <code>NULL</code> if you don't want the
 1100|       |                       failure code.
 1101|       |                      See op_open_callbacks() for a full list of failure codes.
 1102|       |   \return A freshly opened \c OggOpusFile, or <code>NULL</code> on error.*/
 1103|       |OP_WARN_UNUSED_RESULT OggOpusFile *op_open_memory(const unsigned char *_data,
 1104|       | size_t _size,int *_error);
 1105|       |
 1106|       |/**Open a stream from a URL.
 1107|       |   This function behaves identically to op_open_url(), except that it
 1108|       |    takes a va_list instead of a variable number of arguments.
 1109|       |   It does not call the <code>va_end</code> macro, and because it invokes the
 1110|       |    <code>va_arg</code> macro, the value of \a _ap is undefined after the call.
 1111|       |   \note If you use this function, you must link against <tt>libopusurl</tt>.
 1112|       |   \param         _url   The URL to open.
 1113|       |                         Currently only the <file:>, <http:>, and <https:>
 1114|       |                          schemes are supported.
 1115|       |                         Both <http:> and <https:> may be disabled at compile
 1116|       |                          time, in which case opening such URLs will always
 1117|       |                          fail.
 1118|       |                         Currently this only supports URIs.
 1119|       |                         IRIs should be converted to UTF-8 and URL-escaped,
 1120|       |                          with internationalized domain names encoded in
 1121|       |                          punycode, before passing them to this function.
 1122|       |   \param[out]    _error Returns 0 on success, or a failure code on error.
 1123|       |                         You may pass in <code>NULL</code> if you don't want
 1124|       |                          the failure code.
 1125|       |                         See op_open_callbacks() for a full list of failure
 1126|       |                          codes.
 1127|       |   \param[in,out] _ap    A list of the \ref url_options "optional flags" to
 1128|       |                          use.
 1129|       |                         This is a variable-length list of options terminated
 1130|       |                          with <code>NULL</code>.
 1131|       |   \return A freshly opened \c OggOpusFile, or <code>NULL</code> on error.*/
 1132|       |OP_WARN_UNUSED_RESULT OggOpusFile *op_vopen_url(const char *_url,
 1133|       | int *_error,va_list _ap) OP_ARG_NONNULL(1);
 1134|       |
 1135|       |/**Open a stream from a URL.
 1136|       |   \note If you use this function, you must link against <tt>libopusurl</tt>.
 1137|       |   \param      _url   The URL to open.
 1138|       |                      Currently only the <file:>, <http:>, and <https:> schemes
 1139|       |                       are supported.
 1140|       |                      Both <http:> and <https:> may be disabled at compile
 1141|       |                       time, in which case opening such URLs will always fail.
 1142|       |                      Currently this only supports URIs.
 1143|       |                      IRIs should be converted to UTF-8 and URL-escaped, with
 1144|       |                       internationalized domain names encoded in punycode,
 1145|       |                       before passing them to this function.
 1146|       |   \param[out] _error Returns 0 on success, or a failure code on error.
 1147|       |                      You may pass in <code>NULL</code> if you don't want the
 1148|       |                       failure code.
 1149|       |                      See op_open_callbacks() for a full list of failure codes.
 1150|       |   \param      ...    The \ref url_options "optional flags" to use.
 1151|       |                      This is a variable-length list of options terminated with
 1152|       |                       <code>NULL</code>.
 1153|       |   \return A freshly opened \c OggOpusFile, or <code>NULL</code> on error.*/
 1154|       |OP_WARN_UNUSED_RESULT OggOpusFile *op_open_url(const char *_url,
 1155|       | int *_error,...) OP_ARG_NONNULL(1);
 1156|       |
 1157|       |/**Open a stream using the given set of callbacks to access it.
 1158|       |   \param _stream        The stream to read from (e.g., a <code>FILE *</code>).
 1159|       |                         This value will be passed verbatim as the first
 1160|       |                          argument to all of the callbacks.
 1161|       |   \param _cb            The callbacks with which to access the stream.
 1162|       |                         <code><a href="#op_read_func">read()</a></code> must
 1163|       |                          be implemented.
 1164|       |                         <code><a href="#op_seek_func">seek()</a></code> and
 1165|       |                          <code><a href="#op_tell_func">tell()</a></code> may
 1166|       |                          be <code>NULL</code>, or may always return -1 to
 1167|       |                          indicate a stream is unseekable, but if
 1168|       |                          <code><a href="#op_seek_func">seek()</a></code> is
 1169|       |                          implemented and succeeds on a particular stream, then
 1170|       |                          <code><a href="#op_tell_func">tell()</a></code> must
 1171|       |                          also.
 1172|       |                         <code><a href="#op_close_func">close()</a></code> may
 1173|       |                          be <code>NULL</code>, but if it is not, it will be
 1174|       |                          called when the \c OggOpusFile is destroyed by
 1175|       |                          op_free().
 1176|       |                         It will not be called if op_open_callbacks() fails
 1177|       |                          with an error.
 1178|       |   \param _initial_data  An initial buffer of data from the start of the
 1179|       |                          stream.
 1180|       |                         Applications can read some number of bytes from the
 1181|       |                          start of the stream to help identify this as an Opus
 1182|       |                          stream, and then provide them here to allow the
 1183|       |                          stream to be opened, even if it is unseekable.
 1184|       |   \param _initial_bytes The number of bytes in \a _initial_data.
 1185|       |                         If the stream is seekable, its current position (as
 1186|       |                          reported by
 1187|       |                          <code><a href="#opus_tell_func">tell()</a></code>
 1188|       |                          at the start of this function) must be equal to
 1189|       |                          \a _initial_bytes.
 1190|       |                         Otherwise, seeking to absolute positions will
 1191|       |                          generate inconsistent results.
 1192|       |   \param[out] _error    Returns 0 on success, or a failure code on error.
 1193|       |                         You may pass in <code>NULL</code> if you don't want
 1194|       |                          the failure code.
 1195|       |                         The failure code will be one of
 1196|       |                         <dl>
 1197|       |                           <dt>#OP_EREAD</dt>
 1198|       |                           <dd>An underlying read, seek, or tell operation
 1199|       |                            failed when it should have succeeded, or we failed
 1200|       |                            to find data in the stream we had seen before.</dd>
 1201|       |                           <dt>#OP_EFAULT</dt>
 1202|       |                           <dd>There was a memory allocation failure, or an
 1203|       |                            internal library error.</dd>
 1204|       |                           <dt>#OP_EIMPL</dt>
 1205|       |                           <dd>The stream used a feature that is not
 1206|       |                            implemented, such as an unsupported channel
 1207|       |                            family.</dd>
 1208|       |                           <dt>#OP_EINVAL</dt>
 1209|       |                           <dd><code><a href="#op_seek_func">seek()</a></code>
 1210|       |                            was implemented and succeeded on this source, but
 1211|       |                            <code><a href="#op_tell_func">tell()</a></code>
 1212|       |                            did not, or the starting position indicator was
 1213|       |                            not equal to \a _initial_bytes.</dd>
 1214|       |                           <dt>#OP_ENOTFORMAT</dt>
 1215|       |                           <dd>The stream contained a link that did not have
 1216|       |                            any logical Opus streams in it.</dd>
 1217|       |                           <dt>#OP_EBADHEADER</dt>
 1218|       |                           <dd>A required header packet was not properly
 1219|       |                            formatted, contained illegal values, or was missing
 1220|       |                            altogether.</dd>
 1221|       |                           <dt>#OP_EVERSION</dt>
 1222|       |                           <dd>An ID header contained an unrecognized version
 1223|       |                            number.</dd>
 1224|       |                           <dt>#OP_EBADLINK</dt>
 1225|       |                           <dd>We failed to find data we had seen before after
 1226|       |                            seeking.</dd>
 1227|       |                           <dt>#OP_EBADTIMESTAMP</dt>
 1228|       |                           <dd>The first or last timestamp in a link failed
 1229|       |                            basic validity checks.</dd>
 1230|       |                         </dl>
 1231|       |   \return A freshly opened \c OggOpusFile, or <code>NULL</code> on error.
 1232|       |           <tt>libopusfile</tt> does <em>not</em> take ownership of the stream
 1233|       |            if the call fails.
 1234|       |           The calling application is responsible for closing the stream if
 1235|       |            this call returns an error.*/
 1236|       |OP_WARN_UNUSED_RESULT OggOpusFile *op_open_callbacks(void *_stream,
 1237|       | const OpusFileCallbacks *_cb,const unsigned char *_initial_data,
 1238|       | size_t _initial_bytes,int *_error) OP_ARG_NONNULL(2);
 1239|       |
 1240|       |/**Partially open a stream from the given file path.
 1241|       |   \see op_test_callbacks
 1242|       |   \param      _path  The path to the file to open.
 1243|       |   \param[out] _error Returns 0 on success, or a failure code on error.
 1244|       |                      You may pass in <code>NULL</code> if you don't want the
 1245|       |                       failure code.
 1246|       |                      The failure code will be #OP_EFAULT if the file could not
 1247|       |                       be opened, or one of the other failure codes from
 1248|       |                       op_open_callbacks() otherwise.
 1249|       |   \return A partially opened \c OggOpusFile, or <code>NULL</code> on error.*/
 1250|       |OP_WARN_UNUSED_RESULT OggOpusFile *op_test_file(const char *_path,int *_error)
 1251|       | OP_ARG_NONNULL(1);
 1252|       |
 1253|       |/**Partially open a stream from a memory buffer.
 1254|       |   \see op_test_callbacks
 1255|       |   \param      _data  The memory buffer to open.
 1256|       |   \param      _size  The number of bytes in the buffer.
 1257|       |   \param[out] _error Returns 0 on success, or a failure code on error.
 1258|       |                      You may pass in <code>NULL</code> if you don't want the
 1259|       |                       failure code.
 1260|       |                      See op_open_callbacks() for a full list of failure codes.
 1261|       |   \return A partially opened \c OggOpusFile, or <code>NULL</code> on error.*/
 1262|       |OP_WARN_UNUSED_RESULT OggOpusFile *op_test_memory(const unsigned char *_data,
 1263|       | size_t _size,int *_error);
 1264|       |
 1265|       |/**Partially open a stream from a URL.
 1266|       |   This function behaves identically to op_test_url(), except that it
 1267|       |    takes a va_list instead of a variable number of arguments.
 1268|       |   It does not call the <code>va_end</code> macro, and because it invokes the
 1269|       |    <code>va_arg</code> macro, the value of \a _ap is undefined after the call.
 1270|       |   \note If you use this function, you must link against <tt>libopusurl</tt>.
 1271|       |   \see op_test_url
 1272|       |   \see op_test_callbacks
 1273|       |   \param         _url    The URL to open.
 1274|       |                          Currently only the <file:>, <http:>, and <https:>
 1275|       |                           schemes are supported.
 1276|       |                          Both <http:> and <https:> may be disabled at compile
 1277|       |                           time, in which case opening such URLs will always
 1278|       |                           fail.
 1279|       |                          Currently this only supports URIs.
 1280|       |                          IRIs should be converted to UTF-8 and URL-escaped,
 1281|       |                           with internationalized domain names encoded in
 1282|       |                           punycode, before passing them to this function.
 1283|       |   \param[out]    _error  Returns 0 on success, or a failure code on error.
 1284|       |                          You may pass in <code>NULL</code> if you don't want
 1285|       |                           the failure code.
 1286|       |                          See op_open_callbacks() for a full list of failure
 1287|       |                           codes.
 1288|       |   \param[in,out] _ap     A list of the \ref url_options "optional flags" to
 1289|       |                           use.
 1290|       |                          This is a variable-length list of options terminated
 1291|       |                           with <code>NULL</code>.
 1292|       |   \return A partially opened \c OggOpusFile, or <code>NULL</code> on error.*/
 1293|       |OP_WARN_UNUSED_RESULT OggOpusFile *op_vtest_url(const char *_url,
 1294|       | int *_error,va_list _ap) OP_ARG_NONNULL(1);
 1295|       |
 1296|       |/**Partially open a stream from a URL.
 1297|       |   \note If you use this function, you must link against <tt>libopusurl</tt>.
 1298|       |   \see op_test_callbacks
 1299|       |   \param      _url    The URL to open.
 1300|       |                       Currently only the <file:>, <http:>, and <https:>
 1301|       |                        schemes are supported.
 1302|       |                       Both <http:> and <https:> may be disabled at compile
 1303|       |                        time, in which case opening such URLs will always fail.
 1304|       |                       Currently this only supports URIs.
 1305|       |                       IRIs should be converted to UTF-8 and URL-escaped, with
 1306|       |                        internationalized domain names encoded in punycode,
 1307|       |                        before passing them to this function.
 1308|       |   \param[out] _error  Returns 0 on success, or a failure code on error.
 1309|       |                       You may pass in <code>NULL</code> if you don't want the
 1310|       |                        failure code.
 1311|       |                       See op_open_callbacks() for a full list of failure
 1312|       |                        codes.
 1313|       |   \param      ...     The \ref url_options "optional flags" to use.
 1314|       |                       This is a variable-length list of options terminated
 1315|       |                        with <code>NULL</code>.
 1316|       |   \return A partially opened \c OggOpusFile, or <code>NULL</code> on error.*/
 1317|       |OP_WARN_UNUSED_RESULT OggOpusFile *op_test_url(const char *_url,
 1318|       | int *_error,...) OP_ARG_NONNULL(1);
 1319|       |
 1320|       |/**Partially open a stream using the given set of callbacks to access it.
 1321|       |   This tests for Opusness and loads the headers for the first link.
 1322|       |   It does not seek (although it tests for seekability).
 1323|       |   You can query a partially open stream for the few pieces of basic
 1324|       |    information returned by op_serialno(), op_channel_count(), op_head(), and
 1325|       |    op_tags() (but only for the first link).
 1326|       |   You may also determine if it is seekable via a call to op_seekable().
 1327|       |   You cannot read audio from the stream, seek, get the size or duration,
 1328|       |    get information from links other than the first one, or even get the total
 1329|       |    number of links until you finish opening the stream with op_test_open().
 1330|       |   If you do not need to do any of these things, you can dispose of it with
 1331|       |    op_free() instead.
 1332|       |
 1333|       |   This function is provided mostly to simplify porting existing code that used
 1334|       |    <tt>libvorbisfile</tt>.
 1335|       |   For new code, you are likely better off using op_test() instead, which
 1336|       |    is less resource-intensive, requires less data to succeed, and imposes a
 1337|       |    hard limit on the amount of data it examines (important for unseekable
 1338|       |    streams, where all such data must be buffered until you are sure of the
 1339|       |    stream type).
 1340|       |   \param _stream        The stream to read from (e.g., a <code>FILE *</code>).
 1341|       |                         This value will be passed verbatim as the first
 1342|       |                          argument to all of the callbacks.
 1343|       |   \param _cb            The callbacks with which to access the stream.
 1344|       |                         <code><a href="#op_read_func">read()</a></code> must
 1345|       |                          be implemented.
 1346|       |                         <code><a href="#op_seek_func">seek()</a></code> and
 1347|       |                          <code><a href="#op_tell_func">tell()</a></code> may
 1348|       |                          be <code>NULL</code>, or may always return -1 to
 1349|       |                          indicate a stream is unseekable, but if
 1350|       |                          <code><a href="#op_seek_func">seek()</a></code> is
 1351|       |                          implemented and succeeds on a particular stream, then
 1352|       |                          <code><a href="#op_tell_func">tell()</a></code> must
 1353|       |                          also.
 1354|       |                         <code><a href="#op_close_func">close()</a></code> may
 1355|       |                          be <code>NULL</code>, but if it is not, it will be
 1356|       |                          called when the \c OggOpusFile is destroyed by
 1357|       |                          op_free().
 1358|       |                         It will not be called if op_open_callbacks() fails
 1359|       |                          with an error.
 1360|       |   \param _initial_data  An initial buffer of data from the start of the
 1361|       |                          stream.
 1362|       |                         Applications can read some number of bytes from the
 1363|       |                          start of the stream to help identify this as an Opus
 1364|       |                          stream, and then provide them here to allow the
 1365|       |                          stream to be tested more thoroughly, even if it is
 1366|       |                          unseekable.
 1367|       |   \param _initial_bytes The number of bytes in \a _initial_data.
 1368|       |                         If the stream is seekable, its current position (as
 1369|       |                          reported by
 1370|       |                          <code><a href="#opus_tell_func">tell()</a></code>
 1371|       |                          at the start of this function) must be equal to
 1372|       |                          \a _initial_bytes.
 1373|       |                         Otherwise, seeking to absolute positions will
 1374|       |                          generate inconsistent results.
 1375|       |   \param[out] _error    Returns 0 on success, or a failure code on error.
 1376|       |                         You may pass in <code>NULL</code> if you don't want
 1377|       |                          the failure code.
 1378|       |                         See op_open_callbacks() for a full list of failure
 1379|       |                          codes.
 1380|       |   \return A partially opened \c OggOpusFile, or <code>NULL</code> on error.
 1381|       |           <tt>libopusfile</tt> does <em>not</em> take ownership of the stream
 1382|       |            if the call fails.
 1383|       |           The calling application is responsible for closing the stream if
 1384|       |            this call returns an error.*/
 1385|       |OP_WARN_UNUSED_RESULT OggOpusFile *op_test_callbacks(void *_stream,
 1386|       | const OpusFileCallbacks *_cb,const unsigned char *_initial_data,
 1387|       | size_t _initial_bytes,int *_error) OP_ARG_NONNULL(2);
 1388|       |
 1389|       |/**Finish opening a stream partially opened with op_test_callbacks() or one of
 1390|       |    the associated convenience functions.
 1391|       |   If this function fails, you are still responsible for freeing the
 1392|       |    \c OggOpusFile with op_free().
 1393|       |   \param _of The \c OggOpusFile to finish opening.
 1394|       |   \return 0 on success, or a negative value on error.
 1395|       |   \retval #OP_EREAD         An underlying read, seek, or tell operation failed
 1396|       |                              when it should have succeeded.
 1397|       |   \retval #OP_EFAULT        There was a memory allocation failure, or an
 1398|       |                              internal library error.
 1399|       |   \retval #OP_EIMPL         The stream used a feature that is not implemented,
 1400|       |                              such as an unsupported channel family.
 1401|       |   \retval #OP_EINVAL        The stream was not partially opened with
 1402|       |                              op_test_callbacks() or one of the associated
 1403|       |                              convenience functions.
 1404|       |   \retval #OP_ENOTFORMAT    The stream contained a link that did not have any
 1405|       |                              logical Opus streams in it.
 1406|       |   \retval #OP_EBADHEADER    A required header packet was not properly
 1407|       |                              formatted, contained illegal values, or was
 1408|       |                              missing altogether.
 1409|       |   \retval #OP_EVERSION      An ID header contained an unrecognized version
 1410|       |                              number.
 1411|       |   \retval #OP_EBADLINK      We failed to find data we had seen before after
 1412|       |                              seeking.
 1413|       |   \retval #OP_EBADTIMESTAMP The first or last timestamp in a link failed basic
 1414|       |                              validity checks.*/
 1415|       |int op_test_open(OggOpusFile *_of) OP_ARG_NONNULL(1);
 1416|       |
 1417|       |/**Release all memory used by an \c OggOpusFile.
 1418|       |   \param _of The \c OggOpusFile to free.*/
 1419|       |void op_free(OggOpusFile *_of);
 1420|       |
 1421|       |/*@}*/
 1422|       |/*@}*/
 1423|       |
 1424|       |/**\defgroup stream_info Stream Information*/
 1425|       |/*@{*/
 1426|       |/**\name Functions for obtaining information about streams
 1427|       |
 1428|       |   These functions allow you to get basic information about a stream, including
 1429|       |    seekability, the number of links (for chained streams), plus the size,
 1430|       |    duration, bitrate, header parameters, and meta information for each link
 1431|       |    (or, where available, the stream as a whole).
 1432|       |   Some of these (size, duration) are only available for seekable streams.
 1433|       |   You can also query the current stream position, link, and playback time,
 1434|       |    and instantaneous bitrate during playback.
 1435|       |
 1436|       |   Some of these functions may be used successfully on the partially open
 1437|       |    streams returned by op_test_callbacks() or one of the associated
 1438|       |    convenience functions.
 1439|       |   Their documention will indicate so explicitly.*/
 1440|       |/*@{*/
 1441|       |
 1442|       |/**Returns whether or not the stream being read is seekable.
 1443|       |   This is true if
 1444|       |   <ol>
 1445|       |   <li>The <code><a href="#op_seek_func">seek()</a></code> and
 1446|       |    <code><a href="#op_tell_func">tell()</a></code> callbacks are both
 1447|       |    non-<code>NULL</code>,</li>
 1448|       |   <li>The <code><a href="#op_seek_func">seek()</a></code> callback was
 1449|       |    successfully executed at least once, and</li>
 1450|       |   <li>The <code><a href="#op_tell_func">tell()</a></code> callback was
 1451|       |    successfully able to report the position indicator afterwards.</li>
 1452|       |   </ol>
 1453|       |   This function may be called on partially-opened streams.
 1454|       |   \param _of The \c OggOpusFile whose seekable status is to be returned.
 1455|       |   \return A non-zero value if seekable, and 0 if unseekable.*/
 1456|       |int op_seekable(const OggOpusFile *_of) OP_ARG_NONNULL(1);
 1457|       |
 1458|       |/**Returns the number of links in this chained stream.
 1459|       |   This function may be called on partially-opened streams, but it will always
 1460|       |    return 1.
 1461|       |   The actual number of links is not known until the stream is fully opened.
 1462|       |   \param _of The \c OggOpusFile from which to retrieve the link count.
 1463|       |   \return For fully-open seekable streams, this returns the total number of
 1464|       |            links in the whole stream, which will be at least 1.
 1465|       |           For partially-open or unseekable streams, this always returns 1.*/
 1466|       |int op_link_count(const OggOpusFile *_of) OP_ARG_NONNULL(1);
 1467|       |
 1468|       |/**Get the serial number of the given link in a (possibly-chained) Ogg Opus
 1469|       |    stream.
 1470|       |   This function may be called on partially-opened streams, but it will always
 1471|       |    return the serial number of the Opus stream in the first link.
 1472|       |   \param _of The \c OggOpusFile from which to retrieve the serial number.
 1473|       |   \param _li The index of the link whose serial number should be retrieved.
 1474|       |              Use a negative number to get the serial number of the current
 1475|       |               link.
 1476|       |   \return The serial number of the given link.
 1477|       |           If \a _li is greater than the total number of links, this returns
 1478|       |            the serial number of the last link.
 1479|       |           If the stream is not seekable, this always returns the serial number
 1480|       |            of the current link.*/
 1481|       |opus_uint32 op_serialno(const OggOpusFile *_of,int _li) OP_ARG_NONNULL(1);
 1482|       |
 1483|       |/**Get the channel count of the given link in a (possibly-chained) Ogg Opus
 1484|       |    stream.
 1485|       |   This is equivalent to <code>op_head(_of,_li)->channel_count</code>, but
 1486|       |    is provided for convenience.
 1487|       |   This function may be called on partially-opened streams, but it will always
 1488|       |    return the channel count of the Opus stream in the first link.
 1489|       |   \param _of The \c OggOpusFile from which to retrieve the channel count.
 1490|       |   \param _li The index of the link whose channel count should be retrieved.
 1491|       |              Use a negative number to get the channel count of the current
 1492|       |               link.
 1493|       |   \return The channel count of the given link.
 1494|       |           If \a _li is greater than the total number of links, this returns
 1495|       |            the channel count of the last link.
 1496|       |           If the stream is not seekable, this always returns the channel count
 1497|       |            of the current link.*/
 1498|       |int op_channel_count(const OggOpusFile *_of,int _li) OP_ARG_NONNULL(1);
 1499|       |
 1500|       |/**Get the total (compressed) size of the stream, or of an individual link in
 1501|       |    a (possibly-chained) Ogg Opus stream, including all headers and Ogg muxing
 1502|       |    overhead.
 1503|       |   \warning If the Opus stream (or link) is concurrently multiplexed with other
 1504|       |    logical streams (e.g., video), this returns the size of the entire stream
 1505|       |    (or link), not just the number of bytes in the first logical Opus stream.
 1506|       |   Returning the latter would require scanning the entire file.
 1507|       |   \param _of The \c OggOpusFile from which to retrieve the compressed size.
 1508|       |   \param _li The index of the link whose compressed size should be computed.
 1509|       |              Use a negative number to get the compressed size of the entire
 1510|       |               stream.
 1511|       |   \return The compressed size of the entire stream if \a _li is negative, the
 1512|       |            compressed size of link \a _li if it is non-negative, or a negative
 1513|       |            value on error.
 1514|       |           The compressed size of the entire stream may be smaller than that
 1515|       |            of the underlying stream if trailing garbage was detected in the
 1516|       |            file.
 1517|       |   \retval #OP_EINVAL The stream is not seekable (so we can't know the length),
 1518|       |                       \a _li wasn't less than the total number of links in
 1519|       |                       the stream, or the stream was only partially open.*/
 1520|       |opus_int64 op_raw_total(const OggOpusFile *_of,int _li) OP_ARG_NONNULL(1);
 1521|       |
 1522|       |/**Get the total PCM length (number of samples at 48 kHz) of the stream, or of
 1523|       |    an individual link in a (possibly-chained) Ogg Opus stream.
 1524|       |   Users looking for <code>op_time_total()</code> should use op_pcm_total()
 1525|       |    instead.
 1526|       |   Because timestamps in Opus are fixed at 48 kHz, there is no need for a
 1527|       |    separate function to convert this to seconds (and leaving it out avoids
 1528|       |    introducing floating point to the API, for those that wish to avoid it).
 1529|       |   \param _of The \c OggOpusFile from which to retrieve the PCM offset.
 1530|       |   \param _li The index of the link whose PCM length should be computed.
 1531|       |              Use a negative number to get the PCM length of the entire stream.
 1532|       |   \return The PCM length of the entire stream if \a _li is negative, the PCM
 1533|       |            length of link \a _li if it is non-negative, or a negative value on
 1534|       |            error.
 1535|       |   \retval #OP_EINVAL The stream is not seekable (so we can't know the length),
 1536|       |                       \a _li wasn't less than the total number of links in
 1537|       |                       the stream, or the stream was only partially open.*/
 1538|       |ogg_int64_t op_pcm_total(const OggOpusFile *_of,int _li) OP_ARG_NONNULL(1);
 1539|       |
 1540|       |/**Get the ID header information for the given link in a (possibly chained) Ogg
 1541|       |    Opus stream.
 1542|       |   This function may be called on partially-opened streams, but it will always
 1543|       |    return the ID header information of the Opus stream in the first link.
 1544|       |   \param _of The \c OggOpusFile from which to retrieve the ID header
 1545|       |               information.
 1546|       |   \param _li The index of the link whose ID header information should be
 1547|       |               retrieved.
 1548|       |              Use a negative number to get the ID header information of the
 1549|       |               current link.
 1550|       |              For an unseekable stream, \a _li is ignored, and the ID header
 1551|       |               information for the current link is always returned, if
 1552|       |               available.
 1553|       |   \return The contents of the ID header for the given link.*/
 1554|       |const OpusHead *op_head(const OggOpusFile *_of,int _li) OP_ARG_NONNULL(1);
 1555|       |
 1556|       |/**Get the comment header information for the given link in a (possibly
 1557|       |    chained) Ogg Opus stream.
 1558|       |   This function may be called on partially-opened streams, but it will always
 1559|       |    return the tags from the Opus stream in the first link.
 1560|       |   \param _of The \c OggOpusFile from which to retrieve the comment header
 1561|       |               information.
 1562|       |   \param _li The index of the link whose comment header information should be
 1563|       |               retrieved.
 1564|       |              Use a negative number to get the comment header information of
 1565|       |               the current link.
 1566|       |              For an unseekable stream, \a _li is ignored, and the comment
 1567|       |               header information for the current link is always returned, if
 1568|       |               available.
 1569|       |   \return The contents of the comment header for the given link, or
 1570|       |            <code>NULL</code> if this is an unseekable stream that encountered
 1571|       |            an invalid link.*/
 1572|       |const OpusTags *op_tags(const OggOpusFile *_of,int _li) OP_ARG_NONNULL(1);
 1573|       |
 1574|       |/**Retrieve the index of the current link.
 1575|       |   This is the link that produced the data most recently read by
 1576|       |    op_read_float() or its associated functions, or, after a seek, the link
 1577|       |    that the seek target landed in.
 1578|       |   Reading more data may advance the link index (even on the first read after a
 1579|       |    seek).
 1580|       |   \param _of The \c OggOpusFile from which to retrieve the current link index.
 1581|       |   \return The index of the current link on success, or a negative value on
 1582|       |            failure.
 1583|       |           For seekable streams, this is a number between 0 (inclusive) and the
 1584|       |            value returned by op_link_count() (exclusive).
 1585|       |           For unseekable streams, this value starts at 0 and increments by one
 1586|       |            each time a new link is encountered (even though op_link_count()
 1587|       |            always returns 1).
 1588|       |   \retval #OP_EINVAL The stream was only partially open.*/
 1589|       |int op_current_link(const OggOpusFile *_of) OP_ARG_NONNULL(1);
 1590|       |
 1591|       |/**Computes the bitrate of the stream, or of an individual link in a
 1592|       |    (possibly-chained) Ogg Opus stream.
 1593|       |   The stream must be seekable to compute the bitrate.
 1594|       |   For unseekable streams, use op_bitrate_instant() to get periodic estimates.
 1595|       |   \warning If the Opus stream (or link) is concurrently multiplexed with other
 1596|       |    logical streams (e.g., video), this uses the size of the entire stream (or
 1597|       |    link) to compute the bitrate, not just the number of bytes in the first
 1598|       |    logical Opus stream.
 1599|       |   Returning the latter requires scanning the entire file, but this may be done
 1600|       |    by decoding the whole file and calling op_bitrate_instant() once at the
 1601|       |    end.
 1602|       |   Install a trivial decoding callback with op_set_decode_callback() if you
 1603|       |    wish to skip actual decoding during this process.
 1604|       |   \param _of The \c OggOpusFile from which to retrieve the bitrate.
 1605|       |   \param _li The index of the link whose bitrate should be computed.
 1606|       |              Use a negative number to get the bitrate of the whole stream.
 1607|       |   \return The bitrate on success, or a negative value on error.
 1608|       |   \retval #OP_EINVAL The stream was only partially open, the stream was not
 1609|       |                       seekable, or \a _li was larger than the number of
 1610|       |                       links.*/
 1611|       |opus_int32 op_bitrate(const OggOpusFile *_of,int _li) OP_ARG_NONNULL(1);
 1612|       |
 1613|       |/**Compute the instantaneous bitrate, measured as the ratio of bits to playable
 1614|       |    samples decoded since a) the last call to op_bitrate_instant(), b) the last
 1615|       |    seek, or c) the start of playback, whichever was most recent.
 1616|       |   This will spike somewhat after a seek or at the start/end of a chain
 1617|       |    boundary, as pre-skip, pre-roll, and end-trimming causes samples to be
 1618|       |    decoded but not played.
 1619|       |   \param _of The \c OggOpusFile from which to retrieve the bitrate.
 1620|       |   \return The bitrate, in bits per second, or a negative value on error.
 1621|       |   \retval #OP_FALSE  No data has been decoded since any of the events
 1622|       |                       described above.
 1623|       |   \retval #OP_EINVAL The stream was only partially open.*/
 1624|       |opus_int32 op_bitrate_instant(OggOpusFile *_of) OP_ARG_NONNULL(1);
 1625|       |
 1626|       |/**Obtain the current value of the position indicator for \a _of.
 1627|       |   \param _of The \c OggOpusFile from which to retrieve the position indicator.
 1628|       |   \return The byte position that is currently being read from.
 1629|       |   \retval #OP_EINVAL The stream was only partially open.*/
 1630|       |opus_int64 op_raw_tell(const OggOpusFile *_of) OP_ARG_NONNULL(1);
 1631|       |
 1632|       |/**Obtain the PCM offset of the next sample to be read.
 1633|       |   If the stream is not properly timestamped, this might not increment by the
 1634|       |    proper amount between reads, or even return monotonically increasing
 1635|       |    values.
 1636|       |   \param _of The \c OggOpusFile from which to retrieve the PCM offset.
 1637|       |   \return The PCM offset of the next sample to be read.
 1638|       |   \retval #OP_EINVAL The stream was only partially open.*/
 1639|       |ogg_int64_t op_pcm_tell(const OggOpusFile *_of) OP_ARG_NONNULL(1);
 1640|       |
 1641|       |/*@}*/
 1642|       |/*@}*/
 1643|       |
 1644|       |/**\defgroup stream_seeking Seeking*/
 1645|       |/*@{*/
 1646|       |/**\name Functions for seeking in Opus streams
 1647|       |
 1648|       |   These functions let you seek in Opus streams, if the underlying stream
 1649|       |    support it.
 1650|       |   Seeking is implemented for all built-in stream I/O routines, though some
 1651|       |    individual streams may not be seekable (pipes, live HTTP streams, or HTTP
 1652|       |    streams from a server that does not support <code>Range</code> requests).
 1653|       |
 1654|       |   op_raw_seek() is the fastest: it is guaranteed to perform at most one
 1655|       |    physical seek, but, since the target is a byte position, makes no guarantee
 1656|       |    how close to a given time it will come.
 1657|       |   op_pcm_seek() provides sample-accurate seeking.
 1658|       |   The number of physical seeks it requires is still quite small (often 1 or
 1659|       |    2, even in highly variable bitrate streams).
 1660|       |
 1661|       |   Seeking in Opus requires decoding some pre-roll amount before playback to
 1662|       |    allow the internal state to converge (as if recovering from packet loss).
 1663|       |   This is handled internally by <tt>libopusfile</tt>, but means there is
 1664|       |    little extra overhead for decoding up to the exact position requested
 1665|       |    (since it must decode some amount of audio anyway).
 1666|       |   It also means that decoding after seeking may not return exactly the same
 1667|       |    values as would be obtained by decoding the stream straight through.
 1668|       |   However, such differences are expected to be smaller than the loss
 1669|       |    introduced by Opus's lossy compression.*/
 1670|       |/*@{*/
 1671|       |
 1672|       |/**Seek to a byte offset relative to the <b>compressed</b> data.
 1673|       |   This also scans packets to update the PCM cursor.
 1674|       |   It will cross a logical bitstream boundary, but only if it can't get any
 1675|       |    packets out of the tail of the link to which it seeks.
 1676|       |   \param _of          The \c OggOpusFile in which to seek.
 1677|       |   \param _byte_offset The byte position to seek to.
 1678|       |                       This must be between 0 and #op_raw_total(\a _of,\c -1)
 1679|       |                        (inclusive).
 1680|       |   \return 0 on success, or a negative error code on failure.
 1681|       |   \retval #OP_EREAD    The underlying seek operation failed.
 1682|       |   \retval #OP_EINVAL   The stream was only partially open, or the target was
 1683|       |                         outside the valid range for the stream.
 1684|       |   \retval #OP_ENOSEEK  This stream is not seekable.
 1685|       |   \retval #OP_EBADLINK Failed to initialize a decoder for a stream for an
 1686|       |                         unknown reason.*/
 1687|       |int op_raw_seek(OggOpusFile *_of,opus_int64 _byte_offset) OP_ARG_NONNULL(1);
 1688|       |
 1689|       |/**Seek to the specified PCM offset, such that decoding will begin at exactly
 1690|       |    the requested position.
 1691|       |   \param _of         The \c OggOpusFile in which to seek.
 1692|       |   \param _pcm_offset The PCM offset to seek to.
 1693|       |                      This is in samples at 48 kHz relative to the start of the
 1694|       |                       stream.
 1695|       |   \return 0 on success, or a negative value on error.
 1696|       |   \retval #OP_EREAD    An underlying read or seek operation failed.
 1697|       |   \retval #OP_EINVAL   The stream was only partially open, or the target was
 1698|       |                         outside the valid range for the stream.
 1699|       |   \retval #OP_ENOSEEK  This stream is not seekable.
 1700|       |   \retval #OP_EBADLINK We failed to find data we had seen before, or the
 1701|       |                         bitstream structure was sufficiently malformed that
 1702|       |                         seeking to the target destination was impossible.*/
 1703|       |int op_pcm_seek(OggOpusFile *_of,ogg_int64_t _pcm_offset) OP_ARG_NONNULL(1);
 1704|       |
 1705|       |/*@}*/
 1706|       |/*@}*/
 1707|       |
 1708|       |/**\defgroup stream_decoding Decoding*/
 1709|       |/*@{*/
 1710|       |/**\name Functions for decoding audio data
 1711|       |
 1712|       |   These functions retrieve actual decoded audio data from the stream.
 1713|       |   The general functions, op_read() and op_read_float() return 16-bit or
 1714|       |    floating-point output, both using native endian ordering.
 1715|       |   The number of channels returned can change from link to link in a chained
 1716|       |    stream.
 1717|       |   There are special functions, op_read_stereo() and op_read_float_stereo(),
 1718|       |    which always output two channels, to simplify applications which do not
 1719|       |    wish to handle multichannel audio.
 1720|       |   These downmix multichannel files to two channels, so they can always return
 1721|       |    samples in the same format for every link in a chained file.
 1722|       |
 1723|       |   If the rest of your audio processing chain can handle floating point, the
 1724|       |    floating-point routines should be preferred, as they prevent clipping and
 1725|       |    other issues which might be avoided entirely if, e.g., you scale down the
 1726|       |    volume at some other stage.
 1727|       |   However, if you intend to consume 16-bit samples directly, the conversion in
 1728|       |    <tt>libopusfile</tt> provides noise-shaping dithering and, if compiled
 1729|       |    against <tt>libopus</tt>&nbsp;1.1 or later, soft-clipping prevention.
 1730|       |
 1731|       |   <tt>libopusfile</tt> can also be configured at compile time to use the
 1732|       |    fixed-point <tt>libopus</tt> API.
 1733|       |   If so, <tt>libopusfile</tt>'s floating-point API may also be disabled.
 1734|       |   In that configuration, nothing in <tt>libopusfile</tt> will use any
 1735|       |    floating-point operations, to simplify support on devices without an
 1736|       |    adequate FPU.
 1737|       |
 1738|       |   \warning HTTPS streams may be be vulnerable to truncation attacks if you do
 1739|       |    not check the error return code from op_read_float() or its associated
 1740|       |    functions.
 1741|       |   If the remote peer does not close the connection gracefully (with a TLS
 1742|       |    "close notify" message), these functions will return #OP_EREAD instead of 0
 1743|       |    when they reach the end of the file.
 1744|       |   If you are reading from an <https:> URL (particularly if seeking is not
 1745|       |    supported), you should make sure to check for this error and warn the user
 1746|       |    appropriately.*/
 1747|       |/*@{*/
 1748|       |
 1749|       |/**Indicates that the decoding callback should produce signed 16-bit
 1750|       |    native-endian output samples.*/
 1751|       |#define OP_DEC_FORMAT_SHORT (7008)
 1752|       |/**Indicates that the decoding callback should produce 32-bit native-endian
 1753|       |    float samples.*/
 1754|      0|#define OP_DEC_FORMAT_FLOAT (7040)
 1755|       |
 1756|       |/**Indicates that the decoding callback did not decode anything, and that
 1757|       |    <tt>libopusfile</tt> should decode normally instead.*/
 1758|      0|#define OP_DEC_USE_DEFAULT  (6720)
 1759|       |
 1760|       |/**Called to decode an Opus packet.
 1761|       |   This should invoke the functional equivalent of opus_multistream_decode() or
 1762|       |    opus_multistream_decode_float(), except that it returns 0 on success
 1763|       |    instead of the number of decoded samples (which is known a priori).
 1764|       |   \param _ctx       The application-provided callback context.
 1765|       |   \param _decoder   The decoder to use to decode the packet.
 1766|       |   \param[out] _pcm  The buffer to decode into.
 1767|       |                     This will always have enough room for \a _nchannels of
 1768|       |                      \a _nsamples samples, which should be placed into this
 1769|       |                      buffer interleaved.
 1770|       |   \param _op        The packet to decode.
 1771|       |                     This will always have its granule position set to a valid
 1772|       |                      value.
 1773|       |   \param _nsamples  The number of samples expected from the packet.
 1774|       |   \param _nchannels The number of channels expected from the packet.
 1775|       |   \param _format    The desired sample output format.
 1776|       |                     This is either #OP_DEC_FORMAT_SHORT or
 1777|       |                      #OP_DEC_FORMAT_FLOAT.
 1778|       |   \param _li        The index of the link from which this packet was decoded.
 1779|       |   \return A non-negative value on success, or a negative value on error.
 1780|       |           Any error codes should be the same as those returned by
 1781|       |            opus_multistream_decode() or opus_multistream_decode_float().
 1782|       |           Success codes are as follows:
 1783|       |   \retval 0                   Decoding was successful.
 1784|       |                               The application has filled the buffer with
 1785|       |                                exactly <code>\a _nsamples*\a
 1786|       |                                _nchannels</code> samples in the requested
 1787|       |                                format.
 1788|       |   \retval #OP_DEC_USE_DEFAULT No decoding was done.
 1789|       |                               <tt>libopusfile</tt> should do the decoding
 1790|       |                                by itself instead.*/
 1791|       |typedef int (*op_decode_cb_func)(void *_ctx,OpusMSDecoder *_decoder,void *_pcm,
 1792|       | const ogg_packet *_op,int _nsamples,int _nchannels,int _format,int _li);
 1793|       |
 1794|       |/**Sets the packet decode callback function.
 1795|       |   If set, this is called once for each packet that needs to be decoded.
 1796|       |   This can be used by advanced applications to do additional processing on the
 1797|       |    compressed or uncompressed data.
 1798|       |   For example, an application might save the final entropy coder state for
 1799|       |    debugging and testing purposes, or it might apply additional filters
 1800|       |    before the downmixing, dithering, or soft-clipping performed by
 1801|       |    <tt>libopusfile</tt>, so long as these filters do not introduce any
 1802|       |    latency.
 1803|       |
 1804|       |   A call to this function is no guarantee that the audio will eventually be
 1805|       |    delivered to the application.
 1806|       |   <tt>libopusfile</tt> may discard some or all of the decoded audio data
 1807|       |    (i.e., at the beginning or end of a link, or after a seek), however the
 1808|       |    callback is still required to provide all of it.
 1809|       |   \param _of        The \c OggOpusFile on which to set the decode callback.
 1810|       |   \param _decode_cb The callback function to call.
 1811|       |                     This may be <code>NULL</code> to disable calling the
 1812|       |                      callback.
 1813|       |   \param _ctx       The application-provided context pointer to pass to the
 1814|       |                      callback on each call.*/
 1815|       |void op_set_decode_callback(OggOpusFile *_of,
 1816|       | op_decode_cb_func _decode_cb,void *_ctx) OP_ARG_NONNULL(1);
 1817|       |
 1818|       |/**Gain offset type that indicates that the provided offset is relative to the
 1819|       |    header gain.
 1820|       |   This is the default.*/
 1821|      3|#define OP_HEADER_GAIN   (0)
 1822|       |
 1823|       |/**Gain offset type that indicates that the provided offset is relative to the
 1824|       |    R128_ALBUM_GAIN value (if any), in addition to the header gain.*/
 1825|      0|#define OP_ALBUM_GAIN    (3007)
 1826|       |
 1827|       |/**Gain offset type that indicates that the provided offset is relative to the
 1828|       |    R128_TRACK_GAIN value (if any), in addition to the header gain.*/
 1829|      0|#define OP_TRACK_GAIN    (3008)
 1830|       |
 1831|       |/**Gain offset type that indicates that the provided offset should be used as
 1832|       |    the gain directly, without applying any the header or track gains.*/
 1833|      0|#define OP_ABSOLUTE_GAIN (3009)
 1834|       |
 1835|       |/**Sets the gain to be used for decoded output.
 1836|       |   By default, the gain in the header is applied with no additional offset.
 1837|       |   The total gain (including header gain and/or track gain, if applicable, and
 1838|       |    this offset), will be clamped to [-32768,32767]/256 dB.
 1839|       |   This is more than enough to saturate or underflow 16-bit PCM.
 1840|       |   \note The new gain will not be applied to any already buffered, decoded
 1841|       |    output.
 1842|       |   This means you cannot change it sample-by-sample, as at best it will be
 1843|       |    updated packet-by-packet.
 1844|       |   It is meant for setting a target volume level, rather than applying smooth
 1845|       |    fades, etc.
 1846|       |   \param _of             The \c OggOpusFile on which to set the gain offset.
 1847|       |   \param _gain_type      One of #OP_HEADER_GAIN, #OP_ALBUM_GAIN,
 1848|       |                           #OP_TRACK_GAIN, or #OP_ABSOLUTE_GAIN.
 1849|       |   \param _gain_offset_q8 The gain offset to apply, in 1/256ths of a dB.
 1850|       |   \return 0 on success or a negative value on error.
 1851|       |   \retval #OP_EINVAL The \a _gain_type was unrecognized.*/
 1852|       |int op_set_gain_offset(OggOpusFile *_of,
 1853|       | int _gain_type,opus_int32 _gain_offset_q8) OP_ARG_NONNULL(1);
 1854|       |
 1855|       |/**Sets whether or not dithering is enabled for 16-bit decoding.
 1856|       |   By default, when <tt>libopusfile</tt> is compiled to use floating-point
 1857|       |    internally, calling op_read() or op_read_stereo() will first decode to
 1858|       |    float, and then convert to fixed-point using noise-shaping dithering.
 1859|       |   This flag can be used to disable that dithering.
 1860|       |   When the application uses op_read_float() or op_read_float_stereo(), or when
 1861|       |    the library has been compiled to decode directly to fixed point, this flag
 1862|       |    has no effect.
 1863|       |   \param _of      The \c OggOpusFile on which to enable or disable dithering.
 1864|       |   \param _enabled A non-zero value to enable dithering, or 0 to disable it.*/
 1865|       |void op_set_dither_enabled(OggOpusFile *_of,int _enabled) OP_ARG_NONNULL(1);
 1866|       |
 1867|       |/**Reads more samples from the stream.
 1868|       |   \note Although \a _buf_size must indicate the total number of values that
 1869|       |    can be stored in \a _pcm, the return value is the number of samples
 1870|       |    <em>per channel</em>.
 1871|       |   This is done because
 1872|       |   <ol>
 1873|       |   <li>The channel count cannot be known a priori (reading more samples might
 1874|       |        advance us into the next link, with a different channel count), so
 1875|       |        \a _buf_size cannot also be in units of samples per channel,</li>
 1876|       |   <li>Returning the samples per channel matches the <code>libopus</code> API
 1877|       |        as closely as we're able,</li>
 1878|       |   <li>Returning the total number of values instead of samples per channel
 1879|       |        would mean the caller would need a division to compute the samples per
 1880|       |        channel, and might worry about the possibility of getting back samples
 1881|       |        for some channels and not others, and</li>
 1882|       |   <li>This approach is relatively fool-proof: if an application passes too
 1883|       |        small a value to \a _buf_size, they will simply get fewer samples back,
 1884|       |        and if they assume the return value is the total number of values, then
 1885|       |        they will simply read too few (rather than reading too many and going
 1886|       |        off the end of the buffer).</li>
 1887|       |   </ol>
 1888|       |   \param      _of       The \c OggOpusFile from which to read.
 1889|       |   \param[out] _pcm      A buffer in which to store the output PCM samples, as
 1890|       |                          signed native-endian 16-bit values at 48&nbsp;kHz
 1891|       |                          with a nominal range of <code>[-32768,32767)</code>.
 1892|       |                         Multiple channels are interleaved using the
 1893|       |                          <a href="https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-810004.3.9">Vorbis
 1894|       |                          channel ordering</a>.
 1895|       |                         This must have room for at least \a _buf_size values.
 1896|       |   \param      _buf_size The number of values that can be stored in \a _pcm.
 1897|       |                         It is recommended that this be large enough for at
 1898|       |                          least 120 ms of data at 48 kHz per channel (5760
 1899|       |                          values per channel).
 1900|       |                         Smaller buffers will simply return less data, possibly
 1901|       |                          consuming more memory to buffer the data internally.
 1902|       |                         <tt>libopusfile</tt> may return less data than
 1903|       |                          requested.
 1904|       |                         If so, there is no guarantee that the remaining data
 1905|       |                          in \a _pcm will be unmodified.
 1906|       |   \param[out] _li       The index of the link this data was decoded from.
 1907|       |                         You may pass <code>NULL</code> if you do not need this
 1908|       |                          information.
 1909|       |                         If this function fails (returning a negative value),
 1910|       |                          this parameter is left unset.
 1911|       |   \return The number of samples read per channel on success, or a negative
 1912|       |            value on failure.
 1913|       |           The channel count can be retrieved on success by calling
 1914|       |            <code>op_head(_of,*_li)</code>.
 1915|       |           The number of samples returned may be 0 if the buffer was too small
 1916|       |            to store even a single sample for all channels, or if end-of-file
 1917|       |            was reached.
 1918|       |           The list of possible failure codes follows.
 1919|       |           Most of them can only be returned by unseekable, chained streams
 1920|       |            that encounter a new link.
 1921|       |   \retval #OP_HOLE          There was a hole in the data, and some samples
 1922|       |                              may have been skipped.
 1923|       |                             Call this function again to continue decoding
 1924|       |                              past the hole.
 1925|       |   \retval #OP_EREAD         An underlying read operation failed.
 1926|       |                             This may signal a truncation attack from an
 1927|       |                              <https:> source.
 1928|       |   \retval #OP_EFAULT        An internal memory allocation failed.
 1929|       |   \retval #OP_EIMPL         An unseekable stream encountered a new link that
 1930|       |                              used a feature that is not implemented, such as
 1931|       |                              an unsupported channel family.
 1932|       |   \retval #OP_EINVAL        The stream was only partially open.
 1933|       |   \retval #OP_ENOTFORMAT    An unseekable stream encountered a new link that
 1934|       |                              did not have any logical Opus streams in it.
 1935|       |   \retval #OP_EBADHEADER    An unseekable stream encountered a new link with a
 1936|       |                              required header packet that was not properly
 1937|       |                              formatted, contained illegal values, or was
 1938|       |                              missing altogether.
 1939|       |   \retval #OP_EVERSION      An unseekable stream encountered a new link with
 1940|       |                              an ID header that contained an unrecognized
 1941|       |                              version number.
 1942|       |   \retval #OP_EBADPACKET    Failed to properly decode the next packet.
 1943|       |   \retval #OP_EBADLINK      We failed to find data we had seen before.
 1944|       |   \retval #OP_EBADTIMESTAMP An unseekable stream encountered a new link with
 1945|       |                              a starting timestamp that failed basic validity
 1946|       |                              checks.*/
 1947|       |OP_WARN_UNUSED_RESULT int op_read(OggOpusFile *_of,
 1948|       | opus_int16 *_pcm,int _buf_size,int *_li) OP_ARG_NONNULL(1);
 1949|       |
 1950|       |/**Reads more samples from the stream.
 1951|       |   \note Although \a _buf_size must indicate the total number of values that
 1952|       |    can be stored in \a _pcm, the return value is the number of samples
 1953|       |    <em>per channel</em>.
 1954|       |   <ol>
 1955|       |   <li>The channel count cannot be known a priori (reading more samples might
 1956|       |        advance us into the next link, with a different channel count), so
 1957|       |        \a _buf_size cannot also be in units of samples per channel,</li>
 1958|       |   <li>Returning the samples per channel matches the <code>libopus</code> API
 1959|       |        as closely as we're able,</li>
 1960|       |   <li>Returning the total number of values instead of samples per channel
 1961|       |        would mean the caller would need a division to compute the samples per
 1962|       |        channel, and might worry about the possibility of getting back samples
 1963|       |        for some channels and not others, and</li>
 1964|       |   <li>This approach is relatively fool-proof: if an application passes too
 1965|       |        small a value to \a _buf_size, they will simply get fewer samples back,
 1966|       |        and if they assume the return value is the total number of values, then
 1967|       |        they will simply read too few (rather than reading too many and going
 1968|       |        off the end of the buffer).</li>
 1969|       |   </ol>
 1970|       |   \param      _of       The \c OggOpusFile from which to read.
 1971|       |   \param[out] _pcm      A buffer in which to store the output PCM samples as
 1972|       |                          signed floats at 48&nbsp;kHz with a nominal range of
 1973|       |                          <code>[-1.0,1.0]</code>.
 1974|       |                         Multiple channels are interleaved using the
 1975|       |                          <a href="https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-810004.3.9">Vorbis
 1976|       |                          channel ordering</a>.
 1977|       |                         This must have room for at least \a _buf_size floats.
 1978|       |   \param      _buf_size The number of floats that can be stored in \a _pcm.
 1979|       |                         It is recommended that this be large enough for at
 1980|       |                          least 120 ms of data at 48 kHz per channel (5760
 1981|       |                          samples per channel).
 1982|       |                         Smaller buffers will simply return less data, possibly
 1983|       |                          consuming more memory to buffer the data internally.
 1984|       |                         If less than \a _buf_size values are returned,
 1985|       |                          <tt>libopusfile</tt> makes no guarantee that the
 1986|       |                          remaining data in \a _pcm will be unmodified.
 1987|       |   \param[out] _li       The index of the link this data was decoded from.
 1988|       |                         You may pass <code>NULL</code> if you do not need this
 1989|       |                          information.
 1990|       |                         If this function fails (returning a negative value),
 1991|       |                          this parameter is left unset.
 1992|       |   \return The number of samples read per channel on success, or a negative
 1993|       |            value on failure.
 1994|       |           The channel count can be retrieved on success by calling
 1995|       |            <code>op_head(_of,*_li)</code>.
 1996|       |           The number of samples returned may be 0 if the buffer was too small
 1997|       |            to store even a single sample for all channels, or if end-of-file
 1998|       |            was reached.
 1999|       |           The list of possible failure codes follows.
 2000|       |           Most of them can only be returned by unseekable, chained streams
 2001|       |            that encounter a new link.
 2002|       |   \retval #OP_HOLE          There was a hole in the data, and some samples
 2003|       |                              may have been skipped.
 2004|       |                             Call this function again to continue decoding
 2005|       |                              past the hole.
 2006|       |   \retval #OP_EREAD         An underlying read operation failed.
 2007|       |                             This may signal a truncation attack from an
 2008|       |                              <https:> source.
 2009|       |   \retval #OP_EFAULT        An internal memory allocation failed.
 2010|       |   \retval #OP_EIMPL         An unseekable stream encountered a new link that
 2011|       |                              used a feature that is not implemented, such as
 2012|       |                              an unsupported channel family.
 2013|       |   \retval #OP_EINVAL        The stream was only partially open.
 2014|       |   \retval #OP_ENOTFORMAT    An unseekable stream encountered a new link that
 2015|       |                              did not have any logical Opus streams in it.
 2016|       |   \retval #OP_EBADHEADER    An unseekable stream encountered a new link with a
 2017|       |                              required header packet that was not properly
 2018|       |                              formatted, contained illegal values, or was
 2019|       |                              missing altogether.
 2020|       |   \retval #OP_EVERSION      An unseekable stream encountered a new link with
 2021|       |                              an ID header that contained an unrecognized
 2022|       |                              version number.
 2023|       |   \retval #OP_EBADPACKET    Failed to properly decode the next packet.
 2024|       |   \retval #OP_EBADLINK      We failed to find data we had seen before.
 2025|       |   \retval #OP_EBADTIMESTAMP An unseekable stream encountered a new link with
 2026|       |                              a starting timestamp that failed basic validity
 2027|       |                              checks.*/
 2028|       |OP_WARN_UNUSED_RESULT int op_read_float(OggOpusFile *_of,
 2029|       | float *_pcm,int _buf_size,int *_li) OP_ARG_NONNULL(1);
 2030|       |
 2031|       |/**Reads more samples from the stream and downmixes to stereo, if necessary.
 2032|       |   This function is intended for simple players that want a uniform output
 2033|       |    format, even if the channel count changes between links in a chained
 2034|       |    stream.
 2035|       |   \note \a _buf_size indicates the total number of values that can be stored
 2036|       |    in \a _pcm, while the return value is the number of samples <em>per
 2037|       |    channel</em>, even though the channel count is known, for consistency with
 2038|       |    op_read().
 2039|       |   \param      _of       The \c OggOpusFile from which to read.
 2040|       |   \param[out] _pcm      A buffer in which to store the output PCM samples, as
 2041|       |                          signed native-endian 16-bit values at 48&nbsp;kHz
 2042|       |                          with a nominal range of <code>[-32768,32767)</code>.
 2043|       |                         The left and right channels are interleaved in the
 2044|       |                          buffer.
 2045|       |                         This must have room for at least \a _buf_size values.
 2046|       |   \param      _buf_size The number of values that can be stored in \a _pcm.
 2047|       |                         It is recommended that this be large enough for at
 2048|       |                          least 120 ms of data at 48 kHz per channel (11520
 2049|       |                          values total).
 2050|       |                         Smaller buffers will simply return less data, possibly
 2051|       |                          consuming more memory to buffer the data internally.
 2052|       |                         If less than \a _buf_size values are returned,
 2053|       |                          <tt>libopusfile</tt> makes no guarantee that the
 2054|       |                          remaining data in \a _pcm will be unmodified.
 2055|       |   \return The number of samples read per channel on success, or a negative
 2056|       |            value on failure.
 2057|       |           The number of samples returned may be 0 if the buffer was too small
 2058|       |            to store even a single sample for both channels, or if end-of-file
 2059|       |            was reached.
 2060|       |           The list of possible failure codes follows.
 2061|       |           Most of them can only be returned by unseekable, chained streams
 2062|       |            that encounter a new link.
 2063|       |   \retval #OP_HOLE          There was a hole in the data, and some samples
 2064|       |                              may have been skipped.
 2065|       |                             Call this function again to continue decoding
 2066|       |                              past the hole.
 2067|       |   \retval #OP_EREAD         An underlying read operation failed.
 2068|       |                             This may signal a truncation attack from an
 2069|       |                              <https:> source.
 2070|       |   \retval #OP_EFAULT        An internal memory allocation failed.
 2071|       |   \retval #OP_EIMPL         An unseekable stream encountered a new link that
 2072|       |                              used a feature that is not implemented, such as
 2073|       |                              an unsupported channel family.
 2074|       |   \retval #OP_EINVAL        The stream was only partially open.
 2075|       |   \retval #OP_ENOTFORMAT    An unseekable stream encountered a new link that
 2076|       |                              did not have any logical Opus streams in it.
 2077|       |   \retval #OP_EBADHEADER    An unseekable stream encountered a new link with a
 2078|       |                              required header packet that was not properly
 2079|       |                              formatted, contained illegal values, or was
 2080|       |                              missing altogether.
 2081|       |   \retval #OP_EVERSION      An unseekable stream encountered a new link with
 2082|       |                              an ID header that contained an unrecognized
 2083|       |                              version number.
 2084|       |   \retval #OP_EBADPACKET    Failed to properly decode the next packet.
 2085|       |   \retval #OP_EBADLINK      We failed to find data we had seen before.
 2086|       |   \retval #OP_EBADTIMESTAMP An unseekable stream encountered a new link with
 2087|       |                              a starting timestamp that failed basic validity
 2088|       |                              checks.*/
 2089|       |OP_WARN_UNUSED_RESULT int op_read_stereo(OggOpusFile *_of,
 2090|       | opus_int16 *_pcm,int _buf_size) OP_ARG_NONNULL(1);
 2091|       |
 2092|       |/**Reads more samples from the stream and downmixes to stereo, if necessary.
 2093|       |   This function is intended for simple players that want a uniform output
 2094|       |    format, even if the channel count changes between links in a chained
 2095|       |    stream.
 2096|       |   \note \a _buf_size indicates the total number of values that can be stored
 2097|       |    in \a _pcm, while the return value is the number of samples <em>per
 2098|       |    channel</em>, even though the channel count is known, for consistency with
 2099|       |    op_read_float().
 2100|       |   \param      _of       The \c OggOpusFile from which to read.
 2101|       |   \param[out] _pcm      A buffer in which to store the output PCM samples, as
 2102|       |                          signed floats at 48&nbsp;kHz with a nominal range of
 2103|       |                          <code>[-1.0,1.0]</code>.
 2104|       |                         The left and right channels are interleaved in the
 2105|       |                          buffer.
 2106|       |                         This must have room for at least \a _buf_size values.
 2107|       |   \param      _buf_size The number of values that can be stored in \a _pcm.
 2108|       |                         It is recommended that this be large enough for at
 2109|       |                          least 120 ms of data at 48 kHz per channel (11520
 2110|       |                          values total).
 2111|       |                         Smaller buffers will simply return less data, possibly
 2112|       |                          consuming more memory to buffer the data internally.
 2113|       |                         If less than \a _buf_size values are returned,
 2114|       |                          <tt>libopusfile</tt> makes no guarantee that the
 2115|       |                          remaining data in \a _pcm will be unmodified.
 2116|       |   \return The number of samples read per channel on success, or a negative
 2117|       |            value on failure.
 2118|       |           The number of samples returned may be 0 if the buffer was too small
 2119|       |            to store even a single sample for both channels, or if end-of-file
 2120|       |            was reached.
 2121|       |           The list of possible failure codes follows.
 2122|       |           Most of them can only be returned by unseekable, chained streams
 2123|       |            that encounter a new link.
 2124|       |   \retval #OP_HOLE          There was a hole in the data, and some samples
 2125|       |                              may have been skipped.
 2126|       |                             Call this function again to continue decoding
 2127|       |                              past the hole.
 2128|       |   \retval #OP_EREAD         An underlying read operation failed.
 2129|       |                             This may signal a truncation attack from an
 2130|       |                              <https:> source.
 2131|       |   \retval #OP_EFAULT        An internal memory allocation failed.
 2132|       |   \retval #OP_EIMPL         An unseekable stream encountered a new link that
 2133|       |                              used a feature that is not implemented, such as
 2134|       |                              an unsupported channel family.
 2135|       |   \retval #OP_EINVAL        The stream was only partially open.
 2136|       |   \retval #OP_ENOTFORMAT    An unseekable stream encountered a new link that
 2137|       |                              that did not have any logical Opus streams in it.
 2138|       |   \retval #OP_EBADHEADER    An unseekable stream encountered a new link with a
 2139|       |                              required header packet that was not properly
 2140|       |                              formatted, contained illegal values, or was
 2141|       |                              missing altogether.
 2142|       |   \retval #OP_EVERSION      An unseekable stream encountered a new link with
 2143|       |                              an ID header that contained an unrecognized
 2144|       |                              version number.
 2145|       |   \retval #OP_EBADPACKET    Failed to properly decode the next packet.
 2146|       |   \retval #OP_EBADLINK      We failed to find data we had seen before.
 2147|       |   \retval #OP_EBADTIMESTAMP An unseekable stream encountered a new link with
 2148|       |                              a starting timestamp that failed basic validity
 2149|       |                              checks.*/
 2150|       |OP_WARN_UNUSED_RESULT int op_read_float_stereo(OggOpusFile *_of,
 2151|       | float *_pcm,int _buf_size) OP_ARG_NONNULL(1);
 2152|       |
 2153|       |/*@}*/
 2154|       |/*@}*/
 2155|       |
 2156|       |# if OP_GNUC_PREREQ(4,0)
 2157|       |#  pragma GCC visibility pop
 2158|       |# endif
 2159|       |
 2160|       |# if defined(__cplusplus)
 2161|       |}
 2162|       |# endif
 2163|       |
 2164|       |#endif

/home/fyu/Workspace/hapi-client/test/test-api/opusfile/src/info.c:
    1|       |/********************************************************************
    2|       | *                                                                  *
    3|       | * THIS FILE IS PART OF THE libopusfile SOFTWARE CODEC SOURCE CODE. *
    4|       | * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
    5|       | * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
    6|       | * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
    7|       | *                                                                  *
    8|       | * THE libopusfile SOURCE CODE IS (C) COPYRIGHT 2012-2020           *
    9|       | * by the Xiph.Org Foundation and contributors https://xiph.org/    *
   10|       | *                                                                  *
   11|       | ********************************************************************/
   12|       |#ifdef HAVE_CONFIG_H
   13|       |#include "config.h"
   14|       |#endif
   15|       |
   16|       |#include "internal.h"
   17|       |#include <limits.h>
   18|       |#include <string.h>
   19|       |
   20|      3|static unsigned op_parse_uint16le(const unsigned char *_data){
   21|      3|  return _data[0]|_data[1]<<8;
   22|      3|}
   23|       |
   24|      3|static int op_parse_int16le(const unsigned char *_data){
   25|      3|  int ret;
   26|      3|  ret=_data[0]|_data[1]<<8;
   27|      3|  return (ret^0x8000)-0x8000;
   28|      3|}
   29|       |
   30|     14|static opus_uint32 op_parse_uint32le(const unsigned char *_data){
   31|     14|  return _data[0]|(opus_uint32)_data[1]<<8|
   32|     14|   (opus_uint32)_data[2]<<16|(opus_uint32)_data[3]<<24;
   33|     14|}
   34|       |
   35|      0|static opus_uint32 op_parse_uint32be(const unsigned char *_data){
   36|      0|  return _data[3]|(opus_uint32)_data[2]<<8|
   37|      0|   (opus_uint32)_data[1]<<16|(opus_uint32)_data[0]<<24;
   38|      0|}
   39|       |
   40|      3|int opus_head_parse(OpusHead *_head,const unsigned char *_data,size_t _len){
   41|      3|  OpusHead head;
   42|      3|  if(_len<8)return OP_ENOTFORMAT;
   43|      3|  if(memcmp(_data,"OpusHead",8)!=0)return OP_ENOTFORMAT;
   44|      3|  if(_len<9)return OP_EBADHEADER;
   45|      3|  head.version=_data[8];
   46|      3|  if(head.version>15)return OP_EVERSION;
   47|      3|  if(_len<19)return OP_EBADHEADER;
   48|      3|  head.channel_count=_data[9];
   49|      3|  head.pre_skip=op_parse_uint16le(_data+10);
   50|      3|  head.input_sample_rate=op_parse_uint32le(_data+12);
   51|      3|  head.output_gain=op_parse_int16le(_data+16);
   52|      3|  head.mapping_family=_data[18];
   53|      3|  if(head.mapping_family==0){
   54|      3|    if(head.channel_count<1||head.channel_count>2)return OP_EBADHEADER;
   55|      3|    if(head.version<=1&&_len>19)return OP_EBADHEADER;
   56|      3|    head.stream_count=1;
   57|      3|    head.coupled_count=head.channel_count-1;
   58|      3|    if(_head!=NULL){
   59|      3|      _head->mapping[0]=0;
   60|      3|      _head->mapping[1]=1;
   61|      3|    }
   62|      3|  }
   63|      0|  else if(head.mapping_family==1){
   64|      0|    size_t size;
   65|      0|    int    ci;
   66|      0|    if(head.channel_count<1||head.channel_count>8)return OP_EBADHEADER;
   67|      0|    size=21+head.channel_count;
   68|      0|    if(_len<size||head.version<=1&&_len>size)return OP_EBADHEADER;
   69|      0|    head.stream_count=_data[19];
   70|      0|    if(head.stream_count<1)return OP_EBADHEADER;
   71|      0|    head.coupled_count=_data[20];
   72|      0|    if(head.coupled_count>head.stream_count)return OP_EBADHEADER;
   73|      0|    for(ci=0;ci<head.channel_count;ci++){
   74|      0|      if(_data[21+ci]>=head.stream_count+head.coupled_count
   75|      0|       &&_data[21+ci]!=255){
   76|      0|        return OP_EBADHEADER;
   77|      0|      }
   78|      0|    }
   79|      0|    if(_head!=NULL)memcpy(_head->mapping,_data+21,head.channel_count);
   80|      0|  }
   81|       |  /*General purpose players should not attempt to play back content with
   82|       |     channel mapping family 255.*/
   83|      0|  else if(head.mapping_family==255)return OP_EIMPL;
   84|       |  /*No other channel mapping families are currently defined.*/
   85|      0|  else return OP_EBADHEADER;
   86|      3|  if(_head!=NULL)memcpy(_head,&head,head.mapping-(unsigned char *)&head);
   87|      3|  return 0;
   88|      3|}
   89|       |
   90|      4|void opus_tags_init(OpusTags *_tags){
   91|      4|  memset(_tags,0,sizeof(*_tags));
   92|      4|}
   93|       |
   94|      4|void opus_tags_clear(OpusTags *_tags){
   95|      4|  int ncomments;
   96|      4|  int ci;
   97|      4|  ncomments=_tags->comments;
   98|      4|  if(_tags->user_comments!=NULL)ncomments++;
   99|      1|  else{
  100|      1|    OP_ASSERT(ncomments==0);
  101|      1|  }
  102|     12|  for(ci=ncomments;ci-->0;)_ogg_free(_tags->user_comments[ci]);
  103|      4|  _ogg_free(_tags->user_comments);
  104|      4|  _ogg_free(_tags->comment_lengths);
  105|      4|  _ogg_free(_tags->vendor);
  106|      4|}
  107|       |
  108|       |/*Ensure there's room for up to _ncomments comments.*/
  109|      3|static int op_tags_ensure_capacity(OpusTags *_tags,size_t _ncomments){
  110|      3|  char   **user_comments;
  111|      3|  int     *comment_lengths;
  112|      3|  int      cur_ncomments;
  113|      3|  size_t   size;
  114|      3|  if(OP_UNLIKELY(_ncomments>=(size_t)INT_MAX))return OP_EFAULT;
  115|      3|  size=sizeof(*_tags->comment_lengths)*(_ncomments+1);
  116|      3|  if(size/sizeof(*_tags->comment_lengths)!=_ncomments+1)return OP_EFAULT;
  117|      3|  cur_ncomments=_tags->comments;
  118|       |  /*We only support growing.
  119|       |    Trimming requires cleaning up the allocated strings in the old space, and
  120|       |     is best handled separately if it's ever needed.*/
  121|      3|  OP_ASSERT(_ncomments>=(size_t)cur_ncomments);
  122|      3|  comment_lengths=(int *)_ogg_realloc(_tags->comment_lengths,size);
  123|      3|  if(OP_UNLIKELY(comment_lengths==NULL))return OP_EFAULT;
  124|      3|  if(_tags->comment_lengths==NULL){
  125|      3|    OP_ASSERT(cur_ncomments==0);
  126|      3|    comment_lengths[cur_ncomments]=0;
  127|      3|  }
  128|      3|  comment_lengths[_ncomments]=comment_lengths[cur_ncomments];
  129|      3|  _tags->comment_lengths=comment_lengths;
  130|      3|  size=sizeof(*_tags->user_comments)*(_ncomments+1);
  131|      3|  if(size/sizeof(*_tags->user_comments)!=_ncomments+1)return OP_EFAULT;
  132|      3|  user_comments=(char **)_ogg_realloc(_tags->user_comments,size);
  133|      3|  if(OP_UNLIKELY(user_comments==NULL))return OP_EFAULT;
  134|      3|  if(_tags->user_comments==NULL){
  135|      3|    OP_ASSERT(cur_ncomments==0);
  136|      3|    user_comments[cur_ncomments]=NULL;
  137|      3|  }
  138|      3|  user_comments[_ncomments]=user_comments[cur_ncomments];
  139|      3|  _tags->user_comments=user_comments;
  140|      3|  return 0;
  141|      3|}
  142|       |
  143|       |/*Duplicate a (possibly non-NUL terminated) string with a known length.*/
  144|      8|static char *op_strdup_with_len(const char *_s,size_t _len){
  145|      8|  size_t  size;
  146|      8|  char   *ret;
  147|      8|  size=sizeof(*ret)*(_len+1);
  148|      8|  if(OP_UNLIKELY(size<_len))return NULL;
  149|      8|  ret=(char *)_ogg_malloc(size);
  150|      8|  if(OP_LIKELY(ret!=NULL)){
  151|      8|    ret=(char *)memcpy(ret,_s,sizeof(*ret)*_len);
  152|      8|    ret[_len]='\0';
  153|      8|  }
  154|      8|  return ret;
  155|      8|}
  156|       |
  157|       |/*The actual implementation of opus_tags_parse().
  158|       |  Unlike the public API, this function requires _tags to already be
  159|       |   initialized, modifies its contents before success is guaranteed, and assumes
  160|       |   the caller will clear it on error.*/
  161|       |static int opus_tags_parse_impl(OpusTags *_tags,
  162|      4| const unsigned char *_data,size_t _len){
  163|      4|  opus_uint32 count;
  164|      4|  size_t      len;
  165|      4|  int         ncomments;
  166|      4|  int         ci;
  167|      4|  len=_len;
  168|      4|  if(len<8)return OP_ENOTFORMAT;
  169|      4|  if(memcmp(_data,"OpusTags",8)!=0)return OP_ENOTFORMAT;
  170|      3|  if(len<16)return OP_EBADHEADER;
  171|      3|  _data+=8;
  172|      3|  len-=8;
  173|      3|  count=op_parse_uint32le(_data);
  174|      3|  _data+=4;
  175|      3|  len-=4;
  176|      3|  if(count>len)return OP_EBADHEADER;
  177|      3|  if(_tags!=NULL){
  178|      3|    _tags->vendor=op_strdup_with_len((char *)_data,count);
  179|      3|    if(_tags->vendor==NULL)return OP_EFAULT;
  180|      3|  }
  181|      3|  _data+=count;
  182|      3|  len-=count;
  183|      3|  if(len<4)return OP_EBADHEADER;
  184|      3|  count=op_parse_uint32le(_data);
  185|      3|  _data+=4;
  186|      3|  len-=4;
  187|       |  /*Check to make sure there's minimally sufficient data left in the packet.*/
  188|      3|  if(count>len>>2)return OP_EBADHEADER;
  189|       |  /*Check for overflow (the API limits this to an int).*/
  190|      3|  if(count>(opus_uint32)INT_MAX-1)return OP_EFAULT;
  191|      3|  if(_tags!=NULL){
  192|      3|    int ret;
  193|      3|    ret=op_tags_ensure_capacity(_tags,count);
  194|      3|    if(ret<0)return ret;
  195|      3|  }
  196|      3|  ncomments=(int)count;
  197|      8|  for(ci=0;ci<ncomments;ci++){
  198|       |    /*Check to make sure there's minimally sufficient data left in the packet.*/
  199|      5|    if((size_t)(ncomments-ci)>len>>2)return OP_EBADHEADER;
  200|      5|    count=op_parse_uint32le(_data);
  201|      5|    _data+=4;
  202|      5|    len-=4;
  203|      5|    if(count>len)return OP_EBADHEADER;
  204|       |    /*Check for overflow (the API limits this to an int).*/
  205|      5|    if(count>(opus_uint32)INT_MAX)return OP_EFAULT;
  206|      5|    if(_tags!=NULL){
  207|      5|      _tags->user_comments[ci]=op_strdup_with_len((char *)_data,count);
  208|      5|      if(_tags->user_comments[ci]==NULL)return OP_EFAULT;
  209|      5|      _tags->comment_lengths[ci]=(int)count;
  210|      5|      _tags->comments=ci+1;
  211|       |      /*Needed by opus_tags_clear() if we fail before parsing the (optional)
  212|       |         binary metadata.*/
  213|       |      /* [HAPI]: This line of code is the fix patch. Remove it to reintroduce the old bug.*/
  214|      5|      _tags->user_comments[ci+1]=NULL;
  215|      5|    }
  216|      5|    _data+=count;
  217|      5|    len-=count;
  218|      5|  }
  219|      3|  if(len>0&&(_data[0]&1)){
  220|      0|    if(len>(opus_uint32)INT_MAX)return OP_EFAULT;
  221|      0|    if(_tags!=NULL){
  222|      0|      _tags->user_comments[ncomments]=(char *)_ogg_malloc(len);
  223|      0|      if(OP_UNLIKELY(_tags->user_comments[ncomments]==NULL))return OP_EFAULT;
  224|      0|      memcpy(_tags->user_comments[ncomments],_data,len);
  225|      0|      _tags->comment_lengths[ncomments]=(int)len;
  226|      0|    }
  227|      0|  }
  228|      3|  return 0;
  229|      3|}
  230|       |
  231|      4|int opus_tags_parse(OpusTags *_tags,const unsigned char *_data,size_t _len){
  232|      4|  if(_tags!=NULL){
  233|      4|    OpusTags tags;
  234|      4|    int      ret;
  235|      4|    opus_tags_init(&tags);
  236|      4|    ret=opus_tags_parse_impl(&tags,_data,_len);
  237|      4|    if(ret<0)opus_tags_clear(&tags);
  238|      3|    else *_tags=*&tags;
  239|      4|    return ret;
  240|      4|  }
  241|      0|  else return opus_tags_parse_impl(NULL,_data,_len);
  242|      4|}
  243|       |
  244|       |/*The actual implementation of opus_tags_copy().
  245|       |  Unlike the public API, this function requires _dst to already be
  246|       |   initialized, modifies its contents before success is guaranteed, and assumes
  247|       |   the caller will clear it on error.*/
  248|      0|static int opus_tags_copy_impl(OpusTags *_dst,const OpusTags *_src){
  249|      0|  char *vendor;
  250|      0|  int   ncomments;
  251|      0|  int   ret;
  252|      0|  int   ci;
  253|      0|  vendor=_src->vendor;
  254|      0|  _dst->vendor=op_strdup_with_len(vendor,strlen(vendor));
  255|      0|  if(OP_UNLIKELY(_dst->vendor==NULL))return OP_EFAULT;
  256|      0|  ncomments=_src->comments;
  257|      0|  ret=op_tags_ensure_capacity(_dst,ncomments);
  258|      0|  if(OP_UNLIKELY(ret<0))return ret;
  259|      0|  for(ci=0;ci<ncomments;ci++){
  260|      0|    int len;
  261|      0|    len=_src->comment_lengths[ci];
  262|      0|    OP_ASSERT(len>=0);
  263|      0|    _dst->user_comments[ci]=op_strdup_with_len(_src->user_comments[ci],len);
  264|      0|    if(OP_UNLIKELY(_dst->user_comments[ci]==NULL))return OP_EFAULT;
  265|      0|    _dst->comment_lengths[ci]=len;
  266|      0|    _dst->comments=ci+1;
  267|      0|  }
  268|      0|  if(_src->comment_lengths!=NULL){
  269|      0|    int len;
  270|      0|    len=_src->comment_lengths[ncomments];
  271|      0|    if(len>0){
  272|      0|      _dst->user_comments[ncomments]=(char *)_ogg_malloc(len);
  273|      0|      if(OP_UNLIKELY(_dst->user_comments[ncomments]==NULL))return OP_EFAULT;
  274|      0|      memcpy(_dst->user_comments[ncomments],_src->user_comments[ncomments],len);
  275|      0|      _dst->comment_lengths[ncomments]=len;
  276|      0|    }
  277|      0|  }
  278|      0|  return 0;
  279|      0|}
  280|       |
  281|      0|int opus_tags_copy(OpusTags *_dst,const OpusTags *_src){
  282|      0|  OpusTags dst;
  283|      0|  int      ret;
  284|      0|  opus_tags_init(&dst);
  285|      0|  ret=opus_tags_copy_impl(&dst,_src);
  286|      0|  if(OP_UNLIKELY(ret<0))opus_tags_clear(&dst);
  287|      0|  else *_dst=*&dst;
  288|      0|  return ret;
  289|      0|}
  290|       |
  291|      0|int opus_tags_add(OpusTags *_tags,const char *_tag,const char *_value){
  292|      0|  char   *comment;
  293|      0|  size_t  tag_len;
  294|      0|  size_t  value_len;
  295|      0|  int     ncomments;
  296|      0|  int     ret;
  297|      0|  ncomments=_tags->comments;
  298|      0|  ret=op_tags_ensure_capacity(_tags,ncomments+1);
  299|      0|  if(OP_UNLIKELY(ret<0))return ret;
  300|      0|  tag_len=strlen(_tag);
  301|      0|  value_len=strlen(_value);
  302|       |  /*+2 for '=' and '\0'.*/
  303|      0|  if(tag_len+value_len<tag_len)return OP_EFAULT;
  304|      0|  if(tag_len+value_len>(size_t)INT_MAX-2)return OP_EFAULT;
  305|      0|  comment=(char *)_ogg_malloc(sizeof(*comment)*(tag_len+value_len+2));
  306|      0|  if(OP_UNLIKELY(comment==NULL))return OP_EFAULT;
  307|      0|  memcpy(comment,_tag,sizeof(*comment)*tag_len);
  308|      0|  comment[tag_len]='=';
  309|      0|  memcpy(comment+tag_len+1,_value,sizeof(*comment)*(value_len+1));
  310|      0|  _tags->user_comments[ncomments]=comment;
  311|      0|  _tags->comment_lengths[ncomments]=(int)(tag_len+value_len+1);
  312|      0|  _tags->comments=ncomments+1;
  313|      0|  return 0;
  314|      0|}
  315|       |
  316|      0|int opus_tags_add_comment(OpusTags *_tags,const char *_comment){
  317|      0|  char *comment;
  318|      0|  int   comment_len;
  319|      0|  int   ncomments;
  320|      0|  int   ret;
  321|      0|  ncomments=_tags->comments;
  322|      0|  ret=op_tags_ensure_capacity(_tags,ncomments+1);
  323|      0|  if(OP_UNLIKELY(ret<0))return ret;
  324|      0|  comment_len=(int)strlen(_comment);
  325|      0|  comment=op_strdup_with_len(_comment,comment_len);
  326|      0|  if(OP_UNLIKELY(comment==NULL))return OP_EFAULT;
  327|      0|  _tags->user_comments[ncomments]=comment;
  328|      0|  _tags->comment_lengths[ncomments]=comment_len;
  329|      0|  _tags->comments=ncomments+1;
  330|      0|  return 0;
  331|      0|}
  332|       |
  333|       |int opus_tags_set_binary_suffix(OpusTags *_tags,
  334|      0| const unsigned char *_data,int _len){
  335|      0|  unsigned char *binary_suffix_data;
  336|      0|  int            ncomments;
  337|      0|  int            ret;
  338|      0|  if(_len<0||_len>0&&(_data==NULL||!(_data[0]&1)))return OP_EINVAL;
  339|      0|  ncomments=_tags->comments;
  340|      0|  ret=op_tags_ensure_capacity(_tags,ncomments);
  341|      0|  if(OP_UNLIKELY(ret<0))return ret;
  342|      0|  binary_suffix_data=
  343|      0|   (unsigned char *)_ogg_realloc(_tags->user_comments[ncomments],_len);
  344|      0|  if(OP_UNLIKELY(binary_suffix_data==NULL))return OP_EFAULT;
  345|      0|  memcpy(binary_suffix_data,_data,_len);
  346|      0|  _tags->user_comments[ncomments]=(char *)binary_suffix_data;
  347|      0|  _tags->comment_lengths[ncomments]=_len;
  348|      0|  return 0;
  349|      0|}
  350|       |
  351|      0|int opus_tagcompare(const char *_tag_name,const char *_comment){
  352|      0|  size_t tag_len;
  353|      0|  tag_len=strlen(_tag_name);
  354|      0|  if(OP_UNLIKELY(tag_len>(size_t)INT_MAX))return -1;
  355|      0|  return opus_tagncompare(_tag_name,(int)tag_len,_comment);
  356|      0|}
  357|       |
  358|      0|int opus_tagncompare(const char *_tag_name,int _tag_len,const char *_comment){
  359|      0|  int ret;
  360|      0|  OP_ASSERT(_tag_len>=0);
  361|      0|  ret=op_strncasecmp(_tag_name,_comment,_tag_len);
  362|      0|  return ret?ret:'='-_comment[_tag_len];
  363|      0|}
  364|       |
  365|      0|const char *opus_tags_query(const OpusTags *_tags,const char *_tag,int _count){
  366|      0|  char   **user_comments;
  367|      0|  size_t   tag_len;
  368|      0|  int      found;
  369|      0|  int      ncomments;
  370|      0|  int      ci;
  371|      0|  tag_len=strlen(_tag);
  372|      0|  if(OP_UNLIKELY(tag_len>(size_t)INT_MAX))return NULL;
  373|      0|  ncomments=_tags->comments;
  374|      0|  user_comments=_tags->user_comments;
  375|      0|  found=0;
  376|      0|  for(ci=0;ci<ncomments;ci++){
  377|      0|    if(!opus_tagncompare(_tag,(int)tag_len,user_comments[ci])){
  378|       |      /*We return a pointer to the data, not a copy.*/
  379|      0|      if(_count==found++)return user_comments[ci]+tag_len+1;
  380|      0|    }
  381|      0|  }
  382|       |  /*Didn't find anything.*/
  383|      0|  return NULL;
  384|      0|}
  385|       |
  386|      0|int opus_tags_query_count(const OpusTags *_tags,const char *_tag){
  387|      0|  char   **user_comments;
  388|      0|  size_t   tag_len;
  389|      0|  int      found;
  390|      0|  int      ncomments;
  391|      0|  int      ci;
  392|      0|  tag_len=strlen(_tag);
  393|      0|  if(OP_UNLIKELY(tag_len>(size_t)INT_MAX))return 0;
  394|      0|  ncomments=_tags->comments;
  395|      0|  user_comments=_tags->user_comments;
  396|      0|  found=0;
  397|      0|  for(ci=0;ci<ncomments;ci++){
  398|      0|    if(!opus_tagncompare(_tag,(int)tag_len,user_comments[ci]))found++;
  399|      0|  }
  400|      0|  return found;
  401|      0|}
  402|       |
  403|       |const unsigned char *opus_tags_get_binary_suffix(const OpusTags *_tags,
  404|      0| int *_len){
  405|      0|  int ncomments;
  406|      0|  int len;
  407|      0|  ncomments=_tags->comments;
  408|      0|  len=_tags->comment_lengths==NULL?0:_tags->comment_lengths[ncomments];
  409|      0|  *_len=len;
  410|      0|  OP_ASSERT(len==0||_tags->user_comments!=NULL);
  411|      0|  return len>0?(const unsigned char *)_tags->user_comments[ncomments]:NULL;
  412|      0|}
  413|       |
  414|       |static int opus_tags_get_gain(const OpusTags *_tags,int *_gain_q8,
  415|      0| const char *_tag_name,size_t _tag_len){
  416|      0|  char **comments;
  417|      0|  int    ncomments;
  418|      0|  int    ci;
  419|      0|  comments=_tags->user_comments;
  420|      0|  ncomments=_tags->comments;
  421|       |  /*Look for the first valid tag with the name _tag_name and use that.*/
  422|      0|  for(ci=0;ci<ncomments;ci++){
  423|      0|    OP_ASSERT(_tag_len<=(size_t)INT_MAX);
  424|      0|    if(opus_tagncompare(_tag_name,(int)_tag_len,comments[ci])==0){
  425|      0|      char       *p;
  426|      0|      opus_int32  gain_q8;
  427|      0|      int         negative;
  428|      0|      p=comments[ci]+_tag_len+1;
  429|      0|      negative=0;
  430|      0|      if(*p=='-'){
  431|      0|        negative=-1;
  432|      0|        p++;
  433|      0|      }
  434|      0|      else if(*p=='+')p++;
  435|      0|      gain_q8=0;
  436|      0|      while(*p>='0'&&*p<='9'){
  437|      0|        gain_q8=10*gain_q8+*p-'0';
  438|      0|        if(gain_q8>32767-negative)break;
  439|      0|        p++;
  440|      0|      }
  441|       |      /*This didn't look like a signed 16-bit decimal integer.
  442|       |        Not a valid gain tag.*/
  443|      0|      if(*p!='\0')continue;
  444|      0|      *_gain_q8=(int)(gain_q8+negative^negative);
  445|      0|      return 0;
  446|      0|    }
  447|      0|  }
  448|      0|  return OP_FALSE;
  449|      0|}
  450|       |
  451|      0|int opus_tags_get_album_gain(const OpusTags *_tags,int *_gain_q8){
  452|      0|  return opus_tags_get_gain(_tags,_gain_q8,"R128_ALBUM_GAIN",15);
  453|      0|}
  454|       |
  455|      0|int opus_tags_get_track_gain(const OpusTags *_tags,int *_gain_q8){
  456|      0|  return opus_tags_get_gain(_tags,_gain_q8,"R128_TRACK_GAIN",15);
  457|      0|}
  458|       |
  459|      0|static int op_is_jpeg(const unsigned char *_buf,size_t _buf_sz){
  460|      0|  return _buf_sz>=3&&memcmp(_buf,"\xFF\xD8\xFF",3)==0;
  461|      0|}
  462|       |
  463|       |/*Tries to extract the width, height, bits per pixel, and palette size of a
  464|       |   JPEG.
  465|       |  On failure, simply leaves its outputs unmodified.*/
  466|       |static void op_extract_jpeg_params(const unsigned char *_buf,size_t _buf_sz,
  467|       | opus_uint32 *_width,opus_uint32 *_height,
  468|      0| opus_uint32 *_depth,opus_uint32 *_colors,int *_has_palette){
  469|      0|  if(op_is_jpeg(_buf,_buf_sz)){
  470|      0|    size_t offs;
  471|      0|    offs=2;
  472|      0|    for(;;){
  473|      0|      size_t segment_len;
  474|      0|      int    marker;
  475|      0|      while(offs<_buf_sz&&_buf[offs]!=0xFF)offs++;
  476|      0|      while(offs<_buf_sz&&_buf[offs]==0xFF)offs++;
  477|      0|      marker=_buf[offs];
  478|      0|      offs++;
  479|       |      /*If we hit EOI* (end of image), or another SOI* (start of image),
  480|       |         or SOS (start of scan), then stop now.*/
  481|      0|      if(offs>=_buf_sz||(marker>=0xD8&&marker<=0xDA))break;
  482|       |      /*RST* (restart markers): skip (no segment length).*/
  483|      0|      else if(marker>=0xD0&&marker<=0xD7)continue;
  484|       |      /*Read the length of the marker segment.*/
  485|      0|      if(_buf_sz-offs<2)break;
  486|      0|      segment_len=_buf[offs]<<8|_buf[offs+1];
  487|      0|      if(segment_len<2||_buf_sz-offs<segment_len)break;
  488|      0|      if(marker==0xC0||(marker>0xC0&&marker<0xD0&&(marker&3)!=0)){
  489|       |        /*Found a SOFn (start of frame) marker segment:*/
  490|      0|        if(segment_len>=8){
  491|      0|          *_height=_buf[offs+3]<<8|_buf[offs+4];
  492|      0|          *_width=_buf[offs+5]<<8|_buf[offs+6];
  493|      0|          *_depth=_buf[offs+2]*_buf[offs+7];
  494|      0|          *_colors=0;
  495|      0|          *_has_palette=0;
  496|      0|        }
  497|      0|        break;
  498|      0|      }
  499|       |      /*Other markers: skip the whole marker segment.*/
  500|      0|      offs+=segment_len;
  501|      0|    }
  502|      0|  }
  503|      0|}
  504|       |
  505|      0|static int op_is_png(const unsigned char *_buf,size_t _buf_sz){
  506|      0|  return _buf_sz>=8&&memcmp(_buf,"\x89PNG\x0D\x0A\x1A\x0A",8)==0;
  507|      0|}
  508|       |
  509|       |/*Tries to extract the width, height, bits per pixel, and palette size of a
  510|       |   PNG.
  511|       |  On failure, simply leaves its outputs unmodified.*/
  512|       |static void op_extract_png_params(const unsigned char *_buf,size_t _buf_sz,
  513|       | opus_uint32 *_width,opus_uint32 *_height,
  514|      0| opus_uint32 *_depth,opus_uint32 *_colors,int *_has_palette){
  515|      0|  if(op_is_png(_buf,_buf_sz)){
  516|      0|    size_t offs;
  517|      0|    offs=8;
  518|      0|    while(_buf_sz-offs>=12){
  519|      0|      ogg_uint32_t chunk_len;
  520|      0|      chunk_len=op_parse_uint32be(_buf+offs);
  521|      0|      if(chunk_len>_buf_sz-(offs+12))break;
  522|      0|      else if(chunk_len==13&&memcmp(_buf+offs+4,"IHDR",4)==0){
  523|      0|        int color_type;
  524|      0|        *_width=op_parse_uint32be(_buf+offs+8);
  525|      0|        *_height=op_parse_uint32be(_buf+offs+12);
  526|      0|        color_type=_buf[offs+17];
  527|      0|        if(color_type==3){
  528|      0|          *_depth=24;
  529|      0|          *_has_palette=1;
  530|      0|        }
  531|      0|        else{
  532|      0|          int sample_depth;
  533|      0|          sample_depth=_buf[offs+16];
  534|      0|          if(color_type==0)*_depth=sample_depth;
  535|      0|          else if(color_type==2)*_depth=sample_depth*3;
  536|      0|          else if(color_type==4)*_depth=sample_depth*2;
  537|      0|          else if(color_type==6)*_depth=sample_depth*4;
  538|      0|          *_colors=0;
  539|      0|          *_has_palette=0;
  540|      0|          break;
  541|      0|        }
  542|      0|      }
  543|      0|      else if(*_has_palette>0&&memcmp(_buf+offs+4,"PLTE",4)==0){
  544|      0|        *_colors=chunk_len/3;
  545|      0|        break;
  546|      0|      }
  547|      0|      offs+=12+chunk_len;
  548|      0|    }
  549|      0|  }
  550|      0|}
  551|       |
  552|      0|static int op_is_gif(const unsigned char *_buf,size_t _buf_sz){
  553|      0|  return _buf_sz>=6&&(memcmp(_buf,"GIF87a",6)==0||memcmp(_buf,"GIF89a",6)==0);
  554|      0|}
  555|       |
  556|       |/*Tries to extract the width, height, bits per pixel, and palette size of a
  557|       |   GIF.
  558|       |  On failure, simply leaves its outputs unmodified.*/
  559|       |static void op_extract_gif_params(const unsigned char *_buf,size_t _buf_sz,
  560|       | opus_uint32 *_width,opus_uint32 *_height,
  561|      0| opus_uint32 *_depth,opus_uint32 *_colors,int *_has_palette){
  562|      0|  if(op_is_gif(_buf,_buf_sz)&&_buf_sz>=14){
  563|      0|    *_width=_buf[6]|_buf[7]<<8;
  564|      0|    *_height=_buf[8]|_buf[9]<<8;
  565|       |    /*libFLAC hard-codes the depth to 24.*/
  566|      0|    *_depth=24;
  567|      0|    *_colors=1<<((_buf[10]&7)+1);
  568|      0|    *_has_palette=1;
  569|      0|  }
  570|      0|}
  571|       |
  572|       |/*The actual implementation of opus_picture_tag_parse().
  573|       |  Unlike the public API, this function requires _pic to already be
  574|       |   initialized, modifies its contents before success is guaranteed, and assumes
  575|       |   the caller will clear it on error.*/
  576|       |static int opus_picture_tag_parse_impl(OpusPictureTag *_pic,const char *_tag,
  577|      0| unsigned char *_buf,size_t _buf_sz,size_t _base64_sz){
  578|      0|  opus_int32   picture_type;
  579|      0|  opus_uint32  mime_type_length;
  580|      0|  char        *mime_type;
  581|      0|  opus_uint32  description_length;
  582|      0|  char        *description;
  583|      0|  opus_uint32  width;
  584|      0|  opus_uint32  height;
  585|      0|  opus_uint32  depth;
  586|      0|  opus_uint32  colors;
  587|      0|  opus_uint32  data_length;
  588|      0|  opus_uint32  file_width;
  589|      0|  opus_uint32  file_height;
  590|      0|  opus_uint32  file_depth;
  591|      0|  opus_uint32  file_colors;
  592|      0|  int          format;
  593|      0|  int          has_palette;
  594|      0|  int          colors_set;
  595|      0|  size_t       i;
  596|       |  /*Decode the BASE64 data.*/
  597|      0|  OP_ASSERT(_base64_sz>=11);
  598|      0|  for(i=0;i<_base64_sz;i++){
  599|      0|    opus_uint32 value;
  600|      0|    int         j;
  601|      0|    value=0;
  602|      0|    for(j=0;j<4;j++){
  603|      0|      unsigned c;
  604|      0|      unsigned d;
  605|      0|      c=(unsigned char)_tag[4*i+j];
  606|      0|      if(c=='+')d=62;
  607|      0|      else if(c=='/')d=63;
  608|      0|      else if(c>='0'&&c<='9')d=52+c-'0';
  609|      0|      else if(c>='a'&&c<='z')d=26+c-'a';
  610|      0|      else if(c>='A'&&c<='Z')d=c-'A';
  611|      0|      else if(c=='='&&3*i+j>_buf_sz)d=0;
  612|      0|      else return OP_ENOTFORMAT;
  613|      0|      value=value<<6|d;
  614|      0|    }
  615|      0|    _buf[3*i]=(unsigned char)(value>>16);
  616|      0|    if(3*i+1<_buf_sz){
  617|      0|      _buf[3*i+1]=(unsigned char)(value>>8);
  618|      0|      if(3*i+2<_buf_sz)_buf[3*i+2]=(unsigned char)value;
  619|      0|    }
  620|      0|  }
  621|      0|  i=0;
  622|      0|  picture_type=op_parse_uint32be(_buf+i);
  623|      0|  i+=4;
  624|       |  /*Extract the MIME type.*/
  625|      0|  mime_type_length=op_parse_uint32be(_buf+i);
  626|      0|  i+=4;
  627|      0|  if(mime_type_length>_buf_sz-32)return OP_ENOTFORMAT;
  628|      0|  mime_type=(char *)_ogg_malloc(sizeof(*_pic->mime_type)*(mime_type_length+1));
  629|      0|  if(mime_type==NULL)return OP_EFAULT;
  630|      0|  memcpy(mime_type,_buf+i,sizeof(*mime_type)*mime_type_length);
  631|      0|  mime_type[mime_type_length]='\0';
  632|      0|  _pic->mime_type=mime_type;
  633|      0|  i+=mime_type_length;
  634|       |  /*Extract the description string.*/
  635|      0|  description_length=op_parse_uint32be(_buf+i);
  636|      0|  i+=4;
  637|      0|  if(description_length>_buf_sz-mime_type_length-32)return OP_ENOTFORMAT;
  638|      0|  description=
  639|      0|   (char *)_ogg_malloc(sizeof(*_pic->mime_type)*(description_length+1));
  640|      0|  if(description==NULL)return OP_EFAULT;
  641|      0|  memcpy(description,_buf+i,sizeof(*description)*description_length);
  642|      0|  description[description_length]='\0';
  643|      0|  _pic->description=description;
  644|      0|  i+=description_length;
  645|       |  /*Extract the remaining fields.*/
  646|      0|  width=op_parse_uint32be(_buf+i);
  647|      0|  i+=4;
  648|      0|  height=op_parse_uint32be(_buf+i);
  649|      0|  i+=4;
  650|      0|  depth=op_parse_uint32be(_buf+i);
  651|      0|  i+=4;
  652|      0|  colors=op_parse_uint32be(_buf+i);
  653|      0|  i+=4;
  654|       |  /*If one of these is set, they all must be, but colors==0 is a valid value.*/
  655|      0|  colors_set=width!=0||height!=0||depth!=0||colors!=0;
  656|      0|  if((width==0||height==0||depth==0)&&colors_set)return OP_ENOTFORMAT;
  657|      0|  data_length=op_parse_uint32be(_buf+i);
  658|      0|  i+=4;
  659|      0|  if(data_length>_buf_sz-i)return OP_ENOTFORMAT;
  660|       |  /*Trim extraneous data so we don't copy it below.*/
  661|      0|  _buf_sz=i+data_length;
  662|       |  /*Attempt to determine the image format.*/
  663|      0|  format=OP_PIC_FORMAT_UNKNOWN;
  664|      0|  if(mime_type_length==3&&strcmp(mime_type,"-->")==0){
  665|      0|    format=OP_PIC_FORMAT_URL;
  666|       |    /*Picture type 1 must be a 32x32 PNG.*/
  667|      0|    if(picture_type==1&&(width!=0||height!=0)&&(width!=32||height!=32)){
  668|      0|      return OP_ENOTFORMAT;
  669|      0|    }
  670|       |    /*Append a terminating NUL for the convenience of our callers.*/
  671|      0|    _buf[_buf_sz++]='\0';
  672|      0|  }
  673|      0|  else{
  674|      0|    if(mime_type_length==10
  675|      0|     &&op_strncasecmp(mime_type,"image/jpeg",mime_type_length)==0){
  676|      0|      if(op_is_jpeg(_buf+i,data_length))format=OP_PIC_FORMAT_JPEG;
  677|      0|    }
  678|      0|    else if(mime_type_length==9
  679|      0|     &&op_strncasecmp(mime_type,"image/png",mime_type_length)==0){
  680|      0|      if(op_is_png(_buf+i,data_length))format=OP_PIC_FORMAT_PNG;
  681|      0|    }
  682|      0|    else if(mime_type_length==9
  683|      0|     &&op_strncasecmp(mime_type,"image/gif",mime_type_length)==0){
  684|      0|      if(op_is_gif(_buf+i,data_length))format=OP_PIC_FORMAT_GIF;
  685|      0|    }
  686|      0|    else if(mime_type_length==0||(mime_type_length==6
  687|      0|     &&op_strncasecmp(mime_type,"image/",mime_type_length)==0)){
  688|      0|      if(op_is_jpeg(_buf+i,data_length))format=OP_PIC_FORMAT_JPEG;
  689|      0|      else if(op_is_png(_buf+i,data_length))format=OP_PIC_FORMAT_PNG;
  690|      0|      else if(op_is_gif(_buf+i,data_length))format=OP_PIC_FORMAT_GIF;
  691|      0|    }
  692|      0|    file_width=file_height=file_depth=file_colors=0;
  693|      0|    has_palette=-1;
  694|      0|    switch(format){
  695|      0|      case OP_PIC_FORMAT_JPEG:{
  696|      0|        op_extract_jpeg_params(_buf+i,data_length,
  697|      0|         &file_width,&file_height,&file_depth,&file_colors,&has_palette);
  698|      0|      }break;
  699|      0|      case OP_PIC_FORMAT_PNG:{
  700|      0|        op_extract_png_params(_buf+i,data_length,
  701|      0|         &file_width,&file_height,&file_depth,&file_colors,&has_palette);
  702|      0|      }break;
  703|      0|      case OP_PIC_FORMAT_GIF:{
  704|      0|        op_extract_gif_params(_buf+i,data_length,
  705|      0|         &file_width,&file_height,&file_depth,&file_colors,&has_palette);
  706|      0|      }break;
  707|      0|    }
  708|      0|    if(has_palette>=0){
  709|       |      /*If we successfully extracted these parameters from the image, override
  710|       |         any declared values.*/
  711|      0|      width=file_width;
  712|      0|      height=file_height;
  713|      0|      depth=file_depth;
  714|      0|      colors=file_colors;
  715|      0|    }
  716|       |    /*Picture type 1 must be a 32x32 PNG.*/
  717|      0|    if(picture_type==1&&(format!=OP_PIC_FORMAT_PNG||width!=32||height!=32)){
  718|      0|      return OP_ENOTFORMAT;
  719|      0|    }
  720|      0|  }
  721|       |  /*Adjust _buf_sz instead of using data_length to capture the terminating NUL
  722|       |     for URLs.*/
  723|      0|  _buf_sz-=i;
  724|      0|  memmove(_buf,_buf+i,sizeof(*_buf)*_buf_sz);
  725|      0|  _buf=(unsigned char *)_ogg_realloc(_buf,_buf_sz);
  726|      0|  if(_buf_sz>0&&_buf==NULL)return OP_EFAULT;
  727|      0|  _pic->type=picture_type;
  728|      0|  _pic->width=width;
  729|      0|  _pic->height=height;
  730|      0|  _pic->depth=depth;
  731|      0|  _pic->colors=colors;
  732|      0|  _pic->data_length=data_length;
  733|      0|  _pic->data=_buf;
  734|      0|  _pic->format=format;
  735|      0|  return 0;
  736|      0|}
  737|       |
  738|      0|int opus_picture_tag_parse(OpusPictureTag *_pic,const char *_tag){
  739|      0|  OpusPictureTag  pic;
  740|      0|  unsigned char  *buf;
  741|      0|  size_t          base64_sz;
  742|      0|  size_t          buf_sz;
  743|      0|  size_t          tag_length;
  744|      0|  int             ret;
  745|      0|  if(opus_tagncompare("METADATA_BLOCK_PICTURE",22,_tag)==0)_tag+=23;
  746|       |  /*Figure out how much BASE64-encoded data we have.*/
  747|      0|  tag_length=strlen(_tag);
  748|      0|  if(tag_length&3)return OP_ENOTFORMAT;
  749|      0|  base64_sz=tag_length>>2;
  750|      0|  buf_sz=3*base64_sz;
  751|      0|  if(buf_sz<32)return OP_ENOTFORMAT;
  752|      0|  if(_tag[tag_length-1]=='=')buf_sz--;
  753|      0|  if(_tag[tag_length-2]=='=')buf_sz--;
  754|      0|  if(buf_sz<32)return OP_ENOTFORMAT;
  755|       |  /*Allocate an extra byte to allow appending a terminating NUL to URL data.*/
  756|      0|  buf=(unsigned char *)_ogg_malloc(sizeof(*buf)*(buf_sz+1));
  757|      0|  if(buf==NULL)return OP_EFAULT;
  758|      0|  opus_picture_tag_init(&pic);
  759|      0|  ret=opus_picture_tag_parse_impl(&pic,_tag,buf,buf_sz,base64_sz);
  760|      0|  if(ret<0){
  761|      0|    opus_picture_tag_clear(&pic);
  762|      0|    _ogg_free(buf);
  763|      0|  }
  764|      0|  else *_pic=*&pic;
  765|      0|  return ret;
  766|      0|}
  767|       |
  768|      0|void opus_picture_tag_init(OpusPictureTag *_pic){
  769|      0|  memset(_pic,0,sizeof(*_pic));
  770|      0|}
  771|       |
  772|      0|void opus_picture_tag_clear(OpusPictureTag *_pic){
  773|      0|  _ogg_free(_pic->description);
  774|      0|  _ogg_free(_pic->mime_type);
  775|      0|  _ogg_free(_pic->data);
  776|      0|}

/home/fyu/Workspace/hapi-client/test/test-api/opusfile/src/internal.c:
    1|       |/********************************************************************
    2|       | *                                                                  *
    3|       | * THIS FILE IS PART OF THE libopusfile SOFTWARE CODEC SOURCE CODE. *
    4|       | * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
    5|       | * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
    6|       | * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
    7|       | *                                                                  *
    8|       | * THE libopusfile SOURCE CODE IS (C) COPYRIGHT 2012-2020           *
    9|       | * by the Xiph.Org Foundation and contributors https://xiph.org/    *
   10|       | *                                                                  *
   11|       | ********************************************************************/
   12|       |#ifdef HAVE_CONFIG_H
   13|       |#include "config.h"
   14|       |#endif
   15|       |
   16|       |#include "internal.h"
   17|       |
   18|       |#if defined(OP_ENABLE_ASSERTIONS)
   19|       |void op_fatal_impl(const char *_str,const char *_file,int _line){
   20|       |  fprintf(stderr,"Fatal (internal) error in %s, line %i: %s\n",
   21|       |   _file,_line,_str);
   22|       |  abort();
   23|       |}
   24|       |#endif
   25|       |
   26|       |/*A version of strncasecmp() that is guaranteed to only ignore the case of
   27|       |   ASCII characters.*/
   28|      0|int op_strncasecmp(const char *_a,const char *_b,int _n){
   29|      0|  int i;
   30|      0|  for(i=0;i<_n;i++){
   31|      0|    int a;
   32|      0|    int b;
   33|      0|    int d;
   34|      0|    a=_a[i];
   35|      0|    b=_b[i];
   36|      0|    if(a>='a'&&a<='z')a-='a'-'A';
   37|      0|    if(b>='a'&&b<='z')b-='a'-'A';
   38|      0|    d=a-b;
   39|      0|    if(d)return d;
   40|      0|  }
   41|      0|  return 0;
   42|      0|}

/home/fyu/Workspace/hapi-client/test/test-api/opusfile/src/internal.h:
    1|       |/********************************************************************
    2|       | *                                                                  *
    3|       | * THIS FILE IS PART OF THE libopusfile SOFTWARE CODEC SOURCE CODE. *
    4|       | * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
    5|       | * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
    6|       | * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
    7|       | *                                                                  *
    8|       | * THE libopusfile SOURCE CODE IS (C) COPYRIGHT 2012-2020           *
    9|       | * by the Xiph.Org Foundation and contributors https://xiph.org/    *
   10|       | *                                                                  *
   11|       | ********************************************************************/
   12|       |#if !defined(_opusfile_internal_h)
   13|       |# define _opusfile_internal_h (1)
   14|       |
   15|       |# if !defined(_REENTRANT)
   16|       |#  define _REENTRANT
   17|       |# endif
   18|       |# if !defined(_GNU_SOURCE)
   19|       |#  define _GNU_SOURCE
   20|       |# endif
   21|       |# if !defined(_LARGEFILE_SOURCE)
   22|       |#  define _LARGEFILE_SOURCE
   23|       |# endif
   24|       |# if !defined(_LARGEFILE64_SOURCE)
   25|       |#  define _LARGEFILE64_SOURCE
   26|       |# endif
   27|       |# if !defined(_FILE_OFFSET_BITS)
   28|       |#  define _FILE_OFFSET_BITS 64
   29|       |# endif
   30|       |
   31|       |# include <stdlib.h>
   32|       |# include <opusfile.h>
   33|       |
   34|       |typedef struct OggOpusLink OggOpusLink;
   35|       |
   36|       |# if defined(OP_FIXED_POINT)
   37|       |
   38|       |typedef opus_int16 op_sample;
   39|       |
   40|       |# else
   41|       |
   42|       |typedef float      op_sample;
   43|       |
   44|       |/*We're using this define to test for libopus 1.1 or later until libopus
   45|       |   provides a better mechanism.*/
   46|       |#  if defined(OPUS_GET_EXPERT_FRAME_DURATION_REQUEST)
   47|       |/*Enable soft clipping prevention in 16-bit decodes.*/
   48|       |#   define OP_SOFT_CLIP (1)
   49|       |#  endif
   50|       |
   51|       |# endif
   52|       |
   53|       |# if OP_GNUC_PREREQ(4,2)
   54|       |/*Disable excessive warnings about the order of operations.*/
   55|       |#  pragma GCC diagnostic ignored "-Wparentheses"
   56|       |# elif defined(_MSC_VER)
   57|       |/*Disable excessive warnings about the order of operations.*/
   58|       |#  pragma warning(disable:4554)
   59|       |/*Disable warnings about "deprecated" POSIX functions.*/
   60|       |#  pragma warning(disable:4996)
   61|       |# endif
   62|       |
   63|       |# if OP_GNUC_PREREQ(3,0)
   64|       |/*Another alternative is
   65|       |    (__builtin_constant_p(_x)?!!(_x):__builtin_expect(!!(_x),1))
   66|       |   but that evaluates _x multiple times, which may be bad.*/
   67|    290|#  define OP_LIKELY(_x) (__builtin_expect(!!(_x),1))
   68|  1.47k|#  define OP_UNLIKELY(_x) (__builtin_expect(!!(_x),0))
   69|       |# else
   70|       |#  define OP_LIKELY(_x)   (!!(_x))
   71|       |#  define OP_UNLIKELY(_x) (!!(_x))
   72|       |# endif
   73|       |
   74|       |# if defined(OP_ENABLE_ASSERTIONS)
   75|       |#  if OP_GNUC_PREREQ(2,5)||__SUNPRO_C>=0x590
   76|       |__attribute__((noreturn))
   77|       |#  endif
   78|       |void op_fatal_impl(const char *_str,const char *_file,int _line);
   79|       |
   80|       |#  define OP_FATAL(_str) (op_fatal_impl(_str,__FILE__,__LINE__))
   81|       |
   82|       |#  define OP_ASSERT(_cond) \
   83|       |  do{ \
   84|       |    if(OP_UNLIKELY(!(_cond)))OP_FATAL("assertion failed: " #_cond); \
   85|       |  } \
   86|       |  while(0)
   87|       |#  define OP_ALWAYS_TRUE(_cond) OP_ASSERT(_cond)
   88|       |
   89|       |# else
   90|       |#  define OP_FATAL(_str) abort()
   91|       |#  define OP_ASSERT(_cond)
   92|    151|#  define OP_ALWAYS_TRUE(_cond) ((void)(_cond))
   93|       |# endif
   94|       |
   95|      0|# define OP_INT64_MAX (2*(((ogg_int64_t)1<<62)-1)|1)
   96|      0|# define OP_INT64_MIN (-OP_INT64_MAX-1)
   97|      0|# define OP_INT32_MAX (2*(((ogg_int32_t)1<<30)-1)|1)
   98|       |# define OP_INT32_MIN (-OP_INT32_MAX-1)
   99|       |
  100|     81|# define OP_MIN(_a,_b)        ((_a)<(_b)?(_a):(_b))
  101|      6|# define OP_MAX(_a,_b)        ((_a)>(_b)?(_a):(_b))
  102|      3|# define OP_CLAMP(_lo,_x,_hi) (OP_MAX(_lo,OP_MIN(_x,_hi)))
  103|       |
  104|       |/*Advance a file offset by the given amount, clamping against OP_INT64_MAX.
  105|       |  This is used to advance a known offset by things like OP_CHUNK_SIZE or
  106|       |   OP_PAGE_SIZE_MAX, while making sure to avoid signed overflow.
  107|       |  It assumes that both _offset and _amount are non-negative.*/
  108|       |#define OP_ADV_OFFSET(_offset,_amount) \
  109|       | (OP_MIN(_offset,OP_INT64_MAX-(_amount))+(_amount))
  110|       |
  111|       |/*The maximum channel count for any mapping we'll actually decode.*/
  112|      0|# define OP_NCHANNELS_MAX (8)
  113|       |
  114|       |/*Initial state.*/
  115|       |# define  OP_NOTOPEN   (0)
  116|       |/*We've found the first Opus stream in the first link.*/
  117|      3|# define  OP_PARTOPEN  (1)
  118|      6|# define  OP_OPENED    (2)
  119|       |/*We've found the first Opus stream in the current link.*/
  120|     12|# define  OP_STREAMSET (3)
  121|       |/*We've initialized the decoder for the chosen Opus stream in the current
  122|       |   link.*/
  123|      6|# define  OP_INITSET   (4)
  124|       |
  125|       |/*Information cached for a single link in a chained Ogg Opus file.
  126|       |  We choose the first Opus stream encountered in each link to play back (and
  127|       |   require at least one).*/
  128|       |struct OggOpusLink{
  129|       |  /*The byte offset of the first header page in this link.*/
  130|       |  opus_int64   offset;
  131|       |  /*The byte offset of the first data page from the chosen Opus stream in this
  132|       |     link (after the headers).*/
  133|       |  opus_int64   data_offset;
  134|       |  /*The byte offset of the last page from the chosen Opus stream in this link.
  135|       |    This is used when seeking to ensure we find a page before the last one, so
  136|       |     that end-trimming calculations work properly.
  137|       |    This is only valid for seekable sources.*/
  138|       |  opus_int64   end_offset;
  139|       |  /*The total duration of all prior links.
  140|       |    This is always zero for non-seekable sources.*/
  141|       |  ogg_int64_t  pcm_file_offset;
  142|       |  /*The granule position of the last sample.
  143|       |    This is only valid for seekable sources.*/
  144|       |  ogg_int64_t  pcm_end;
  145|       |  /*The granule position before the first sample.*/
  146|       |  ogg_int64_t  pcm_start;
  147|       |  /*The serial number.*/
  148|       |  ogg_uint32_t serialno;
  149|       |  /*The contents of the info header.*/
  150|       |  OpusHead     head;
  151|       |  /*The contents of the comment header.*/
  152|       |  OpusTags     tags;
  153|       |};
  154|       |
  155|       |struct OggOpusFile{
  156|       |  /*The callbacks used to access the stream.*/
  157|       |  OpusFileCallbacks  callbacks;
  158|       |  /*A FILE *, memory buffer, etc.*/
  159|       |  void              *stream;
  160|       |  /*Whether or not we can seek with this stream.*/
  161|       |  int                seekable;
  162|       |  /*The number of links in this chained Ogg Opus file.*/
  163|       |  int                nlinks;
  164|       |  /*The cached information from each link in a chained Ogg Opus file.
  165|       |    If stream isn't seekable (e.g., it's a pipe), only the current link
  166|       |     appears.*/
  167|       |  OggOpusLink       *links;
  168|       |  /*The number of serial numbers from a single link.*/
  169|       |  int                nserialnos;
  170|       |  /*The capacity of the list of serial numbers from a single link.*/
  171|       |  int                cserialnos;
  172|       |  /*Storage for the list of serial numbers from a single link.
  173|       |    This is a scratch buffer used when scanning the BOS pages at the start of
  174|       |     each link.*/
  175|       |  ogg_uint32_t      *serialnos;
  176|       |  /*This is the current offset of the data processed by the ogg_sync_state.
  177|       |    After a seek, this should be set to the target offset so that we can track
  178|       |     the byte offsets of subsequent pages.
  179|       |    After a call to op_get_next_page(), this will point to the first byte after
  180|       |     that page.*/
  181|       |  opus_int64         offset;
  182|       |  /*The total size of this stream, or -1 if it's unseekable.*/
  183|       |  opus_int64         end;
  184|       |  /*Used to locate pages in the stream.*/
  185|       |  ogg_sync_state     oy;
  186|       |  /*One of OP_NOTOPEN, OP_PARTOPEN, OP_OPENED, OP_STREAMSET, OP_INITSET.*/
  187|       |  int                ready_state;
  188|       |  /*The current link being played back.*/
  189|       |  int                cur_link;
  190|       |  /*The number of decoded samples to discard from the start of decoding.*/
  191|       |  opus_int32         cur_discard_count;
  192|       |  /*The granule position of the previous packet (current packet start time).*/
  193|       |  ogg_int64_t        prev_packet_gp;
  194|       |  /*The stream offset of the most recent page with completed packets, or -1.
  195|       |    This is only needed to recover continued packet data in the seeking logic,
  196|       |     when we use the current position as one of our bounds, only to later
  197|       |     discover it was the correct starting point.*/
  198|       |  opus_int64         prev_page_offset;
  199|       |  /*The number of bytes read since the last bitrate query, including framing.*/
  200|       |  opus_int64         bytes_tracked;
  201|       |  /*The number of samples decoded since the last bitrate query.*/
  202|       |  ogg_int64_t        samples_tracked;
  203|       |  /*Takes physical pages and welds them into a logical stream of packets.*/
  204|       |  ogg_stream_state   os;
  205|       |  /*Re-timestamped packets from a single page.
  206|       |    Buffering these relies on the undocumented libogg behavior that ogg_packet
  207|       |     pointers remain valid until the next page is submitted to the
  208|       |     ogg_stream_state they came from.*/
  209|       |  ogg_packet         op[255];
  210|       |  /*The index of the next packet to return.*/
  211|       |  int                op_pos;
  212|       |  /*The total number of packets available.*/
  213|       |  int                op_count;
  214|       |  /*Central working state for the packet-to-PCM decoder.*/
  215|       |  OpusMSDecoder     *od;
  216|       |  /*The application-provided packet decode callback.*/
  217|       |  op_decode_cb_func  decode_cb;
  218|       |  /*The application-provided packet decode callback context.*/
  219|       |  void              *decode_cb_ctx;
  220|       |  /*The stream count used to initialize the decoder.*/
  221|       |  int                od_stream_count;
  222|       |  /*The coupled stream count used to initialize the decoder.*/
  223|       |  int                od_coupled_count;
  224|       |  /*The channel count used to initialize the decoder.*/
  225|       |  int                od_channel_count;
  226|       |  /*The channel mapping used to initialize the decoder.*/
  227|       |  unsigned char      od_mapping[OP_NCHANNELS_MAX];
  228|       |  /*The buffered data for one decoded packet.*/
  229|       |  op_sample         *od_buffer;
  230|       |  /*The current position in the decoded buffer.*/
  231|       |  int                od_buffer_pos;
  232|       |  /*The number of valid samples in the decoded buffer.*/
  233|       |  int                od_buffer_size;
  234|       |  /*The type of gain offset to apply.
  235|       |    One of OP_HEADER_GAIN, OP_ALBUM_GAIN, OP_TRACK_GAIN, or OP_ABSOLUTE_GAIN.*/
  236|       |  int                gain_type;
  237|       |  /*The offset to apply to the gain.*/
  238|       |  opus_int32         gain_offset_q8;
  239|       |  /*Internal state for soft clipping and dithering float->short output.*/
  240|       |#if !defined(OP_FIXED_POINT)
  241|       |# if defined(OP_SOFT_CLIP)
  242|       |  float              clip_state[OP_NCHANNELS_MAX];
  243|       |# endif
  244|       |  float              dither_a[OP_NCHANNELS_MAX*4];
  245|       |  float              dither_b[OP_NCHANNELS_MAX*4];
  246|       |  opus_uint32        dither_seed;
  247|       |  int                dither_mute;
  248|       |  int                dither_disabled;
  249|       |  /*The number of channels represented by the internal state.
  250|       |    This gets set to 0 whenever anything that would prevent state propagation
  251|       |     occurs (switching between the float/short APIs, or between the
  252|       |     stereo/multistream APIs).*/
  253|       |  int                state_channel_count;
  254|       |#endif
  255|       |};
  256|       |
  257|       |int op_strncasecmp(const char *_a,const char *_b,int _n);
  258|       |
  259|       |#endif

/home/fyu/Workspace/hapi-client/test/test-api/opusfile/src/opusfile.c:
    1|       |/********************************************************************
    2|       | *                                                                  *
    3|       | * THIS FILE IS PART OF THE libopusfile SOFTWARE CODEC SOURCE CODE. *
    4|       | * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
    5|       | * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
    6|       | * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
    7|       | *                                                                  *
    8|       | * THE libopusfile SOURCE CODE IS (C) COPYRIGHT 1994-2020           *
    9|       | * by the Xiph.Org Foundation and contributors https://xiph.org/    *
   10|       | *                                                                  *
   11|       | ********************************************************************
   12|       |
   13|       | function: stdio-based convenience library for opening/seeking/decoding
   14|       | last mod: $Id: vorbisfile.c 17573 2010-10-27 14:53:59Z xiphmont $
   15|       |
   16|       | ********************************************************************/
   17|       |#ifdef HAVE_CONFIG_H
   18|       |#include "config.h"
   19|       |#endif
   20|       |
   21|       |#include "internal.h"
   22|       |#include <stdio.h>
   23|       |#include <stdlib.h>
   24|       |#include <errno.h>
   25|       |#include <limits.h>
   26|       |#include <string.h>
   27|       |#include <math.h>
   28|       |
   29|       |#include "opusfile.h"
   30|       |
   31|       |/*This implementation is largely based off of libvorbisfile.
   32|       |  All of the Ogg bits work roughly the same, though I have made some
   33|       |   "improvements" that have not been folded back there, yet.*/
   34|       |
   35|       |/*A 'chained bitstream' is an Ogg Opus bitstream that contains more than one
   36|       |   logical bitstream arranged end to end (the only form of Ogg multiplexing
   37|       |   supported by this library.
   38|       |  Grouping (parallel multiplexing) is not supported, except to the extent that
   39|       |   if there are multiple logical Ogg streams in a single link of the chain, we
   40|       |   will ignore all but the first Opus stream we find.*/
   41|       |
   42|       |/*An Ogg Opus file can be played beginning to end (streamed) without worrying
   43|       |   ahead of time about chaining (see opusdec from the opus-tools package).
   44|       |  If we have the whole file, however, and want random access
   45|       |   (seeking/scrubbing) or desire to know the total length/time of a file, we
   46|       |   need to account for the possibility of chaining.*/
   47|       |
   48|       |/*We can handle things a number of ways.
   49|       |  We can determine the entire bitstream structure right off the bat, or find
   50|       |   pieces on demand.
   51|       |  This library determines and caches structure for the entire bitstream, but
   52|       |   builds a virtual decoder on the fly when moving between links in the chain.*/
   53|       |
   54|       |/*There are also different ways to implement seeking.
   55|       |  Enough information exists in an Ogg bitstream to seek to sample-granularity
   56|       |   positions in the output.
   57|       |  Or, one can seek by picking some portion of the stream roughly in the desired
   58|       |   area if we only want coarse navigation through the stream.
   59|       |  We implement and expose both strategies.*/
   60|       |
   61|       |/*The maximum number of bytes in a page (including the page headers).*/
   62|       |#define OP_PAGE_SIZE_MAX  (65307)
   63|       |/*The default amount to seek backwards per step when trying to find the
   64|       |   previous page.
   65|       |  This must be at least as large as the maximum size of a page.*/
   66|      3|#define OP_CHUNK_SIZE     (65536)
   67|       |/*The maximum amount to seek backwards per step when trying to find the
   68|       |   previous page.*/
   69|       |#define OP_CHUNK_SIZE_MAX (1024*(opus_int32)1024)
   70|       |/*A smaller read size is needed for low-rate streaming.*/
   71|     17|#define OP_READ_SIZE      (2048)
   72|       |
   73|       |int op_test(OpusHead *_head,
   74|      0| const unsigned char *_initial_data,size_t _initial_bytes){
   75|      0|  ogg_sync_state  oy;
   76|      0|  char           *data;
   77|      0|  int             err;
   78|       |  /*The first page of a normal Opus file will be at most 57 bytes (27 Ogg
   79|       |     page header bytes + 1 lacing value + 21 Opus header bytes + 8 channel
   80|       |     mapping bytes).
   81|       |    It will be at least 47 bytes (27 Ogg page header bytes + 1 lacing value +
   82|       |     19 Opus header bytes using channel mapping family 0).
   83|       |    If we don't have at least that much data, give up now.*/
   84|      0|  if(_initial_bytes<47)return OP_FALSE;
   85|       |  /*Only proceed if we start with the magic OggS string.
   86|       |    This is to prevent us spending a lot of time allocating memory and looking
   87|       |     for Ogg pages in non-Ogg files.*/
   88|      0|  if(memcmp(_initial_data,"OggS",4)!=0)return OP_ENOTFORMAT;
   89|      0|  if(OP_UNLIKELY(_initial_bytes>(size_t)LONG_MAX))return OP_EFAULT;
   90|      0|  ogg_sync_init(&oy);
   91|      0|  data=ogg_sync_buffer(&oy,(long)_initial_bytes);
   92|      0|  if(data!=NULL){
   93|      0|    ogg_stream_state os;
   94|      0|    ogg_page         og;
   95|      0|    int              ret;
   96|      0|    memcpy(data,_initial_data,_initial_bytes);
   97|      0|    ogg_sync_wrote(&oy,(long)_initial_bytes);
   98|      0|    ogg_stream_init(&os,-1);
   99|      0|    err=OP_FALSE;
  100|      0|    do{
  101|      0|      ogg_packet op;
  102|      0|      ret=ogg_sync_pageout(&oy,&og);
  103|       |      /*Ignore holes.*/
  104|      0|      if(ret<0)continue;
  105|       |      /*Stop if we run out of data.*/
  106|      0|      if(!ret)break;
  107|      0|      ogg_stream_reset_serialno(&os,ogg_page_serialno(&og));
  108|      0|      ogg_stream_pagein(&os,&og);
  109|       |      /*Only process the first packet on this page (if it's a BOS packet,
  110|       |         it's required to be the only one).*/
  111|      0|      if(ogg_stream_packetout(&os,&op)==1){
  112|      0|        if(op.b_o_s){
  113|      0|          ret=opus_head_parse(_head,op.packet,op.bytes);
  114|       |          /*If this didn't look like Opus, keep going.*/
  115|      0|          if(ret==OP_ENOTFORMAT)continue;
  116|       |          /*Otherwise we're done, one way or another.*/
  117|      0|          err=ret;
  118|      0|        }
  119|       |        /*We finished parsing the headers.
  120|       |          There is no Opus to be found.*/
  121|      0|        else err=OP_ENOTFORMAT;
  122|      0|      }
  123|      0|    }
  124|      0|    while(err==OP_FALSE);
  125|      0|    ogg_stream_clear(&os);
  126|      0|  }
  127|      0|  else err=OP_EFAULT;
  128|      0|  ogg_sync_clear(&oy);
  129|      0|  return err;
  130|      0|}
  131|       |
  132|       |/*Many, many internal helpers.
  133|       |  The intention is not to be confusing.
  134|       |  Rampant duplication and monolithic function implementation (though we do have
  135|       |   some large, omnibus functions still) would be harder to understand anyway.
  136|       |  The high level functions are last.
  137|       |  Begin grokking near the end of the file if you prefer to read things
  138|       |   top-down.*/
  139|       |
  140|       |/*The read/seek functions track absolute position within the stream.*/
  141|       |
  142|       |/*Read a little more data from the file/pipe into the ogg_sync framer.
  143|       |  _nbytes: The maximum number of bytes to read.
  144|       |  Return: A positive number of bytes read on success, 0 on end-of-file, or a
  145|       |           negative value on failure.*/
  146|     92|static int op_get_data(OggOpusFile *_of,int _nbytes){
  147|     92|  unsigned char *buffer;
  148|     92|  int            nbytes;
  149|     92|  OP_ASSERT(_nbytes>0);
  150|     92|  buffer=(unsigned char *)ogg_sync_buffer(&_of->oy,_nbytes);
  151|     92|  nbytes=(int)(*_of->callbacks.read)(_of->stream,buffer,_nbytes);
  152|     92|  OP_ASSERT(nbytes<=_nbytes);
  153|     92|  if(OP_LIKELY(nbytes>0))ogg_sync_wrote(&_of->oy,nbytes);
  154|     92|  return nbytes;
  155|     92|}
  156|       |
  157|       |/*Save a tiny smidge of verbosity to make the code more readable.*/
  158|      3|static int op_seek_helper(OggOpusFile *_of,opus_int64 _offset){
  159|      3|  if(_offset==_of->offset)return 0;
  160|      3|  if(_of->callbacks.seek==NULL
  161|      3|   ||(*_of->callbacks.seek)(_of->stream,_offset,SEEK_SET)){
  162|      0|    return OP_EREAD;
  163|      0|  }
  164|      3|  _of->offset=_offset;
  165|      3|  ogg_sync_reset(&_of->oy);
  166|      3|  return 0;
  167|      3|}
  168|       |
  169|       |/*Get the current position indicator of the underlying stream.
  170|       |  This should be the same as the value reported by tell().*/
  171|     80|static opus_int64 op_position(const OggOpusFile *_of){
  172|       |  /*The current position indicator is _not_ simply offset.
  173|       |    We may also have unprocessed, buffered data in the sync state.*/
  174|     80|  return _of->offset+_of->oy.fill-_of->oy.returned;
  175|     80|}
  176|       |
  177|       |/*From the head of the stream, get the next page.
  178|       |  _boundary specifies if the function is allowed to fetch more data from the
  179|       |   stream (and how much) or only use internally buffered data.
  180|       |  _boundary: -1: Unbounded search.
  181|       |              0: Read no additional data.
  182|       |                 Use only cached data.
  183|       |              n: Search for the start of a new page up to file position n.
  184|       |  Return: n>=0:       Found a page at absolute offset n.
  185|       |          OP_FALSE:   Hit the _boundary limit.
  186|       |          OP_EREAD:   An underlying read operation failed.
  187|       |          OP_BADLINK: We hit end-of-file before reaching _boundary.*/
  188|       |static opus_int64 op_get_next_page(OggOpusFile *_of,ogg_page *_og,
  189|     24| opus_int64 _boundary){
  190|    187|  while(_boundary<=0||_of->offset<_boundary){
  191|    187|    int more;
  192|    187|    more=ogg_sync_pageseek(&_of->oy,_og);
  193|       |    /*Skipped (-more) bytes.*/
  194|    187|    if(OP_UNLIKELY(more<0))_of->offset-=more;
  195|    115|    else if(more==0){
  196|     94|      int read_nbytes;
  197|     94|      int ret;
  198|       |      /*Send more paramedics.*/
  199|     94|      if(!_boundary)return OP_FALSE;
  200|     94|      if(_boundary<0)read_nbytes=OP_READ_SIZE;
  201|     77|      else{
  202|     77|        opus_int64 position;
  203|     77|        position=op_position(_of);
  204|     77|        if(position>=_boundary)return OP_FALSE;
  205|     75|        read_nbytes=(int)OP_MIN(_boundary-position,OP_READ_SIZE);
  206|     75|      }
  207|     92|      ret=op_get_data(_of,read_nbytes);
  208|     92|      if(OP_UNLIKELY(ret<0))return OP_EREAD;
  209|     92|      if(OP_UNLIKELY(ret==0)){
  210|       |        /*Only fail cleanly on EOF if we didn't have a known boundary.
  211|       |          Otherwise, we should have been able to reach that boundary, and this
  212|       |           is a fatal error.*/
  213|      1|        return OP_UNLIKELY(_boundary<0)?OP_FALSE:OP_EBADLINK;
  214|      1|      }
  215|     92|    }
  216|     21|    else{
  217|       |      /*Got a page.
  218|       |        Return the page start offset and advance the internal offset past the
  219|       |         page end.*/
  220|     21|      opus_int64 page_offset;
  221|     21|      page_offset=_of->offset;
  222|     21|      _of->offset+=more;
  223|     21|      OP_ASSERT(page_offset>=0);
  224|     21|      return page_offset;
  225|     21|    }
  226|    187|  }
  227|      0|  return OP_FALSE;
  228|     24|}
  229|       |
  230|       |static int op_add_serialno(const ogg_page *_og,
  231|      3| ogg_uint32_t **_serialnos,int *_nserialnos,int *_cserialnos){
  232|      3|  ogg_uint32_t *serialnos;
  233|      3|  int           nserialnos;
  234|      3|  int           cserialnos;
  235|      3|  ogg_uint32_t s;
  236|      3|  s=ogg_page_serialno(_og);
  237|      3|  serialnos=*_serialnos;
  238|      3|  nserialnos=*_nserialnos;
  239|      3|  cserialnos=*_cserialnos;
  240|      3|  if(OP_UNLIKELY(nserialnos>=cserialnos)){
  241|      3|    if(OP_UNLIKELY(cserialnos>INT_MAX/(int)sizeof(*serialnos)-1>>1)){
  242|      0|      return OP_EFAULT;
  243|      0|    }
  244|      3|    cserialnos=2*cserialnos+1;
  245|      3|    OP_ASSERT(nserialnos<cserialnos);
  246|      3|    serialnos=(ogg_uint32_t *)_ogg_realloc(serialnos,
  247|      3|     sizeof(*serialnos)*cserialnos);
  248|      3|    if(OP_UNLIKELY(serialnos==NULL))return OP_EFAULT;
  249|      3|  }
  250|      3|  serialnos[nserialnos++]=s;
  251|      3|  *_serialnos=serialnos;
  252|      3|  *_nserialnos=nserialnos;
  253|      3|  *_cserialnos=cserialnos;
  254|      3|  return 0;
  255|      3|}
  256|       |
  257|       |/*Returns nonzero if found.*/
  258|       |static int op_lookup_serialno(ogg_uint32_t _s,
  259|     18| const ogg_uint32_t *_serialnos,int _nserialnos){
  260|     18|  int i;
  261|     18|  for(i=0;i<_nserialnos&&_serialnos[i]!=_s;i++);
  262|     18|  return i<_nserialnos;
  263|     18|}
  264|       |
  265|       |static int op_lookup_page_serialno(const ogg_page *_og,
  266|      3| const ogg_uint32_t *_serialnos,int _nserialnos){
  267|      3|  return op_lookup_serialno(ogg_page_serialno(_og),_serialnos,_nserialnos);
  268|      3|}
  269|       |
  270|       |typedef struct OpusSeekRecord OpusSeekRecord;
  271|       |
  272|       |/*We use this to remember the pages we found while enumerating the links of a
  273|       |   chained stream.
  274|       |  We keep track of the starting and ending offsets, as well as the point we
  275|       |   started searching from, so we know where to bisect.
  276|       |  We also keep the serial number, so we can tell if the page belonged to the
  277|       |   current link or not, as well as the granule position, to aid in estimating
  278|       |   the start of the link.*/
  279|       |struct OpusSeekRecord{
  280|       |  /*The earliest byte we know of such that reading forward from it causes
  281|       |     capture to be regained at this page.*/
  282|       |  opus_int64   search_start;
  283|       |  /*The offset of this page.*/
  284|       |  opus_int64   offset;
  285|       |  /*The size of this page.*/
  286|       |  opus_int32   size;
  287|       |  /*The serial number of this page.*/
  288|       |  ogg_uint32_t serialno;
  289|       |  /*The granule position of this page.*/
  290|       |  ogg_int64_t  gp;
  291|       |};
  292|       |
  293|       |/*Find the last page beginning before _offset with a valid granule position.
  294|       |  There is no '_boundary' parameter as it will always have to read more data.
  295|       |  This is much dirtier than the above, as Ogg doesn't have any backward search
  296|       |   linkage.
  297|       |  This search prefers pages of the specified serial number.
  298|       |  If a page of the specified serial number is spotted during the
  299|       |   seek-back-and-read-forward, it will return the info of last page of the
  300|       |   matching serial number, instead of the very last page, unless the very last
  301|       |   page belongs to a different link than preferred serial number.
  302|       |  If no page of the specified serial number is seen, it will return the info of
  303|       |   the last page.
  304|       |  [out] _sr:   Returns information about the page that was found on success.
  305|       |  _offset:     The _offset before which to find a page.
  306|       |               Any page returned will consist of data entirely before _offset.
  307|       |  _serialno:   The preferred serial number.
  308|       |               If a page with this serial number is found, it will be returned
  309|       |                even if another page in the same link is found closer to
  310|       |                _offset.
  311|       |               This is purely opportunistic: there is no guarantee such a page
  312|       |                will be found if it exists.
  313|       |  _serialnos:  The list of serial numbers in the link that contains the
  314|       |                preferred serial number.
  315|       |  _nserialnos: The number of serial numbers in the current link.
  316|       |  Return: 0 on success, or a negative value on failure.
  317|       |          OP_EREAD:    Failed to read more data (error or EOF).
  318|       |          OP_EBADLINK: We couldn't find a page even after seeking back to the
  319|       |                        start of the stream.*/
  320|       |static int op_get_prev_page_serial(OggOpusFile *_of,OpusSeekRecord *_sr,
  321|       | opus_int64 _offset,ogg_uint32_t _serialno,
  322|      3| const ogg_uint32_t *_serialnos,int _nserialnos){
  323|      3|  OpusSeekRecord preferred_sr;
  324|      3|  ogg_page       og;
  325|      3|  opus_int64     begin;
  326|      3|  opus_int64     end;
  327|      3|  opus_int64     original_end;
  328|      3|  opus_int32     chunk_size;
  329|      3|  int            preferred_found;
  330|      3|  original_end=end=begin=_offset;
  331|      3|  preferred_found=0;
  332|      3|  _offset=-1;
  333|      3|  chunk_size=OP_CHUNK_SIZE;
  334|      3|  do{
  335|      3|    opus_int64 search_start;
  336|      3|    int        ret;
  337|      3|    OP_ASSERT(chunk_size>=OP_PAGE_SIZE_MAX);
  338|      3|    begin=OP_MAX(begin-chunk_size,0);
  339|      3|    ret=op_seek_helper(_of,begin);
  340|      3|    if(OP_UNLIKELY(ret<0))return ret;
  341|      3|    search_start=begin;
  342|     15|    while(_of->offset<end){
  343|     14|      opus_int64   llret;
  344|     14|      ogg_uint32_t serialno;
  345|     14|      llret=op_get_next_page(_of,&og,end);
  346|     14|      if(OP_UNLIKELY(llret<OP_FALSE))return (int)llret;
  347|     14|      else if(llret==OP_FALSE)break;
  348|     12|      serialno=ogg_page_serialno(&og);
  349|       |      /*Save the information for this page.
  350|       |        We're not interested in the page itself... just the serial number, byte
  351|       |         offset, page size, and granule position.*/
  352|     12|      _sr->search_start=search_start;
  353|     12|      _sr->offset=_offset=llret;
  354|     12|      _sr->serialno=serialno;
  355|     12|      OP_ASSERT(_of->offset-_offset>=0);
  356|     12|      OP_ASSERT(_of->offset-_offset<=OP_PAGE_SIZE_MAX);
  357|     12|      _sr->size=(opus_int32)(_of->offset-_offset);
  358|     12|      _sr->gp=ogg_page_granulepos(&og);
  359|       |      /*If this page is from the stream we're looking for, remember it.*/
  360|     12|      if(serialno==_serialno){
  361|     12|        preferred_found=1;
  362|     12|        *&preferred_sr=*_sr;
  363|     12|      }
  364|     12|      if(!op_lookup_serialno(serialno,_serialnos,_nserialnos)){
  365|       |        /*We fell off the end of the link, which means we seeked back too far
  366|       |           and shouldn't have been looking in that link to begin with.
  367|       |          If we found the preferred serial number, forget that we saw it.*/
  368|      0|        preferred_found=0;
  369|      0|      }
  370|     12|      search_start=llret+1;
  371|     12|    }
  372|       |    /*We started from the beginning of the stream and found nothing.
  373|       |      This should be impossible unless the contents of the stream changed out
  374|       |       from under us after we read from it.*/
  375|      3|    if(OP_UNLIKELY(!begin)&&OP_UNLIKELY(_offset<0))return OP_EBADLINK;
  376|       |    /*Bump up the chunk size.
  377|       |      This is mildly helpful when seeks are very expensive (http).*/
  378|      3|    chunk_size=OP_MIN(2*chunk_size,OP_CHUNK_SIZE_MAX);
  379|       |    /*Avoid quadratic complexity if we hit an invalid patch of the file.*/
  380|      3|    end=OP_MIN(begin+OP_PAGE_SIZE_MAX-1,original_end);
  381|      3|  }
  382|      3|  while(_offset<0);
  383|      3|  if(preferred_found)*_sr=*&preferred_sr;
  384|      3|  return 0;
  385|      3|}
  386|       |
  387|       |/*Find the last page beginning before _offset with the given serial number and
  388|       |   a valid granule position.
  389|       |  Unlike the above search, this continues until it finds such a page, but does
  390|       |   not stray outside the current link.
  391|       |  We could implement it (inefficiently) by calling op_get_prev_page_serial()
  392|       |   repeatedly until it returned a page that had both our preferred serial
  393|       |   number and a valid granule position, but doing it with a separate function
  394|       |   allows us to avoid repeatedly re-scanning valid pages from other streams as
  395|       |   we seek-back-and-read-forward.
  396|       |  [out] _gp:   Returns the granule position of the page that was found on
  397|       |                success.
  398|       |  _offset:     The _offset before which to find a page.
  399|       |               Any page returned will consist of data entirely before _offset.
  400|       |  _serialno:   The target serial number.
  401|       |  _serialnos:  The list of serial numbers in the link that contains the
  402|       |                preferred serial number.
  403|       |  _nserialnos: The number of serial numbers in the current link.
  404|       |  Return: The offset of the page on success, or a negative value on failure.
  405|       |          OP_EREAD:    Failed to read more data (error or EOF).
  406|       |          OP_EBADLINK: We couldn't find a page even after seeking back past the
  407|       |                        beginning of the link.*/
  408|       |static opus_int64 op_get_last_page(OggOpusFile *_of,ogg_int64_t *_gp,
  409|       | opus_int64 _offset,ogg_uint32_t _serialno,
  410|      0| const ogg_uint32_t *_serialnos,int _nserialnos){
  411|      0|  ogg_page    og;
  412|      0|  ogg_int64_t gp;
  413|      0|  opus_int64  begin;
  414|      0|  opus_int64  end;
  415|      0|  opus_int64  original_end;
  416|      0|  opus_int32  chunk_size;
  417|       |  /*The target serial number must belong to the current link.*/
  418|      0|  OP_ASSERT(op_lookup_serialno(_serialno,_serialnos,_nserialnos));
  419|      0|  original_end=end=begin=_offset;
  420|      0|  _offset=-1;
  421|       |  /*We shouldn't have to initialize gp, but gcc is too dumb to figure out that
  422|       |     ret>=0 implies we entered the if(page_gp!=-1) block at least once.*/
  423|      0|  gp=-1;
  424|      0|  chunk_size=OP_CHUNK_SIZE;
  425|      0|  do{
  426|      0|    int left_link;
  427|      0|    int ret;
  428|      0|    OP_ASSERT(chunk_size>=OP_PAGE_SIZE_MAX);
  429|      0|    begin=OP_MAX(begin-chunk_size,0);
  430|      0|    ret=op_seek_helper(_of,begin);
  431|      0|    if(OP_UNLIKELY(ret<0))return ret;
  432|      0|    left_link=0;
  433|      0|    while(_of->offset<end){
  434|      0|      opus_int64   llret;
  435|      0|      ogg_uint32_t serialno;
  436|      0|      llret=op_get_next_page(_of,&og,end);
  437|      0|      if(OP_UNLIKELY(llret<OP_FALSE))return llret;
  438|      0|      else if(llret==OP_FALSE)break;
  439|      0|      serialno=ogg_page_serialno(&og);
  440|      0|      if(serialno==_serialno){
  441|      0|        ogg_int64_t page_gp;
  442|       |        /*The page is from the right stream...*/
  443|      0|        page_gp=ogg_page_granulepos(&og);
  444|      0|        if(page_gp!=-1){
  445|       |          /*And has a valid granule position.
  446|       |            Let's remember it.*/
  447|      0|          _offset=llret;
  448|      0|          gp=page_gp;
  449|      0|        }
  450|      0|      }
  451|      0|      else if(OP_UNLIKELY(!op_lookup_serialno(serialno,
  452|      0|       _serialnos,_nserialnos))){
  453|       |        /*We fell off the start of the link, which means we don't need to keep
  454|       |           seeking any farther back.*/
  455|      0|        left_link=1;
  456|      0|      }
  457|      0|    }
  458|       |    /*We started from at or before the beginning of the link and found nothing.
  459|       |      This should be impossible unless the contents of the stream changed out
  460|       |       from under us after we read from it.*/
  461|      0|    if((OP_UNLIKELY(left_link)||OP_UNLIKELY(!begin))&&OP_UNLIKELY(_offset<0)){
  462|      0|      return OP_EBADLINK;
  463|      0|    }
  464|       |    /*Bump up the chunk size.
  465|       |      This is mildly helpful when seeks are very expensive (http).*/
  466|      0|    chunk_size=OP_MIN(2*chunk_size,OP_CHUNK_SIZE_MAX);
  467|       |    /*Avoid quadratic complexity if we hit an invalid patch of the file.*/
  468|      0|    end=OP_MIN(begin+OP_PAGE_SIZE_MAX-1,original_end);
  469|      0|  }
  470|      0|  while(_offset<0);
  471|      0|  *_gp=gp;
  472|      0|  return _offset;
  473|      0|}
  474|       |
  475|       |/*Uses the local ogg_stream storage in _of.
  476|       |  This is important for non-streaming input sources.*/
  477|       |static int op_fetch_headers_impl(OggOpusFile *_of,OpusHead *_head,
  478|       | OpusTags *_tags,ogg_uint32_t **_serialnos,int *_nserialnos,
  479|      3| int *_cserialnos,ogg_page *_og){
  480|      3|  ogg_packet op;
  481|      3|  int        ret;
  482|      3|  if(_serialnos!=NULL)*_nserialnos=0;
  483|       |  /*Extract the serialnos of all BOS pages plus the first set of Opus headers
  484|       |     we see in the link.*/
  485|      6|  while(ogg_page_bos(_og)){
  486|      3|    if(_serialnos!=NULL){
  487|      3|      if(OP_UNLIKELY(op_lookup_page_serialno(_og,*_serialnos,*_nserialnos))){
  488|       |        /*A dupe serialnumber in an initial header packet set==invalid stream.*/
  489|      0|        return OP_EBADHEADER;
  490|      0|      }
  491|      3|      ret=op_add_serialno(_og,_serialnos,_nserialnos,_cserialnos);
  492|      3|      if(OP_UNLIKELY(ret<0))return ret;
  493|      3|    }
  494|      3|    if(_of->ready_state<OP_STREAMSET){
  495|       |      /*We don't have an Opus stream in this link yet, so begin prospective
  496|       |         stream setup.
  497|       |        We need a stream to get packets.*/
  498|      3|      ogg_stream_reset_serialno(&_of->os,ogg_page_serialno(_og));
  499|      3|      ogg_stream_pagein(&_of->os,_og);
  500|      3|      if(OP_LIKELY(ogg_stream_packetout(&_of->os,&op)>0)){
  501|      3|        ret=opus_head_parse(_head,op.packet,op.bytes);
  502|       |        /*Found a valid Opus header.
  503|       |          Continue setup.*/
  504|      3|        if(OP_LIKELY(ret>=0))_of->ready_state=OP_STREAMSET;
  505|       |        /*If it's just a stream type we don't recognize, ignore it.
  506|       |          Everything else is fatal.*/
  507|      0|        else if(ret!=OP_ENOTFORMAT)return ret;
  508|      3|      }
  509|       |      /*TODO: Should a BOS page with no packets be an error?*/
  510|      3|    }
  511|       |    /*Get the next page.
  512|       |      No need to clamp the boundary offset against _of->end, as all errors
  513|       |       become OP_ENOTFORMAT or OP_EBADHEADER.*/
  514|      3|    if(OP_UNLIKELY(op_get_next_page(_of,_og,
  515|      3|     OP_ADV_OFFSET(_of->offset,OP_CHUNK_SIZE))<0)){
  516|      0|      return _of->ready_state<OP_STREAMSET?OP_ENOTFORMAT:OP_EBADHEADER;
  517|      0|    }
  518|      3|  }
  519|      3|  if(OP_UNLIKELY(_of->ready_state!=OP_STREAMSET))return OP_ENOTFORMAT;
  520|       |  /*If the first non-header page belonged to our Opus stream, submit it.*/
  521|      3|  if(_of->os.serialno==ogg_page_serialno(_og))ogg_stream_pagein(&_of->os,_og);
  522|       |  /*Loop getting packets.*/
  523|      3|  for(;;){
  524|      3|    switch(ogg_stream_packetout(&_of->os,&op)){
  525|      0|      case 0:{
  526|       |        /*Loop getting pages.*/
  527|      0|        for(;;){
  528|       |          /*No need to clamp the boundary offset against _of->end, as all
  529|       |             errors become OP_EBADHEADER.*/
  530|      0|          if(OP_UNLIKELY(op_get_next_page(_of,_og,
  531|      0|           OP_ADV_OFFSET(_of->offset,OP_CHUNK_SIZE))<0)){
  532|      0|            return OP_EBADHEADER;
  533|      0|          }
  534|       |          /*If this page belongs to the correct stream, go parse it.*/
  535|      0|          if(_of->os.serialno==ogg_page_serialno(_og)){
  536|      0|            ogg_stream_pagein(&_of->os,_og);
  537|      0|            break;
  538|      0|          }
  539|       |          /*If the link ends before we see the Opus comment header, abort.*/
  540|      0|          if(OP_UNLIKELY(ogg_page_bos(_og)))return OP_EBADHEADER;
  541|       |          /*Otherwise, keep looking.*/
  542|      0|        }
  543|      0|      }break;
  544|       |      /*We shouldn't get a hole in the headers!*/
  545|      0|      case -1:return OP_EBADHEADER;
  546|      3|      default:{
  547|       |        /*Got a packet.
  548|       |          It should be the comment header.*/
  549|      3|        ret=opus_tags_parse(_tags,op.packet,op.bytes);
  550|      3|        if(OP_UNLIKELY(ret<0))return ret;
  551|       |        /*Make sure the page terminated at the end of the comment header.
  552|       |          If there is another packet on the page, or part of a packet, then
  553|       |           reject the stream.
  554|       |          Otherwise seekable sources won't be able to seek back to the start
  555|       |           properly.*/
  556|      3|        ret=ogg_stream_packetout(&_of->os,&op);
  557|      3|        if(OP_UNLIKELY(ret!=0)
  558|      3|         ||OP_UNLIKELY(_og->header[_og->header_len-1]==255)){
  559|       |          /*If we fail, the caller assumes our tags are uninitialized.*/
  560|      0|          opus_tags_clear(_tags);
  561|      0|          return OP_EBADHEADER;
  562|      0|        }
  563|      3|        return 0;
  564|      3|      }
  565|      3|    }
  566|      3|  }
  567|      3|}
  568|       |
  569|       |static int op_fetch_headers(OggOpusFile *_of,OpusHead *_head,
  570|       | OpusTags *_tags,ogg_uint32_t **_serialnos,int *_nserialnos,
  571|      4| int *_cserialnos,ogg_page *_og){
  572|      4|  ogg_page og;
  573|      4|  int      ret;
  574|      4|  if(!_og){
  575|       |    /*No need to clamp the boundary offset against _of->end, as all errors
  576|       |       become OP_ENOTFORMAT.*/
  577|      4|    if(OP_UNLIKELY(op_get_next_page(_of,&og,
  578|      4|     OP_ADV_OFFSET(_of->offset,OP_CHUNK_SIZE))<0)){
  579|      1|      return OP_ENOTFORMAT;
  580|      1|    }
  581|      3|    _og=&og;
  582|      3|  }
  583|      3|  _of->ready_state=OP_OPENED;
  584|      3|  ret=op_fetch_headers_impl(_of,_head,_tags,_serialnos,_nserialnos,
  585|      3|   _cserialnos,_og);
  586|       |  /*Revert back from OP_STREAMSET to OP_OPENED on failure, to prevent
  587|       |     double-free of the tags in an unseekable stream.*/
  588|      3|  if(OP_UNLIKELY(ret<0))_of->ready_state=OP_OPENED;
  589|      3|  return ret;
  590|      4|}
  591|       |
  592|       |/*Granule position manipulation routines.
  593|       |  A granule position is defined to be an unsigned 64-bit integer, with the
  594|       |   special value -1 in two's complement indicating an unset or invalid granule
  595|       |   position.
  596|       |  We are not guaranteed to have an unsigned 64-bit type, so we construct the
  597|       |   following routines that
  598|       |   a) Properly order negative numbers as larger than positive numbers, and
  599|       |   b) Check for underflow or overflow past the special -1 value.
  600|       |  This lets us operate on the full, valid range of granule positions in a
  601|       |   consistent and safe manner.
  602|       |  This full range is organized into distinct regions:
  603|       |   [ -1 (invalid) ][ 0 ... OP_INT64_MAX ][ OP_INT64_MIN ... -2 ][-1 (invalid) ]
  604|       |
  605|       |  No one should actually use granule positions so large that they're negative,
  606|       |   even if they are technically valid, as very little software handles them
  607|       |   correctly (including most of Xiph.Org's).
  608|       |  This library also refuses to support durations so large they won't fit in a
  609|       |   signed 64-bit integer (to avoid exposing this mess to the application, and
  610|       |   to simplify a good deal of internal arithmetic), so the only way to use them
  611|       |   successfully is if pcm_start is very large.
  612|       |  This means there isn't anything you can do with negative granule positions
  613|       |   that you couldn't have done with purely non-negative ones.
  614|       |  The main purpose of these routines is to allow us to think very explicitly
  615|       |   about the possible failure cases of all granule position manipulations.*/
  616|       |
  617|       |/*Safely adds a small signed integer to a valid (not -1) granule position.
  618|       |  The result can use the full 64-bit range of values (both positive and
  619|       |   negative), but will fail on overflow (wrapping past -1; wrapping past
  620|       |   OP_INT64_MAX is explicitly okay).
  621|       |  [out] _dst_gp: The resulting granule position.
  622|       |                 Only modified on success.
  623|       |  _src_gp:       The granule position to add to.
  624|       |                 This must not be -1.
  625|       |  _delta:        The amount to add.
  626|       |                 This is allowed to be up to 32 bits to support the maximum
  627|       |                  duration of a single Ogg page (255 packets * 120 ms per
  628|       |                  packet == 1,468,800 samples at 48 kHz).
  629|       |  Return: 0 on success, or OP_EINVAL if the result would wrap around past -1.*/
  630|       |static int op_granpos_add(ogg_int64_t *_dst_gp,ogg_int64_t _src_gp,
  631|    153| opus_int32 _delta){
  632|       |  /*The code below handles this case correctly, but there's no reason we
  633|       |     should ever be called with these values, so make sure we aren't.*/
  634|    153|  OP_ASSERT(_src_gp!=-1);
  635|    153|  if(_delta>0){
  636|       |    /*Adding this amount to the granule position would overflow its 64-bit
  637|       |       range.*/
  638|    150|    if(OP_UNLIKELY(_src_gp<0)&&OP_UNLIKELY(_src_gp>=-1-_delta))return OP_EINVAL;
  639|    150|    if(OP_UNLIKELY(_src_gp>OP_INT64_MAX-_delta)){
  640|       |      /*Adding this amount to the granule position would overflow the positive
  641|       |         half of its 64-bit range.
  642|       |        Since signed overflow is undefined in C, do it in a way the compiler
  643|       |         isn't allowed to screw up.*/
  644|      0|      _delta-=(opus_int32)(OP_INT64_MAX-_src_gp)+1;
  645|      0|      _src_gp=OP_INT64_MIN;
  646|      0|    }
  647|    150|  }
  648|      3|  else if(_delta<0){
  649|       |    /*Subtracting this amount from the granule position would underflow its
  650|       |       64-bit range.*/
  651|      3|    if(_src_gp>=0&&OP_UNLIKELY(_src_gp<-_delta))return OP_EINVAL;
  652|      3|    if(OP_UNLIKELY(_src_gp<OP_INT64_MIN-_delta)){
  653|       |      /*Subtracting this amount from the granule position would underflow the
  654|       |         negative half of its 64-bit range.
  655|       |        Since signed underflow is undefined in C, do it in a way the compiler
  656|       |         isn't allowed to screw up.*/
  657|      0|      _delta+=(opus_int32)(_src_gp-OP_INT64_MIN)+1;
  658|      0|      _src_gp=OP_INT64_MAX;
  659|      0|    }
  660|      3|  }
  661|    153|  *_dst_gp=_src_gp+_delta;
  662|    153|  return 0;
  663|    153|}
  664|       |
  665|       |/*Safely computes the difference between two granule positions.
  666|       |  The difference must fit in a signed 64-bit integer, or the function fails.
  667|       |  It correctly handles the case where the granule position has wrapped around
  668|       |   from positive values to negative ones.
  669|       |  [out] _delta: The difference between the granule positions.
  670|       |                Only modified on success.
  671|       |  _gp_a:        The granule position to subtract from.
  672|       |                This must not be -1.
  673|       |  _gp_b:        The granule position to subtract.
  674|       |                This must not be -1.
  675|       |  Return: 0 on success, or OP_EINVAL if the result would not fit in a signed
  676|       |           64-bit integer.*/
  677|       |static int op_granpos_diff(ogg_int64_t *_delta,
  678|      4| ogg_int64_t _gp_a,ogg_int64_t _gp_b){
  679|      4|  int gp_a_negative;
  680|      4|  int gp_b_negative;
  681|       |  /*The code below handles these cases correctly, but there's no reason we
  682|       |     should ever be called with these values, so make sure we aren't.*/
  683|      4|  OP_ASSERT(_gp_a!=-1);
  684|      4|  OP_ASSERT(_gp_b!=-1);
  685|      4|  gp_a_negative=OP_UNLIKELY(_gp_a<0);
  686|      4|  gp_b_negative=OP_UNLIKELY(_gp_b<0);
  687|      4|  if(OP_UNLIKELY(gp_a_negative^gp_b_negative)){
  688|      0|    ogg_int64_t da;
  689|      0|    ogg_int64_t db;
  690|      0|    if(gp_a_negative){
  691|       |      /*_gp_a has wrapped to a negative value but _gp_b hasn't: the difference
  692|       |         should be positive.*/
  693|       |      /*Step 1: Handle wrapping.*/
  694|       |      /*_gp_a < 0 => da < 0.*/
  695|      0|      da=(OP_INT64_MIN-_gp_a)-1;
  696|       |      /*_gp_b >= 0  => db >= 0.*/
  697|      0|      db=OP_INT64_MAX-_gp_b;
  698|       |      /*Step 2: Check for overflow.*/
  699|      0|      if(OP_UNLIKELY(OP_INT64_MAX+da<db))return OP_EINVAL;
  700|      0|      *_delta=db-da;
  701|      0|    }
  702|      0|    else{
  703|       |      /*_gp_b has wrapped to a negative value but _gp_a hasn't: the difference
  704|       |         should be negative.*/
  705|       |      /*Step 1: Handle wrapping.*/
  706|       |      /*_gp_a >= 0 => da <= 0*/
  707|      0|      da=_gp_a+OP_INT64_MIN;
  708|       |      /*_gp_b < 0 => db <= 0*/
  709|      0|      db=OP_INT64_MIN-_gp_b;
  710|       |      /*Step 2: Check for overflow.*/
  711|      0|      if(OP_UNLIKELY(da<OP_INT64_MIN-db))return OP_EINVAL;
  712|      0|      *_delta=da+db;
  713|      0|    }
  714|      0|  }
  715|      4|  else *_delta=_gp_a-_gp_b;
  716|      4|  return 0;
  717|      4|}
  718|       |
  719|      0|static int op_granpos_cmp(ogg_int64_t _gp_a,ogg_int64_t _gp_b){
  720|       |  /*The invalid granule position -1 should behave like NaN: neither greater
  721|       |     than nor less than any other granule position, nor equal to any other
  722|       |     granule position, including itself.
  723|       |    However, that means there isn't anything we could sensibly return from this
  724|       |     function for it.*/
  725|      0|  OP_ASSERT(_gp_a!=-1);
  726|      0|  OP_ASSERT(_gp_b!=-1);
  727|       |  /*Handle the wrapping cases.*/
  728|      0|  if(OP_UNLIKELY(_gp_a<0)){
  729|      0|    if(_gp_b>=0)return 1;
  730|       |    /*Else fall through.*/
  731|      0|  }
  732|      0|  else if(OP_UNLIKELY(_gp_b<0))return -1;
  733|       |  /*No wrapping case.*/
  734|      0|  return (_gp_a>_gp_b)-(_gp_b>_gp_a);
  735|      0|}
  736|       |
  737|       |/*Returns the duration of the packet (in samples at 48 kHz), or a negative
  738|       |   value on error.*/
  739|    150|static int op_get_packet_duration(const unsigned char *_data,int _len){
  740|    150|  int nframes;
  741|    150|  int frame_size;
  742|    150|  int nsamples;
  743|    150|  nframes=opus_packet_get_nb_frames(_data,_len);
  744|    150|  if(OP_UNLIKELY(nframes<0))return OP_EBADPACKET;
  745|    150|  frame_size=opus_packet_get_samples_per_frame(_data,48000);
  746|    150|  nsamples=nframes*frame_size;
  747|    150|  if(OP_UNLIKELY(nsamples>120*48))return OP_EBADPACKET;
  748|    150|  return nsamples;
  749|    150|}
  750|       |
  751|       |/*This function more properly belongs in info.c, but we define it here to allow
  752|       |   the static granule position manipulation functions to remain static.*/
  753|      0|ogg_int64_t opus_granule_sample(const OpusHead *_head,ogg_int64_t _gp){
  754|      0|  opus_int32 pre_skip;
  755|      0|  pre_skip=_head->pre_skip;
  756|      0|  if(_gp!=-1&&op_granpos_add(&_gp,_gp,-pre_skip))_gp=-1;
  757|      0|  return _gp;
  758|      0|}
  759|       |
  760|       |/*Grab all the packets currently in the stream state, and compute their
  761|       |   durations.
  762|       |  _of->op_count is set to the number of packets collected.
  763|       |  [out] _durations: Returns the durations of the individual packets.
  764|       |  Return: The total duration of all packets, or OP_HOLE if there was a hole.*/
  765|       |static opus_int32 op_collect_audio_packets(OggOpusFile *_of,
  766|      3| int _durations[255]){
  767|      3|  opus_int32 total_duration;
  768|      3|  int        op_count;
  769|       |  /*Count the durations of all packets in the page.*/
  770|      3|  op_count=0;
  771|      3|  total_duration=0;
  772|    153|  for(;;){
  773|    153|    int ret;
  774|       |    /*This takes advantage of undocumented libogg behavior that returned
  775|       |       ogg_packet buffers are valid at least until the next page is
  776|       |       submitted.
  777|       |      Relying on this is not too terrible, as _none_ of the Ogg memory
  778|       |       ownership/lifetime rules are well-documented.
  779|       |      But I can read its code and know this will work.*/
  780|    153|    ret=ogg_stream_packetout(&_of->os,_of->op+op_count);
  781|    153|    if(!ret)break;
  782|    150|    if(OP_UNLIKELY(ret<0)){
  783|       |      /*We shouldn't get holes in the middle of pages.*/
  784|      0|      OP_ASSERT(op_count==0);
  785|       |      /*Set the return value and break out of the loop.
  786|       |        We want to make sure op_count gets set to 0, because we've ingested a
  787|       |         page, so any previously loaded packets are now invalid.*/
  788|      0|      total_duration=OP_HOLE;
  789|      0|      break;
  790|      0|    }
  791|       |    /*Unless libogg is broken, we can't get more than 255 packets from a
  792|       |       single page.*/
  793|    150|    OP_ASSERT(op_count<255);
  794|    150|    _durations[op_count]=op_get_packet_duration(_of->op[op_count].packet,
  795|    150|     _of->op[op_count].bytes);
  796|    150|    if(OP_LIKELY(_durations[op_count]>0)){
  797|       |      /*With at most 255 packets on a page, this can't overflow.*/
  798|    150|      total_duration+=_durations[op_count++];
  799|    150|    }
  800|       |    /*Ignore packets with an invalid TOC sequence.*/
  801|      0|    else if(op_count>0){
  802|       |      /*But save the granule position, if there was one.*/
  803|      0|      _of->op[op_count-1].granulepos=_of->op[op_count].granulepos;
  804|      0|    }
  805|    150|  }
  806|      3|  _of->op_pos=0;
  807|      3|  _of->op_count=op_count;
  808|      3|  return total_duration;
  809|      3|}
  810|       |
  811|       |/*Starting from current cursor position, get the initial PCM offset of the next
  812|       |   page.
  813|       |  This also validates the granule position on the first page with a completed
  814|       |   audio data packet, as required by the spec.
  815|       |  If this link is completely empty (no pages with completed packets), then this
  816|       |   function sets pcm_start=pcm_end=0 and returns the BOS page of the next link
  817|       |   (if any).
  818|       |  In the seekable case, we initialize pcm_end=-1 before calling this function,
  819|       |   so that later we can detect that the link was empty before calling
  820|       |   op_find_final_pcm_offset().
  821|       |  [inout] _link: The link for which to find pcm_start.
  822|       |  [out] _og:     Returns the BOS page of the next link if this link was empty.
  823|       |                 In the unseekable case, we can then feed this to
  824|       |                  op_fetch_headers() to start the next link.
  825|       |                 The caller may pass NULL (e.g., for seekable streams), in
  826|       |                  which case this page will be discarded.
  827|       |  Return: 0 on success, 1 if there is a buffered BOS page available, or a
  828|       |           negative value on unrecoverable error.*/
  829|       |static int op_find_initial_pcm_offset(OggOpusFile *_of,
  830|      3| OggOpusLink *_link,ogg_page *_og){
  831|      3|  ogg_page     og;
  832|      3|  opus_int64   page_offset;
  833|      3|  ogg_int64_t  pcm_start;
  834|      3|  ogg_int64_t  prev_packet_gp;
  835|      3|  ogg_int64_t  cur_page_gp;
  836|      3|  ogg_uint32_t serialno;
  837|      3|  opus_int32   total_duration;
  838|      3|  int          durations[255];
  839|      3|  int          cur_page_eos;
  840|      3|  int          op_count;
  841|      3|  int          pi;
  842|      3|  if(_og==NULL)_og=&og;
  843|      3|  serialno=_of->os.serialno;
  844|      3|  op_count=0;
  845|       |  /*We shouldn't have to initialize total_duration, but gcc is too dumb to
  846|       |     figure out that op_count>0 implies we've been through the whole loop at
  847|       |     least once.*/
  848|      3|  total_duration=0;
  849|      3|  do{
  850|      3|    page_offset=op_get_next_page(_of,_og,_of->end);
  851|       |    /*We should get a page unless the file is truncated or mangled.
  852|       |      Otherwise there are no audio data packets in the whole logical stream.*/
  853|      3|    if(OP_UNLIKELY(page_offset<0)){
  854|       |      /*Fail if there was a read error.*/
  855|      0|      if(page_offset<OP_FALSE)return (int)page_offset;
  856|       |      /*Fail if the pre-skip is non-zero, since it's asking us to skip more
  857|       |         samples than exist.*/
  858|      0|      if(_link->head.pre_skip>0)return OP_EBADTIMESTAMP;
  859|      0|      _link->pcm_file_offset=0;
  860|       |      /*Set pcm_end and end_offset so we can skip the call to
  861|       |         op_find_final_pcm_offset().*/
  862|      0|      _link->pcm_start=_link->pcm_end=0;
  863|      0|      _link->end_offset=_link->data_offset;
  864|      0|      return 0;
  865|      0|    }
  866|       |    /*Similarly, if we hit the next link in the chain, we've gone too far.*/
  867|      3|    if(OP_UNLIKELY(ogg_page_bos(_og))){
  868|      0|      if(_link->head.pre_skip>0)return OP_EBADTIMESTAMP;
  869|       |      /*Set pcm_end and end_offset so we can skip the call to
  870|       |         op_find_final_pcm_offset().*/
  871|      0|      _link->pcm_file_offset=0;
  872|      0|      _link->pcm_start=_link->pcm_end=0;
  873|      0|      _link->end_offset=_link->data_offset;
  874|       |      /*Tell the caller we've got a buffered page for them.*/
  875|      0|      return 1;
  876|      0|    }
  877|       |    /*Ignore pages from other streams (not strictly necessary, because of the
  878|       |       checks in ogg_stream_pagein(), but saves some work).*/
  879|      3|    if(serialno!=(ogg_uint32_t)ogg_page_serialno(_og))continue;
  880|      3|    ogg_stream_pagein(&_of->os,_og);
  881|       |    /*Bitrate tracking: add the header's bytes here.
  882|       |      The body bytes are counted when we consume the packets.*/
  883|      3|    _of->bytes_tracked+=_og->header_len;
  884|       |    /*Count the durations of all packets in the page.*/
  885|      3|    do total_duration=op_collect_audio_packets(_of,durations);
  886|       |    /*Ignore holes.*/
  887|      3|    while(OP_UNLIKELY(total_duration<0));
  888|      3|    op_count=_of->op_count;
  889|      3|  }
  890|      3|  while(op_count<=0);
  891|       |  /*We found the first page with a completed audio data packet: actually look
  892|       |     at the granule position.
  893|       |    RFC 3533 says, "A special value of -1 (in two's complement) indicates that
  894|       |     no packets finish on this page," which does not say that a granule
  895|       |     position that is NOT -1 indicates that some packets DO finish on that page
  896|       |     (even though this was the intention, libogg itself violated this intention
  897|       |     for years before we fixed it).
  898|       |    The Ogg Opus specification only imposes its start-time requirements
  899|       |     on the granule position of the first page with completed packets,
  900|       |     so we ignore any set granule positions until then.*/
  901|      3|  cur_page_gp=_of->op[op_count-1].granulepos;
  902|       |  /*But getting a packet without a valid granule position on the page is not
  903|       |     okay.*/
  904|      3|  if(cur_page_gp==-1)return OP_EBADTIMESTAMP;
  905|      3|  cur_page_eos=_of->op[op_count-1].e_o_s;
  906|      3|  if(OP_LIKELY(!cur_page_eos)){
  907|       |    /*The EOS flag wasn't set.
  908|       |      Work backwards from the provided granule position to get the starting PCM
  909|       |       offset.*/
  910|      3|    if(OP_UNLIKELY(op_granpos_add(&pcm_start,cur_page_gp,-total_duration)<0)){
  911|       |      /*The starting granule position MUST not be smaller than the amount of
  912|       |         audio on the first page with completed packets.*/
  913|      0|      return OP_EBADTIMESTAMP;
  914|      0|    }
  915|      3|  }
  916|      0|  else{
  917|       |    /*The first page with completed packets was also the last.*/
  918|      0|    if(OP_LIKELY(op_granpos_add(&pcm_start,cur_page_gp,-total_duration)<0)){
  919|       |      /*If there's less audio on the page than indicated by the granule
  920|       |         position, then we're doing end-trimming, and the starting PCM offset
  921|       |         is zero by spec mandate.*/
  922|      0|      pcm_start=0;
  923|       |      /*However, the end-trimming MUST not ask us to trim more samples than
  924|       |         exist after applying the pre-skip.*/
  925|      0|      if(OP_UNLIKELY(op_granpos_cmp(cur_page_gp,_link->head.pre_skip)<0)){
  926|      0|        return OP_EBADTIMESTAMP;
  927|      0|      }
  928|      0|    }
  929|      0|  }
  930|       |  /*Timestamp the individual packets.*/
  931|      3|  prev_packet_gp=pcm_start;
  932|    153|  for(pi=0;pi<op_count;pi++){
  933|    150|    if(cur_page_eos){
  934|      0|      ogg_int64_t diff;
  935|      0|      OP_ALWAYS_TRUE(!op_granpos_diff(&diff,cur_page_gp,prev_packet_gp));
  936|      0|      diff=durations[pi]-diff;
  937|       |      /*If we have samples to trim...*/
  938|      0|      if(diff>0){
  939|       |        /*If we trimmed the entire packet, stop (the spec says encoders
  940|       |           shouldn't do this, but we support it anyway).*/
  941|      0|        if(OP_UNLIKELY(diff>durations[pi]))break;
  942|      0|        _of->op[pi].granulepos=prev_packet_gp=cur_page_gp;
  943|       |        /*Move the EOS flag to this packet, if necessary, so we'll trim the
  944|       |           samples.*/
  945|      0|        _of->op[pi].e_o_s=1;
  946|      0|        continue;
  947|      0|      }
  948|      0|    }
  949|       |    /*Update the granule position as normal.*/
  950|    150|    OP_ALWAYS_TRUE(!op_granpos_add(&_of->op[pi].granulepos,
  951|    150|     prev_packet_gp,durations[pi]));
  952|    150|    prev_packet_gp=_of->op[pi].granulepos;
  953|    150|  }
  954|       |  /*Update the packet count after end-trimming.*/
  955|      3|  _of->op_count=pi;
  956|      3|  _of->cur_discard_count=_link->head.pre_skip;
  957|      3|  _link->pcm_file_offset=0;
  958|      3|  _of->prev_packet_gp=_link->pcm_start=pcm_start;
  959|      3|  _of->prev_page_offset=page_offset;
  960|      3|  return 0;
  961|      3|}
  962|       |
  963|       |/*Starting from current cursor position, get the final PCM offset of the
  964|       |   previous page.
  965|       |  This also validates the duration of the link, which, while not strictly
  966|       |   required by the spec, we need to ensure duration calculations don't
  967|       |   overflow.
  968|       |  This is only done for seekable sources.
  969|       |  We must validate that op_find_initial_pcm_offset() succeeded for this link
  970|       |   before calling this function, otherwise it will scan the entire stream
  971|       |   backwards until it reaches the start, and then fail.*/
  972|       |static int op_find_final_pcm_offset(OggOpusFile *_of,
  973|       | const ogg_uint32_t *_serialnos,int _nserialnos,OggOpusLink *_link,
  974|       | opus_int64 _offset,ogg_uint32_t _end_serialno,ogg_int64_t _end_gp,
  975|      3| ogg_int64_t *_total_duration){
  976|      3|  ogg_int64_t  total_duration;
  977|      3|  ogg_int64_t  duration;
  978|      3|  ogg_uint32_t cur_serialno;
  979|       |  /*For the time being, fetch end PCM offset the simple way.*/
  980|      3|  cur_serialno=_link->serialno;
  981|      3|  if(_end_serialno!=cur_serialno||_end_gp==-1){
  982|      0|    _offset=op_get_last_page(_of,&_end_gp,_offset,
  983|      0|     cur_serialno,_serialnos,_nserialnos);
  984|      0|    if(OP_UNLIKELY(_offset<0))return (int)_offset;
  985|      0|  }
  986|       |  /*At worst we should have found the first page with completed packets.*/
  987|      3|  if(OP_UNLIKELY(_offset<_link->data_offset))return OP_EBADLINK;
  988|       |  /*This implementation requires that the difference between the first and last
  989|       |     granule positions in each link be representable in a signed, 64-bit
  990|       |     number, and that each link also have at least as many samples as the
  991|       |     pre-skip requires.*/
  992|      3|  if(OP_UNLIKELY(op_granpos_diff(&duration,_end_gp,_link->pcm_start)<0)
  993|      3|   ||OP_UNLIKELY(duration<_link->head.pre_skip)){
  994|      0|    return OP_EBADTIMESTAMP;
  995|      0|  }
  996|       |  /*We also require that the total duration be representable in a signed,
  997|       |     64-bit number.*/
  998|      3|  duration-=_link->head.pre_skip;
  999|      3|  total_duration=*_total_duration;
 1000|      3|  if(OP_UNLIKELY(OP_INT64_MAX-duration<total_duration))return OP_EBADTIMESTAMP;
 1001|      3|  *_total_duration=total_duration+duration;
 1002|      3|  _link->pcm_end=_end_gp;
 1003|      3|  _link->end_offset=_offset;
 1004|      3|  return 0;
 1005|      3|}
 1006|       |
 1007|       |/*Rescale the number _x from the range [0,_from] to [0,_to].
 1008|       |  _from and _to must be positive.*/
 1009|      0|static opus_int64 op_rescale64(opus_int64 _x,opus_int64 _from,opus_int64 _to){
 1010|      0|  opus_int64 frac;
 1011|      0|  opus_int64 ret;
 1012|      0|  int        i;
 1013|      0|  if(_x>=_from)return _to;
 1014|      0|  if(_x<=0)return 0;
 1015|      0|  frac=0;
 1016|      0|  for(i=0;i<63;i++){
 1017|      0|    frac<<=1;
 1018|      0|    OP_ASSERT(_x<=_from);
 1019|      0|    if(_x>=_from>>1){
 1020|      0|      _x-=_from-_x;
 1021|      0|      frac|=1;
 1022|      0|    }
 1023|      0|    else _x<<=1;
 1024|      0|  }
 1025|      0|  ret=0;
 1026|      0|  for(i=0;i<63;i++){
 1027|      0|    if(frac&1)ret=(ret&_to&1)+(ret>>1)+(_to>>1);
 1028|      0|    else ret>>=1;
 1029|      0|    frac>>=1;
 1030|      0|  }
 1031|      0|  return ret;
 1032|      0|}
 1033|       |
 1034|       |/*The minimum granule position spacing allowed for making predictions.
 1035|       |  This corresponds to about 1 second of audio at 48 kHz for both Opus and
 1036|       |   Vorbis, or one keyframe interval in Theora with the default keyframe spacing
 1037|       |   of 256.*/
 1038|       |#define OP_GP_SPACING_MIN (48000)
 1039|       |
 1040|       |/*Try to estimate the location of the next link using the current seek
 1041|       |   records, assuming the initial granule position of any streams we've found is
 1042|       |   0.*/
 1043|       |static opus_int64 op_predict_link_start(const OpusSeekRecord *_sr,int _nsr,
 1044|      0| opus_int64 _searched,opus_int64 _end_searched,opus_int32 _bias){
 1045|      0|  opus_int64 bisect;
 1046|      0|  int        sri;
 1047|      0|  int        srj;
 1048|       |  /*Require that we be at least OP_CHUNK_SIZE from the end.
 1049|       |    We don't require that we be at least OP_CHUNK_SIZE from the beginning,
 1050|       |     because if we are we'll just scan forward without seeking.*/
 1051|      0|  _end_searched-=OP_CHUNK_SIZE;
 1052|      0|  if(_searched>=_end_searched)return -1;
 1053|      0|  bisect=_end_searched;
 1054|      0|  for(sri=0;sri<_nsr;sri++){
 1055|      0|    ogg_int64_t  gp1;
 1056|      0|    ogg_int64_t  gp2_min;
 1057|      0|    ogg_uint32_t serialno1;
 1058|      0|    opus_int64   offset1;
 1059|       |    /*If the granule position is negative, either it's invalid or we'd cause
 1060|       |       overflow.*/
 1061|      0|    gp1=_sr[sri].gp;
 1062|      0|    if(gp1<0)continue;
 1063|       |    /*We require some minimum distance between granule positions to make an
 1064|       |       estimate.
 1065|       |      We don't actually know what granule position scheme is being used,
 1066|       |       because we have no idea what kind of stream these came from.
 1067|       |      Therefore we require a minimum spacing between them, with the
 1068|       |       expectation that while bitrates and granule position increments might
 1069|       |       vary locally in quite complex ways, they are globally smooth.*/
 1070|      0|    if(OP_UNLIKELY(op_granpos_add(&gp2_min,gp1,OP_GP_SPACING_MIN)<0)){
 1071|       |      /*No granule position would satisfy us.*/
 1072|      0|      continue;
 1073|      0|    }
 1074|      0|    offset1=_sr[sri].offset;
 1075|      0|    serialno1=_sr[sri].serialno;
 1076|      0|    for(srj=sri;srj-->0;){
 1077|      0|      ogg_int64_t gp2;
 1078|      0|      opus_int64  offset2;
 1079|      0|      opus_int64  num;
 1080|      0|      ogg_int64_t den;
 1081|      0|      ogg_int64_t ipart;
 1082|      0|      gp2=_sr[srj].gp;
 1083|      0|      if(gp2<gp2_min)continue;
 1084|       |      /*Oh, and also make sure these came from the same stream.*/
 1085|      0|      if(_sr[srj].serialno!=serialno1)continue;
 1086|      0|      offset2=_sr[srj].offset;
 1087|       |      /*For once, we can subtract with impunity.*/
 1088|      0|      den=gp2-gp1;
 1089|      0|      ipart=gp2/den;
 1090|      0|      num=offset2-offset1;
 1091|      0|      OP_ASSERT(num>0);
 1092|      0|      if(ipart>0&&(offset2-_searched)/ipart<num)continue;
 1093|      0|      offset2-=ipart*num;
 1094|      0|      gp2-=ipart*den;
 1095|      0|      offset2-=op_rescale64(gp2,den,num)-_bias;
 1096|      0|      if(offset2<_searched)continue;
 1097|      0|      bisect=OP_MIN(bisect,offset2);
 1098|      0|      break;
 1099|      0|    }
 1100|      0|  }
 1101|      0|  return bisect>=_end_searched?-1:bisect;
 1102|      0|}
 1103|       |
 1104|       |/*Finds each bitstream link, one at a time, using a bisection search.
 1105|       |  This has to begin by knowing the offset of the first link's initial page.*/
 1106|       |static int op_bisect_forward_serialno(OggOpusFile *_of,
 1107|       | opus_int64 _searched,OpusSeekRecord *_sr,int _csr,
 1108|      3| ogg_uint32_t **_serialnos,int *_nserialnos,int *_cserialnos){
 1109|      3|  ogg_page      og;
 1110|      3|  OggOpusLink  *links;
 1111|      3|  int           nlinks;
 1112|      3|  int           clinks;
 1113|      3|  ogg_uint32_t *serialnos;
 1114|      3|  int           nserialnos;
 1115|      3|  ogg_int64_t   total_duration;
 1116|      3|  int           nsr;
 1117|      3|  int           ret;
 1118|      3|  links=_of->links;
 1119|      3|  nlinks=clinks=_of->nlinks;
 1120|      3|  total_duration=0;
 1121|       |  /*We start with one seek record, for the last page in the file.
 1122|       |    We build up a list of records for places we seek to during link
 1123|       |     enumeration.
 1124|       |    This list is kept sorted in reverse order.
 1125|       |    We only care about seek locations that were _not_ in the current link,
 1126|       |     therefore we can add them one at a time to the end of the list as we
 1127|       |     improve the lower bound on the location where the next link starts.*/
 1128|      3|  nsr=1;
 1129|      3|  for(;;){
 1130|      3|    opus_int64  end_searched;
 1131|      3|    opus_int64  bisect;
 1132|      3|    opus_int64  next;
 1133|      3|    opus_int64  last;
 1134|      3|    ogg_int64_t end_offset;
 1135|      3|    ogg_int64_t end_gp;
 1136|      3|    int         sri;
 1137|      3|    serialnos=*_serialnos;
 1138|      3|    nserialnos=*_nserialnos;
 1139|      3|    if(OP_UNLIKELY(nlinks>=clinks)){
 1140|      3|      if(OP_UNLIKELY(clinks>INT_MAX-1>>1))return OP_EFAULT;
 1141|      3|      clinks=2*clinks+1;
 1142|      3|      OP_ASSERT(nlinks<clinks);
 1143|      3|      links=(OggOpusLink *)_ogg_realloc(links,sizeof(*links)*clinks);
 1144|      3|      if(OP_UNLIKELY(links==NULL))return OP_EFAULT;
 1145|      3|      _of->links=links;
 1146|      3|    }
 1147|       |    /*Invariants:
 1148|       |      We have the headers and serial numbers for the link beginning at 'begin'.
 1149|       |      We have the offset and granule position of the last page in the file
 1150|       |       (potentially not a page we care about).*/
 1151|       |    /*Scan the seek records we already have to save us some bisection.*/
 1152|      3|    for(sri=0;sri<nsr;sri++){
 1153|      3|      if(op_lookup_serialno(_sr[sri].serialno,serialnos,nserialnos))break;
 1154|      3|    }
 1155|       |    /*Is the last page in our current list of serial numbers?*/
 1156|      3|    if(sri<=0)break;
 1157|       |    /*Last page wasn't found.
 1158|       |      We have at least one more link.*/
 1159|      0|    last=-1;
 1160|      0|    end_searched=_sr[sri-1].search_start;
 1161|      0|    next=_sr[sri-1].offset;
 1162|      0|    end_gp=-1;
 1163|      0|    if(sri<nsr){
 1164|      0|      _searched=_sr[sri].offset+_sr[sri].size;
 1165|      0|      if(_sr[sri].serialno==links[nlinks-1].serialno){
 1166|      0|        end_gp=_sr[sri].gp;
 1167|      0|        end_offset=_sr[sri].offset;
 1168|      0|      }
 1169|      0|    }
 1170|      0|    nsr=sri;
 1171|      0|    bisect=-1;
 1172|       |    /*If we've already found the end of at least one link, try to pick the
 1173|       |       first bisection point at twice the average link size.
 1174|       |      This is a good choice for files with lots of links that are all about the
 1175|       |       same size.*/
 1176|      0|    if(nlinks>1){
 1177|      0|      opus_int64 last_offset;
 1178|      0|      opus_int64 avg_link_size;
 1179|      0|      opus_int64 upper_limit;
 1180|      0|      last_offset=links[nlinks-1].offset;
 1181|      0|      avg_link_size=last_offset/(nlinks-1);
 1182|      0|      upper_limit=end_searched-OP_CHUNK_SIZE-avg_link_size;
 1183|      0|      if(OP_LIKELY(last_offset>_searched-avg_link_size)
 1184|      0|       &&OP_LIKELY(last_offset<upper_limit)){
 1185|      0|        bisect=last_offset+avg_link_size;
 1186|      0|        if(OP_LIKELY(bisect<upper_limit))bisect+=avg_link_size;
 1187|      0|      }
 1188|      0|    }
 1189|       |    /*We guard against garbage separating the last and first pages of two
 1190|       |       links below.*/
 1191|      0|    while(_searched<end_searched){
 1192|      0|      opus_int32 next_bias;
 1193|       |      /*If we don't have a better estimate, use simple bisection.*/
 1194|      0|      if(bisect==-1)bisect=_searched+(end_searched-_searched>>1);
 1195|       |      /*If we're within OP_CHUNK_SIZE of the start, scan forward.*/
 1196|      0|      if(bisect-_searched<OP_CHUNK_SIZE)bisect=_searched;
 1197|       |      /*Otherwise we're skipping data.
 1198|       |        Forget the end page, if we saw one, as we might miss a later one.*/
 1199|      0|      else end_gp=-1;
 1200|      0|      ret=op_seek_helper(_of,bisect);
 1201|      0|      if(OP_UNLIKELY(ret<0))return ret;
 1202|      0|      last=op_get_next_page(_of,&og,_sr[nsr-1].offset);
 1203|      0|      if(OP_UNLIKELY(last<OP_FALSE))return (int)last;
 1204|      0|      next_bias=0;
 1205|      0|      if(last==OP_FALSE)end_searched=bisect;
 1206|      0|      else{
 1207|      0|        ogg_uint32_t serialno;
 1208|      0|        ogg_int64_t  gp;
 1209|      0|        serialno=ogg_page_serialno(&og);
 1210|      0|        gp=ogg_page_granulepos(&og);
 1211|      0|        if(!op_lookup_serialno(serialno,serialnos,nserialnos)){
 1212|      0|          end_searched=bisect;
 1213|      0|          next=last;
 1214|       |          /*In reality we should always have enough room, but be paranoid.*/
 1215|      0|          if(OP_LIKELY(nsr<_csr)){
 1216|      0|            _sr[nsr].search_start=bisect;
 1217|      0|            _sr[nsr].offset=last;
 1218|      0|            OP_ASSERT(_of->offset-last>=0);
 1219|      0|            OP_ASSERT(_of->offset-last<=OP_PAGE_SIZE_MAX);
 1220|      0|            _sr[nsr].size=(opus_int32)(_of->offset-last);
 1221|      0|            _sr[nsr].serialno=serialno;
 1222|      0|            _sr[nsr].gp=gp;
 1223|      0|            nsr++;
 1224|      0|          }
 1225|      0|        }
 1226|      0|        else{
 1227|      0|          _searched=_of->offset;
 1228|      0|          next_bias=OP_CHUNK_SIZE;
 1229|      0|          if(serialno==links[nlinks-1].serialno){
 1230|       |            /*This page was from the stream we want, remember it.
 1231|       |              If it's the last such page in the link, we won't have to go back
 1232|       |               looking for it later.*/
 1233|      0|            end_gp=gp;
 1234|      0|            end_offset=last;
 1235|      0|          }
 1236|      0|        }
 1237|      0|      }
 1238|      0|      bisect=op_predict_link_start(_sr,nsr,_searched,end_searched,next_bias);
 1239|      0|    }
 1240|       |    /*Bisection point found.
 1241|       |      Get the final granule position of the previous link, assuming
 1242|       |       op_find_initial_pcm_offset() didn't already determine the link was
 1243|       |       empty.*/
 1244|      0|    if(OP_LIKELY(links[nlinks-1].pcm_end==-1)){
 1245|      0|      if(end_gp==-1){
 1246|       |        /*If we don't know where the end page is, we'll have to seek back and
 1247|       |           look for it, starting from the end of the link.*/
 1248|      0|        end_offset=next;
 1249|       |        /*Also forget the last page we read.
 1250|       |          It won't be available after the seek.*/
 1251|      0|        last=-1;
 1252|      0|      }
 1253|      0|      ret=op_find_final_pcm_offset(_of,serialnos,nserialnos,
 1254|      0|       links+nlinks-1,end_offset,links[nlinks-1].serialno,end_gp,
 1255|      0|       &total_duration);
 1256|      0|      if(OP_UNLIKELY(ret<0))return ret;
 1257|      0|    }
 1258|      0|    if(last!=next){
 1259|       |      /*The last page we read was not the first page the next link.
 1260|       |        Move the cursor position to the offset of that first page.
 1261|       |        This only performs an actual seek if the first page of the next link
 1262|       |         does not start at the end of the last page from the current Opus
 1263|       |         stream with a valid granule position.*/
 1264|      0|      ret=op_seek_helper(_of,next);
 1265|      0|      if(OP_UNLIKELY(ret<0))return ret;
 1266|      0|    }
 1267|      0|    ret=op_fetch_headers(_of,&links[nlinks].head,&links[nlinks].tags,
 1268|      0|     _serialnos,_nserialnos,_cserialnos,last!=next?NULL:&og);
 1269|      0|    if(OP_UNLIKELY(ret<0))return ret;
 1270|      0|    links[nlinks].offset=next;
 1271|      0|    links[nlinks].data_offset=_of->offset;
 1272|      0|    links[nlinks].serialno=_of->os.serialno;
 1273|      0|    links[nlinks].pcm_end=-1;
 1274|       |    /*This might consume a page from the next link, however the next bisection
 1275|       |       always starts with a seek.*/
 1276|      0|    ret=op_find_initial_pcm_offset(_of,links+nlinks,NULL);
 1277|      0|    if(OP_UNLIKELY(ret<0))return ret;
 1278|      0|    links[nlinks].pcm_file_offset=total_duration;
 1279|      0|    _searched=_of->offset;
 1280|       |    /*Mark the current link count so it can be cleaned up on error.*/
 1281|      0|    _of->nlinks=++nlinks;
 1282|      0|  }
 1283|       |  /*Last page is in the starting serialno list, so we've reached the last link.
 1284|       |    Now find the last granule position for it (if we didn't the first time we
 1285|       |     looked at the end of the stream, and if op_find_initial_pcm_offset()
 1286|       |     didn't already determine the link was empty).*/
 1287|      3|  if(OP_LIKELY(links[nlinks-1].pcm_end==-1)){
 1288|      3|    ret=op_find_final_pcm_offset(_of,serialnos,nserialnos,
 1289|      3|     links+nlinks-1,_sr[0].offset,_sr[0].serialno,_sr[0].gp,&total_duration);
 1290|      3|    if(OP_UNLIKELY(ret<0))return ret;
 1291|      3|  }
 1292|       |  /*Trim back the links array if necessary.*/
 1293|      3|  links=(OggOpusLink *)_ogg_realloc(links,sizeof(*links)*nlinks);
 1294|      3|  if(OP_LIKELY(links!=NULL))_of->links=links;
 1295|       |  /*We also don't need these anymore.*/
 1296|      3|  _ogg_free(*_serialnos);
 1297|      3|  *_serialnos=NULL;
 1298|      3|  *_cserialnos=*_nserialnos=0;
 1299|      3|  return 0;
 1300|      3|}
 1301|       |
 1302|      3|static void op_update_gain(OggOpusFile *_of){
 1303|      3|  OpusHead   *head;
 1304|      3|  opus_int32  gain_q8;
 1305|      3|  int         li;
 1306|       |  /*If decode isn't ready, then we'll apply the gain when we initialize the
 1307|       |     decoder.*/
 1308|      3|  if(_of->ready_state<OP_INITSET)return;
 1309|      3|  gain_q8=_of->gain_offset_q8;
 1310|      3|  li=_of->seekable?_of->cur_link:0;
 1311|      3|  head=&_of->links[li].head;
 1312|       |  /*We don't have to worry about overflow here because the header gain and
 1313|       |     track gain must lie in the range [-32768,32767], and the user-supplied
 1314|       |     offset has been pre-clamped to [-98302,98303].*/
 1315|      3|  switch(_of->gain_type){
 1316|      0|    case OP_ALBUM_GAIN:{
 1317|      0|      int album_gain_q8;
 1318|      0|      album_gain_q8=0;
 1319|      0|      opus_tags_get_album_gain(&_of->links[li].tags,&album_gain_q8);
 1320|      0|      gain_q8+=album_gain_q8;
 1321|      0|      gain_q8+=head->output_gain;
 1322|      0|    }break;
 1323|      0|    case OP_TRACK_GAIN:{
 1324|      0|      int track_gain_q8;
 1325|      0|      track_gain_q8=0;
 1326|      0|      opus_tags_get_track_gain(&_of->links[li].tags,&track_gain_q8);
 1327|      0|      gain_q8+=track_gain_q8;
 1328|      0|      gain_q8+=head->output_gain;
 1329|      0|    }break;
 1330|      3|    case OP_HEADER_GAIN:gain_q8+=head->output_gain;break;
 1331|      0|    case OP_ABSOLUTE_GAIN:break;
 1332|      0|    default:OP_ASSERT(0);
 1333|      3|  }
 1334|      3|  gain_q8=OP_CLAMP(-32768,gain_q8,32767);
 1335|      3|  OP_ASSERT(_of->od!=NULL);
 1336|      3|#if defined(OPUS_SET_GAIN)
 1337|      3|  opus_multistream_decoder_ctl(_of->od,OPUS_SET_GAIN(gain_q8));
 1338|       |#else
 1339|       |/*A fallback that works with both float and fixed-point is a bunch of work,
 1340|       |   so just force people to use a sufficiently new version.
 1341|       |  This is deployed well enough at this point that this shouldn't be a burden.*/
 1342|       |# error "libopus 1.0.1 or later required"
 1343|       |#endif
 1344|      3|}
 1345|       |
 1346|      3|static int op_make_decode_ready(OggOpusFile *_of){
 1347|      3|  const OpusHead *head;
 1348|      3|  int             li;
 1349|      3|  int             stream_count;
 1350|      3|  int             coupled_count;
 1351|      3|  int             channel_count;
 1352|      3|  if(_of->ready_state>OP_STREAMSET)return 0;
 1353|      3|  if(OP_UNLIKELY(_of->ready_state<OP_STREAMSET))return OP_EFAULT;
 1354|      3|  li=_of->seekable?_of->cur_link:0;
 1355|      3|  head=&_of->links[li].head;
 1356|      3|  stream_count=head->stream_count;
 1357|      3|  coupled_count=head->coupled_count;
 1358|      3|  channel_count=head->channel_count;
 1359|       |  /*Check to see if the current decoder is compatible with the current link.*/
 1360|      3|  if(_of->od!=NULL&&_of->od_stream_count==stream_count
 1361|      3|   &&_of->od_coupled_count==coupled_count&&_of->od_channel_count==channel_count
 1362|      3|   &&memcmp(_of->od_mapping,head->mapping,
 1363|      0|   sizeof(*head->mapping)*channel_count)==0){
 1364|      0|    opus_multistream_decoder_ctl(_of->od,OPUS_RESET_STATE);
 1365|      0|  }
 1366|      3|  else{
 1367|      3|    int err;
 1368|      3|    opus_multistream_decoder_destroy(_of->od);
 1369|      3|    _of->od=opus_multistream_decoder_create(48000,channel_count,
 1370|      3|     stream_count,coupled_count,head->mapping,&err);
 1371|      3|    if(_of->od==NULL)return OP_EFAULT;
 1372|      3|    _of->od_stream_count=stream_count;
 1373|      3|    _of->od_coupled_count=coupled_count;
 1374|      3|    _of->od_channel_count=channel_count;
 1375|      3|    memcpy(_of->od_mapping,head->mapping,sizeof(*head->mapping)*channel_count);
 1376|      3|  }
 1377|      3|  _of->ready_state=OP_INITSET;
 1378|      3|  _of->bytes_tracked=0;
 1379|      3|  _of->samples_tracked=0;
 1380|      3|#if !defined(OP_FIXED_POINT)
 1381|      3|  _of->state_channel_count=0;
 1382|       |  /*Use the serial number for the PRNG seed to get repeatable output for
 1383|       |     straight play-throughs.*/
 1384|      3|  _of->dither_seed=_of->links[li].serialno;
 1385|      3|#endif
 1386|      3|  op_update_gain(_of);
 1387|      3|  return 0;
 1388|      3|}
 1389|       |
 1390|      3|static int op_open_seekable2_impl(OggOpusFile *_of){
 1391|       |  /*64 seek records should be enough for anybody.
 1392|       |    Actually, with a bisection search in a 63-bit range down to OP_CHUNK_SIZE
 1393|       |     granularity, much more than enough.*/
 1394|      3|  OpusSeekRecord sr[64];
 1395|      3|  opus_int64     data_offset;
 1396|      3|  int            ret;
 1397|       |  /*We can seek, so set out learning all about this file.*/
 1398|      3|  (*_of->callbacks.seek)(_of->stream,0,SEEK_END);
 1399|      3|  _of->offset=_of->end=(*_of->callbacks.tell)(_of->stream);
 1400|      3|  if(OP_UNLIKELY(_of->end<0))return OP_EREAD;
 1401|      3|  data_offset=_of->links[0].data_offset;
 1402|      3|  if(OP_UNLIKELY(_of->end<data_offset))return OP_EBADLINK;
 1403|       |  /*Get the offset of the last page of the physical bitstream, or, if we're
 1404|       |     lucky, the last Opus page of the first link, as most Ogg Opus files will
 1405|       |     contain a single logical bitstream.*/
 1406|      3|  ret=op_get_prev_page_serial(_of,sr,_of->end,
 1407|      3|   _of->links[0].serialno,_of->serialnos,_of->nserialnos);
 1408|      3|  if(OP_UNLIKELY(ret<0))return ret;
 1409|       |  /*If there's any trailing junk, forget about it.*/
 1410|      3|  _of->end=sr[0].offset+sr[0].size;
 1411|      3|  if(OP_UNLIKELY(_of->end<data_offset))return OP_EBADLINK;
 1412|       |  /*Now enumerate the bitstream structure.*/
 1413|      3|  return op_bisect_forward_serialno(_of,data_offset,sr,sizeof(sr)/sizeof(*sr),
 1414|      3|   &_of->serialnos,&_of->nserialnos,&_of->cserialnos);
 1415|      3|}
 1416|       |
 1417|      3|static int op_open_seekable2(OggOpusFile *_of){
 1418|      3|  ogg_sync_state    oy_start;
 1419|      3|  ogg_stream_state  os_start;
 1420|      3|  ogg_packet       *op_start;
 1421|      3|  opus_int64        prev_page_offset;
 1422|      3|  opus_int64        start_offset;
 1423|      3|  int               start_op_count;
 1424|      3|  int               ret;
 1425|       |  /*We're partially open and have a first link header state in storage in _of.
 1426|       |    Save off that stream state so we can come back to it.
 1427|       |    It would be simpler to just dump all this state and seek back to
 1428|       |     links[0].data_offset when we're done.
 1429|       |    But we do the extra work to allow us to seek back to _exactly_ the same
 1430|       |     stream position we're at now.
 1431|       |    This allows, e.g., the HTTP backend to continue reading from the original
 1432|       |     connection (if it's still available), instead of opening a new one.
 1433|       |    This means we can open and start playing a normal Opus file with a single
 1434|       |     link and reasonable packet sizes using only two HTTP requests.*/
 1435|      3|  start_op_count=_of->op_count;
 1436|       |  /*This is a bit too large to put on the stack unconditionally.*/
 1437|      3|  op_start=(ogg_packet *)_ogg_malloc(sizeof(*op_start)*start_op_count);
 1438|      3|  if(op_start==NULL)return OP_EFAULT;
 1439|      3|  *&oy_start=_of->oy;
 1440|      3|  *&os_start=_of->os;
 1441|      3|  prev_page_offset=_of->prev_page_offset;
 1442|      3|  start_offset=_of->offset;
 1443|      3|  memcpy(op_start,_of->op,sizeof(*op_start)*start_op_count);
 1444|      3|  OP_ASSERT((*_of->callbacks.tell)(_of->stream)==op_position(_of));
 1445|      3|  ogg_sync_init(&_of->oy);
 1446|      3|  ogg_stream_init(&_of->os,-1);
 1447|      3|  ret=op_open_seekable2_impl(_of);
 1448|       |  /*Restore the old stream state.*/
 1449|      3|  ogg_stream_clear(&_of->os);
 1450|      3|  ogg_sync_clear(&_of->oy);
 1451|      3|  *&_of->oy=*&oy_start;
 1452|      3|  *&_of->os=*&os_start;
 1453|      3|  _of->offset=start_offset;
 1454|      3|  _of->op_count=start_op_count;
 1455|      3|  memcpy(_of->op,op_start,sizeof(*_of->op)*start_op_count);
 1456|      3|  _ogg_free(op_start);
 1457|      3|  _of->prev_packet_gp=_of->links[0].pcm_start;
 1458|      3|  _of->prev_page_offset=prev_page_offset;
 1459|      3|  _of->cur_discard_count=_of->links[0].head.pre_skip;
 1460|      3|  if(OP_UNLIKELY(ret<0))return ret;
 1461|       |  /*And restore the position indicator.*/
 1462|      3|  ret=(*_of->callbacks.seek)(_of->stream,op_position(_of),SEEK_SET);
 1463|      3|  return OP_UNLIKELY(ret<0)?OP_EREAD:0;
 1464|      3|}
 1465|       |
 1466|       |/*Clear out the current logical bitstream decoder.*/
 1467|      0|static void op_decode_clear(OggOpusFile *_of){
 1468|       |  /*We don't actually free the decoder.
 1469|       |    We might be able to re-use it for the next link.*/
 1470|      0|  _of->op_count=0;
 1471|      0|  _of->od_buffer_size=0;
 1472|      0|  _of->prev_packet_gp=-1;
 1473|      0|  _of->prev_page_offset=-1;
 1474|      0|  if(!_of->seekable){
 1475|      0|    OP_ASSERT(_of->ready_state>=OP_INITSET);
 1476|      0|    opus_tags_clear(&_of->links[0].tags);
 1477|      0|  }
 1478|      0|  _of->ready_state=OP_OPENED;
 1479|      0|}
 1480|       |
 1481|      4|static void op_clear(OggOpusFile *_of){
 1482|      4|  OggOpusLink *links;
 1483|      4|  _ogg_free(_of->od_buffer);
 1484|      4|  if(_of->od!=NULL)opus_multistream_decoder_destroy(_of->od);
 1485|      4|  links=_of->links;
 1486|      4|  if(!_of->seekable){
 1487|      0|    if(_of->ready_state>OP_OPENED||_of->ready_state==OP_PARTOPEN){
 1488|      0|      opus_tags_clear(&links[0].tags);
 1489|      0|    }
 1490|      0|  }
 1491|      4|  else if(OP_LIKELY(links!=NULL)){
 1492|      4|    int nlinks;
 1493|      4|    int link;
 1494|      4|    nlinks=_of->nlinks;
 1495|      7|    for(link=0;link<nlinks;link++)opus_tags_clear(&links[link].tags);
 1496|      4|  }
 1497|      4|  _ogg_free(links);
 1498|      4|  _ogg_free(_of->serialnos);
 1499|      4|  ogg_stream_clear(&_of->os);
 1500|      4|  ogg_sync_clear(&_of->oy);
 1501|      4|  if(_of->callbacks.close!=NULL)(*_of->callbacks.close)(_of->stream);
 1502|      4|}
 1503|       |
 1504|       |static int op_open1(OggOpusFile *_of,
 1505|       | void *_stream,const OpusFileCallbacks *_cb,
 1506|      4| const unsigned char *_initial_data,size_t _initial_bytes){
 1507|      4|  ogg_page  og;
 1508|      4|  ogg_page *pog;
 1509|      4|  int       seekable;
 1510|      4|  int       ret;
 1511|      4|  memset(_of,0,sizeof(*_of));
 1512|      4|  if(OP_UNLIKELY(_initial_bytes>(size_t)LONG_MAX))return OP_EFAULT;
 1513|      4|  _of->end=-1;
 1514|      4|  _of->stream=_stream;
 1515|      4|  *&_of->callbacks=*_cb;
 1516|       |  /*At a minimum, we need to be able to read data.*/
 1517|      4|  if(OP_UNLIKELY(_of->callbacks.read==NULL))return OP_EREAD;
 1518|       |  /*Initialize the framing state.*/
 1519|      4|  ogg_sync_init(&_of->oy);
 1520|       |  /*Perhaps some data was previously read into a buffer for testing against
 1521|       |     other stream types.
 1522|       |    Allow initialization from this previously read data (especially as we may
 1523|       |     be reading from a non-seekable stream).
 1524|       |    This requires copying it into a buffer allocated by ogg_sync_buffer() and
 1525|       |     doesn't support seeking, so this is not a good mechanism to use for
 1526|       |     decoding entire files from RAM.*/
 1527|      4|  if(_initial_bytes>0){
 1528|      0|    char *buffer;
 1529|      0|    buffer=ogg_sync_buffer(&_of->oy,(long)_initial_bytes);
 1530|      0|    memcpy(buffer,_initial_data,_initial_bytes*sizeof(*buffer));
 1531|      0|    ogg_sync_wrote(&_of->oy,(long)_initial_bytes);
 1532|      0|  }
 1533|       |  /*Can we seek?
 1534|       |    Stevens suggests the seek test is portable.
 1535|       |    It's actually not for files on win32, but we address that by fixing it in
 1536|       |     our callback implementation (see stream.c).*/
 1537|      4|  seekable=_cb->seek!=NULL&&(*_cb->seek)(_stream,0,SEEK_CUR)!=-1;
 1538|       |  /*If seek is implemented, tell must also be implemented.*/
 1539|      4|  if(seekable){
 1540|      4|    opus_int64 pos;
 1541|      4|    if(OP_UNLIKELY(_of->callbacks.tell==NULL))return OP_EINVAL;
 1542|      4|    pos=(*_of->callbacks.tell)(_of->stream);
 1543|       |    /*If the current position is not equal to the initial bytes consumed,
 1544|       |       absolute seeking will not work.*/
 1545|      4|    if(OP_UNLIKELY(pos!=(opus_int64)_initial_bytes))return OP_EINVAL;
 1546|      4|  }
 1547|      4|  _of->seekable=seekable;
 1548|       |  /*Don't seek yet.
 1549|       |    Set up a 'single' (current) logical bitstream entry for partial open.*/
 1550|      4|  _of->links=(OggOpusLink *)_ogg_malloc(sizeof(*_of->links));
 1551|       |  /*The serialno gets filled in later by op_fetch_headers().*/
 1552|      4|  ogg_stream_init(&_of->os,-1);
 1553|      4|  pog=NULL;
 1554|      4|  for(;;){
 1555|       |    /*Fetch all BOS pages, store the Opus header and all seen serial numbers,
 1556|       |      and load subsequent Opus setup headers.*/
 1557|      4|    ret=op_fetch_headers(_of,&_of->links[0].head,&_of->links[0].tags,
 1558|      4|     &_of->serialnos,&_of->nserialnos,&_of->cserialnos,pog);
 1559|      4|    if(OP_UNLIKELY(ret<0))break;
 1560|      3|    _of->nlinks=1;
 1561|      3|    _of->links[0].offset=0;
 1562|      3|    _of->links[0].data_offset=_of->offset;
 1563|      3|    _of->links[0].pcm_end=-1;
 1564|      3|    _of->links[0].serialno=_of->os.serialno;
 1565|       |    /*Fetch the initial PCM offset.*/
 1566|      3|    ret=op_find_initial_pcm_offset(_of,_of->links,&og);
 1567|      3|    if(seekable||OP_LIKELY(ret<=0))break;
 1568|       |    /*This link was empty, but we already have the BOS page for the next one in
 1569|       |       og.
 1570|       |      We can't seek, so start processing the next link right now.*/
 1571|      0|    opus_tags_clear(&_of->links[0].tags);
 1572|      0|    _of->nlinks=0;
 1573|      0|    if(!seekable)_of->cur_link++;
 1574|      0|    pog=&og;
 1575|      0|  }
 1576|      4|  if(OP_LIKELY(ret>=0))_of->ready_state=OP_PARTOPEN;
 1577|      4|  return ret;
 1578|      4|}
 1579|       |
 1580|      3|static int op_open2(OggOpusFile *_of){
 1581|      3|  int ret;
 1582|      3|  OP_ASSERT(_of->ready_state==OP_PARTOPEN);
 1583|      3|  if(_of->seekable){
 1584|      3|    _of->ready_state=OP_OPENED;
 1585|      3|    ret=op_open_seekable2(_of);
 1586|      3|  }
 1587|      0|  else ret=0;
 1588|      3|  if(OP_LIKELY(ret>=0)){
 1589|       |    /*We have buffered packets from op_find_initial_pcm_offset().
 1590|       |      Move to OP_INITSET so we can use them.*/
 1591|      3|    _of->ready_state=OP_STREAMSET;
 1592|      3|    ret=op_make_decode_ready(_of);
 1593|      3|    if(OP_LIKELY(ret>=0))return 0;
 1594|      3|  }
 1595|       |  /*Don't auto-close the stream on failure.*/
 1596|      0|  _of->callbacks.close=NULL;
 1597|      0|  op_clear(_of);
 1598|      0|  return ret;
 1599|      3|}
 1600|       |
 1601|       |OggOpusFile *op_test_callbacks(void *_stream,const OpusFileCallbacks *_cb,
 1602|      4| const unsigned char *_initial_data,size_t _initial_bytes,int *_error){
 1603|      4|  OggOpusFile *of;
 1604|      4|  int          ret;
 1605|      4|  of=(OggOpusFile *)_ogg_malloc(sizeof(*of));
 1606|      4|  ret=OP_EFAULT;
 1607|      4|  if(OP_LIKELY(of!=NULL)){
 1608|      4|    ret=op_open1(of,_stream,_cb,_initial_data,_initial_bytes);
 1609|      4|    if(OP_LIKELY(ret>=0)){
 1610|      3|      if(_error!=NULL)*_error=0;
 1611|      3|      return of;
 1612|      3|    }
 1613|       |    /*Don't auto-close the stream on failure.*/
 1614|      1|    of->callbacks.close=NULL;
 1615|      1|    op_clear(of);
 1616|      1|    _ogg_free(of);
 1617|      1|  }
 1618|      1|  if(_error!=NULL)*_error=ret;
 1619|      1|  return NULL;
 1620|      4|}
 1621|       |
 1622|       |OggOpusFile *op_open_callbacks(void *_stream,const OpusFileCallbacks *_cb,
 1623|      0| const unsigned char *_initial_data,size_t _initial_bytes,int *_error){
 1624|      0|  OggOpusFile *of;
 1625|      0|  of=op_test_callbacks(_stream,_cb,_initial_data,_initial_bytes,_error);
 1626|      0|  if(OP_LIKELY(of!=NULL)){
 1627|      0|    int ret;
 1628|      0|    ret=op_open2(of);
 1629|      0|    if(OP_LIKELY(ret>=0))return of;
 1630|      0|    if(_error!=NULL)*_error=ret;
 1631|      0|    _ogg_free(of);
 1632|      0|  }
 1633|      0|  return NULL;
 1634|      0|}
 1635|       |
 1636|       |/*Convenience routine to clean up from failure for the open functions that
 1637|       |   create their own streams.*/
 1638|       |static OggOpusFile *op_open_close_on_failure(void *_stream,
 1639|      0| const OpusFileCallbacks *_cb,int *_error){
 1640|      0|  OggOpusFile *of;
 1641|      0|  if(OP_UNLIKELY(_stream==NULL)){
 1642|      0|    if(_error!=NULL)*_error=OP_EFAULT;
 1643|      0|    return NULL;
 1644|      0|  }
 1645|      0|  of=op_open_callbacks(_stream,_cb,NULL,0,_error);
 1646|      0|  if(OP_UNLIKELY(of==NULL)){
 1647|      0|    (*_cb->close)(_stream);
 1648|      0|  }
 1649|      0|  return of;
 1650|      0|}
 1651|       |
 1652|      0|OggOpusFile *op_open_file(const char *_path,int *_error){
 1653|      0|  OpusFileCallbacks cb;
 1654|      0|  return op_open_close_on_failure(op_fopen(&cb,_path,"rb"),&cb,_error);
 1655|      0|}
 1656|       |
 1657|       |OggOpusFile *op_open_memory(const unsigned char *_data,size_t _size,
 1658|      0| int *_error){
 1659|      0|  OpusFileCallbacks cb;
 1660|      0|  return op_open_close_on_failure(op_mem_stream_create(&cb,_data,_size),&cb,
 1661|      0|   _error);
 1662|      0|}
 1663|       |
 1664|       |/*Convenience routine to clean up from failure for the open functions that
 1665|       |   create their own streams.*/
 1666|       |static OggOpusFile *op_test_close_on_failure(void *_stream,
 1667|      4| const OpusFileCallbacks *_cb,int *_error){
 1668|      4|  OggOpusFile *of;
 1669|      4|  if(OP_UNLIKELY(_stream==NULL)){
 1670|      0|    if(_error!=NULL)*_error=OP_EFAULT;
 1671|      0|    return NULL;
 1672|      0|  }
 1673|      4|  of=op_test_callbacks(_stream,_cb,NULL,0,_error);
 1674|      4|  if(OP_UNLIKELY(of==NULL)) {
 1675|      1|    (*_cb->close)(_stream);
 1676|      1|  }
 1677|      4|  return of;
 1678|      4|}
 1679|       |
 1680|      4|OggOpusFile *op_test_file(const char *_path,int *_error){
 1681|      4|  OpusFileCallbacks cb;
 1682|      4|  return op_test_close_on_failure(op_fopen(&cb,_path,"rb"),&cb,_error);
 1683|      4|}
 1684|       |
 1685|       |OggOpusFile *op_test_memory(const unsigned char *_data,size_t _size,
 1686|      0| int *_error){
 1687|      0|  OpusFileCallbacks cb;
 1688|      0|  return op_test_close_on_failure(op_mem_stream_create(&cb,_data,_size),&cb,
 1689|      0|   _error);
 1690|      0|}
 1691|       |
 1692|      3|int op_test_open(OggOpusFile *_of){
 1693|      3|  int ret;
 1694|      3|  if(OP_UNLIKELY(_of->ready_state!=OP_PARTOPEN))return OP_EINVAL;
 1695|      3|  ret=op_open2(_of);
 1696|       |  /*op_open2() will clear this structure on failure.
 1697|       |    Reset its contents to prevent double-frees in op_free().*/
 1698|      3|  if (OP_UNLIKELY(ret<0)) {
 1699|      0|    printf("opusfile op_test_open unlikely.... ret=%d\n", ret);
 1700|      0|  }
 1701|      3|  if(OP_UNLIKELY(ret<0))memset(_of,0,sizeof(*_of));
 1702|      3|  return ret;
 1703|      3|}
 1704|       |
 1705|      3|void op_free(OggOpusFile *_of){
 1706|      3|  if(OP_LIKELY(_of!=NULL)){
 1707|      3|    op_clear(_of);
 1708|      3|    _ogg_free(_of);
 1709|      3|  }
 1710|      3|}
 1711|       |
 1712|      0|int op_seekable(const OggOpusFile *_of){
 1713|      0|  return _of->seekable;
 1714|      0|}
 1715|       |
 1716|      0|int op_link_count(const OggOpusFile *_of){
 1717|      0|  return _of->nlinks;
 1718|      0|}
 1719|       |
 1720|      0|opus_uint32 op_serialno(const OggOpusFile *_of,int _li){
 1721|      0|  if(OP_UNLIKELY(_li>=_of->nlinks))_li=_of->nlinks-1;
 1722|      0|  if(!_of->seekable)_li=0;
 1723|      0|  return _of->links[_li<0?_of->cur_link:_li].serialno;
 1724|      0|}
 1725|       |
 1726|      3|int op_channel_count(const OggOpusFile *_of,int _li){
 1727|      3|  return op_head(_of,_li)->channel_count;
 1728|      3|}
 1729|       |
 1730|      0|opus_int64 op_raw_total(const OggOpusFile *_of,int _li){
 1731|      0|  if(OP_UNLIKELY(_of->ready_state<OP_OPENED)
 1732|      0|   ||OP_UNLIKELY(!_of->seekable)
 1733|      0|   ||OP_UNLIKELY(_li>=_of->nlinks)){
 1734|      0|    return OP_EINVAL;
 1735|      0|  }
 1736|      0|  if(_li<0)return _of->end;
 1737|      0|  return (_li+1>=_of->nlinks?_of->end:_of->links[_li+1].offset)
 1738|      0|   -(_li>0?_of->links[_li].offset:0);
 1739|      0|}
 1740|       |
 1741|      1|ogg_int64_t op_pcm_total(const OggOpusFile *_of,int _li){
 1742|      1|  OggOpusLink *links;
 1743|      1|  ogg_int64_t  pcm_total;
 1744|      1|  ogg_int64_t  diff;
 1745|      1|  int          nlinks;
 1746|      1|  nlinks=_of->nlinks;
 1747|      1|  if(OP_UNLIKELY(_of->ready_state<OP_OPENED)
 1748|      1|   ||OP_UNLIKELY(!_of->seekable)
 1749|      1|   ||OP_UNLIKELY(_li>=nlinks)){
 1750|      0|    return OP_EINVAL;
 1751|      0|  }
 1752|      1|  links=_of->links;
 1753|       |  /*We verify that the granule position differences are larger than the
 1754|       |     pre-skip and that the total duration does not overflow during link
 1755|       |     enumeration, so we don't have to check here.*/
 1756|      1|  pcm_total=0;
 1757|      1|  if(_li<0){
 1758|      1|    pcm_total=links[nlinks-1].pcm_file_offset;
 1759|      1|    _li=nlinks-1;
 1760|      1|  }
 1761|      1|  OP_ALWAYS_TRUE(!op_granpos_diff(&diff,
 1762|      1|   links[_li].pcm_end,links[_li].pcm_start));
 1763|      1|  return pcm_total+diff-links[_li].head.pre_skip;
 1764|      1|}
 1765|       |
 1766|      3|const OpusHead *op_head(const OggOpusFile *_of,int _li){
 1767|      3|  if(OP_UNLIKELY(_li>=_of->nlinks))_li=_of->nlinks-1;
 1768|      3|  if(!_of->seekable)_li=0;
 1769|      3|  return &_of->links[_li<0?_of->cur_link:_li].head;
 1770|      3|}
 1771|       |
 1772|      0|const OpusTags *op_tags(const OggOpusFile *_of,int _li){
 1773|      0|  if(OP_UNLIKELY(_li>=_of->nlinks))_li=_of->nlinks-1;
 1774|      0|  if(!_of->seekable){
 1775|      0|    if(_of->ready_state<OP_STREAMSET&&_of->ready_state!=OP_PARTOPEN){
 1776|      0|      return NULL;
 1777|      0|    }
 1778|      0|    _li=0;
 1779|      0|  }
 1780|      0|  else if(_li<0)_li=_of->ready_state>=OP_STREAMSET?_of->cur_link:0;
 1781|      0|  return &_of->links[_li].tags;
 1782|      0|}
 1783|       |
 1784|      0|int op_current_link(const OggOpusFile *_of){
 1785|      0|  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;
 1786|      0|  return _of->cur_link;
 1787|      0|}
 1788|       |
 1789|       |/*Compute an average bitrate given a byte and sample count.
 1790|       |  Return: The bitrate in bits per second.*/
 1791|      0|static opus_int32 op_calc_bitrate(opus_int64 _bytes,ogg_int64_t _samples){
 1792|      0|  if(OP_UNLIKELY(_samples<=0))return OP_INT32_MAX;
 1793|       |  /*These rates are absurd, but let's handle them anyway.*/
 1794|      0|  if(OP_UNLIKELY(_bytes>(OP_INT64_MAX-(_samples>>1))/(48000*8))){
 1795|      0|    ogg_int64_t den;
 1796|      0|    if(OP_UNLIKELY(_bytes/(OP_INT32_MAX/(48000*8))>=_samples)){
 1797|      0|      return OP_INT32_MAX;
 1798|      0|    }
 1799|      0|    den=_samples/(48000*8);
 1800|      0|    return (opus_int32)((_bytes+(den>>1))/den);
 1801|      0|  }
 1802|       |  /*This can't actually overflow in normal operation: even with a pre-skip of
 1803|       |     545 2.5 ms frames with 8 streams running at 1282*8+1 bytes per packet
 1804|       |     (1275 byte frames + Opus framing overhead + Ogg lacing values), that all
 1805|       |     produce a single sample of decoded output, we still don't top 45 Mbps.
 1806|       |    The only way to get bitrates larger than that is with excessive Opus
 1807|       |     padding, more encoded streams than output channels, or lots and lots of
 1808|       |     Ogg pages with no packets on them.*/
 1809|      0|  return (opus_int32)OP_MIN((_bytes*48000*8+(_samples>>1))/_samples,
 1810|      0|   OP_INT32_MAX);
 1811|      0|}
 1812|       |
 1813|      0|opus_int32 op_bitrate(const OggOpusFile *_of,int _li){
 1814|      0|  if(OP_UNLIKELY(_of->ready_state<OP_OPENED)||OP_UNLIKELY(!_of->seekable)
 1815|      0|   ||OP_UNLIKELY(_li>=_of->nlinks)){
 1816|      0|    return OP_EINVAL;
 1817|      0|  }
 1818|      0|  return op_calc_bitrate(op_raw_total(_of,_li),op_pcm_total(_of,_li));
 1819|      0|}
 1820|       |
 1821|      0|opus_int32 op_bitrate_instant(OggOpusFile *_of){
 1822|      0|  ogg_int64_t samples_tracked;
 1823|      0|  opus_int32  ret;
 1824|      0|  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;
 1825|      0|  samples_tracked=_of->samples_tracked;
 1826|      0|  if(OP_UNLIKELY(samples_tracked==0))return OP_FALSE;
 1827|      0|  ret=op_calc_bitrate(_of->bytes_tracked,samples_tracked);
 1828|      0|  _of->bytes_tracked=0;
 1829|      0|  _of->samples_tracked=0;
 1830|      0|  return ret;
 1831|      0|}
 1832|       |
 1833|       |/*Given a serialno, find a link with a corresponding Opus stream, if it exists.
 1834|       |  Return: The index of the link to which the page belongs, or a negative number
 1835|       |           if it was not a desired Opus bitstream section.*/
 1836|       |static int op_get_link_from_serialno(const OggOpusFile *_of,int _cur_link,
 1837|      0| opus_int64 _page_offset,ogg_uint32_t _serialno){
 1838|      0|  const OggOpusLink *links;
 1839|      0|  int                nlinks;
 1840|      0|  int                li_lo;
 1841|      0|  int                li_hi;
 1842|      0|  OP_ASSERT(_of->seekable);
 1843|      0|  links=_of->links;
 1844|      0|  nlinks=_of->nlinks;
 1845|      0|  li_lo=0;
 1846|       |  /*Start off by guessing we're just a multiplexed page in the current link.*/
 1847|      0|  li_hi=_cur_link+1<nlinks&&_page_offset<links[_cur_link+1].offset?
 1848|      0|   _cur_link+1:nlinks;
 1849|      0|  do{
 1850|      0|    if(_page_offset>=links[_cur_link].offset)li_lo=_cur_link;
 1851|      0|    else li_hi=_cur_link;
 1852|      0|    _cur_link=li_lo+(li_hi-li_lo>>1);
 1853|      0|  }
 1854|      0|  while(li_hi-li_lo>1);
 1855|       |  /*We've identified the link that should contain this page.
 1856|       |    Make sure it's a page we care about.*/
 1857|      0|  if(links[_cur_link].serialno!=_serialno)return OP_FALSE;
 1858|      0|  return _cur_link;
 1859|      0|}
 1860|       |
 1861|       |/*Fetch and process a page.
 1862|       |  This handles the case where we're at a bitstream boundary and dumps the
 1863|       |   decoding machine.
 1864|       |  If the decoding machine is unloaded, it loads it.
 1865|       |  It also keeps prev_packet_gp up to date (seek and read both use this).
 1866|       |  Return: <0) Error, OP_HOLE (lost packet), or OP_EOF.
 1867|       |           0) Got at least one audio data packet.*/
 1868|       |static int op_fetch_and_process_page(OggOpusFile *_of,
 1869|      0| ogg_page *_og,opus_int64 _page_offset,int _spanp,int _ignore_holes){
 1870|      0|  OggOpusLink  *links;
 1871|      0|  ogg_uint32_t  cur_serialno;
 1872|      0|  int           seekable;
 1873|      0|  int           cur_link;
 1874|      0|  int           ret;
 1875|       |  /*We shouldn't get here if we have unprocessed packets.*/
 1876|      0|  OP_ASSERT(_of->ready_state<OP_INITSET||_of->op_pos>=_of->op_count);
 1877|      0|  seekable=_of->seekable;
 1878|      0|  links=_of->links;
 1879|      0|  cur_link=seekable?_of->cur_link:0;
 1880|      0|  cur_serialno=links[cur_link].serialno;
 1881|       |  /*Handle one page.*/
 1882|      0|  for(;;){
 1883|      0|    ogg_page og;
 1884|      0|    OP_ASSERT(_of->ready_state>=OP_OPENED);
 1885|       |    /*If we were given a page to use, use it.*/
 1886|      0|    if(_og!=NULL){
 1887|      0|      *&og=*_og;
 1888|      0|      _og=NULL;
 1889|      0|    }
 1890|       |    /*Keep reading until we get a page with the correct serialno.*/
 1891|      0|    else _page_offset=op_get_next_page(_of,&og,_of->end);
 1892|       |    /*EOF: Leave uninitialized.*/
 1893|      0|    if(_page_offset<0)return _page_offset<OP_FALSE?(int)_page_offset:OP_EOF;
 1894|      0|    if(OP_LIKELY(_of->ready_state>=OP_STREAMSET)
 1895|      0|     &&cur_serialno!=(ogg_uint32_t)ogg_page_serialno(&og)){
 1896|       |      /*Two possibilities:
 1897|       |         1) Another stream is multiplexed into this logical section, or*/
 1898|      0|      if(OP_LIKELY(!ogg_page_bos(&og)))continue;
 1899|       |      /* 2) Our decoding just traversed a bitstream boundary.*/
 1900|      0|      if(!_spanp)return OP_EOF;
 1901|      0|      if(OP_LIKELY(_of->ready_state>=OP_INITSET))op_decode_clear(_of);
 1902|      0|    }
 1903|       |    /*Bitrate tracking: add the header's bytes here.
 1904|       |      The body bytes are counted when we consume the packets.*/
 1905|      0|    else _of->bytes_tracked+=og.header_len;
 1906|       |    /*Do we need to load a new machine before submitting the page?
 1907|       |      This is different in the seekable and non-seekable cases.
 1908|       |      In the seekable case, we already have all the header information loaded
 1909|       |       and cached.
 1910|       |      We just initialize the machine with it and continue on our merry way.
 1911|       |      In the non-seekable (streaming) case, we'll only be at a boundary if we
 1912|       |       just left the previous logical bitstream, and we're now nominally at the
 1913|       |       header of the next bitstream.*/
 1914|      0|    if(OP_UNLIKELY(_of->ready_state<OP_STREAMSET)){
 1915|      0|      if(seekable){
 1916|      0|        ogg_uint32_t serialno;
 1917|      0|        serialno=ogg_page_serialno(&og);
 1918|       |        /*Match the serialno to bitstream section.*/
 1919|      0|        OP_ASSERT(cur_link>=0&&cur_link<_of->nlinks);
 1920|      0|        if(links[cur_link].serialno!=serialno){
 1921|       |          /*It wasn't a page from the current link.
 1922|       |            Is it from the next one?*/
 1923|      0|          if(OP_LIKELY(cur_link+1<_of->nlinks&&links[cur_link+1].serialno==
 1924|      0|           serialno)){
 1925|      0|            cur_link++;
 1926|      0|          }
 1927|      0|          else{
 1928|      0|            int new_link;
 1929|      0|            new_link=
 1930|      0|             op_get_link_from_serialno(_of,cur_link,_page_offset,serialno);
 1931|       |            /*Not a desired Opus bitstream section.
 1932|       |              Keep trying.*/
 1933|      0|            if(new_link<0)continue;
 1934|      0|            cur_link=new_link;
 1935|      0|          }
 1936|      0|        }
 1937|      0|        cur_serialno=serialno;
 1938|      0|        _of->cur_link=cur_link;
 1939|      0|        ogg_stream_reset_serialno(&_of->os,serialno);
 1940|      0|        _of->ready_state=OP_STREAMSET;
 1941|       |        /*If we're at the start of this link, initialize the granule position
 1942|       |           and pre-skip tracking.*/
 1943|      0|        if(_page_offset<=links[cur_link].data_offset){
 1944|      0|          _of->prev_packet_gp=links[cur_link].pcm_start;
 1945|      0|          _of->prev_page_offset=-1;
 1946|      0|          _of->cur_discard_count=links[cur_link].head.pre_skip;
 1947|       |          /*Ignore a hole at the start of a new link (this is common for
 1948|       |             streams joined in the middle) or after seeking.*/
 1949|      0|          _ignore_holes=1;
 1950|      0|        }
 1951|      0|      }
 1952|      0|      else{
 1953|      0|        do{
 1954|       |          /*We're streaming.
 1955|       |            Fetch the two header packets, build the info struct.*/
 1956|      0|          ret=op_fetch_headers(_of,&links[0].head,&links[0].tags,
 1957|      0|           NULL,NULL,NULL,&og);
 1958|      0|          if(OP_UNLIKELY(ret<0))return ret;
 1959|       |          /*op_find_initial_pcm_offset() will suppress any initial hole for us,
 1960|       |             so no need to set _ignore_holes.*/
 1961|      0|          ret=op_find_initial_pcm_offset(_of,links,&og);
 1962|      0|          if(OP_UNLIKELY(ret<0))return ret;
 1963|      0|          _of->links[0].serialno=cur_serialno=_of->os.serialno;
 1964|      0|          _of->cur_link++;
 1965|      0|        }
 1966|       |        /*If the link was empty, keep going, because we already have the
 1967|       |           BOS page of the next one in og.*/
 1968|      0|        while(OP_UNLIKELY(ret>0));
 1969|       |        /*If we didn't get any packets out of op_find_initial_pcm_offset(),
 1970|       |           keep going (this is possible if end-trimming trimmed them all).*/
 1971|      0|        if(_of->op_count<=0)continue;
 1972|       |        /*Otherwise, we're done.
 1973|       |          TODO: This resets bytes_tracked, which misses the header bytes
 1974|       |           already processed by op_find_initial_pcm_offset().*/
 1975|      0|        ret=op_make_decode_ready(_of);
 1976|      0|        if(OP_UNLIKELY(ret<0))return ret;
 1977|      0|        return 0;
 1978|      0|      }
 1979|      0|    }
 1980|       |    /*The buffered page is the data we want, and we're ready for it.
 1981|       |      Add it to the stream state.*/
 1982|      0|    if(OP_UNLIKELY(_of->ready_state==OP_STREAMSET)){
 1983|      0|      ret=op_make_decode_ready(_of);
 1984|      0|      if(OP_UNLIKELY(ret<0))return ret;
 1985|      0|    }
 1986|       |    /*Extract all the packets from the current page.*/
 1987|      0|    ogg_stream_pagein(&_of->os,&og);
 1988|      0|    if(OP_LIKELY(_of->ready_state>=OP_INITSET)){
 1989|      0|      opus_int32 total_duration;
 1990|      0|      int        durations[255];
 1991|      0|      int        op_count;
 1992|      0|      int        report_hole;
 1993|      0|      report_hole=0;
 1994|      0|      total_duration=op_collect_audio_packets(_of,durations);
 1995|      0|      if(OP_UNLIKELY(total_duration<0)){
 1996|       |        /*libogg reported a hole (a gap in the page sequence numbers).
 1997|       |          Drain the packets from the page anyway.
 1998|       |          If we don't, they'll still be there when we fetch the next page.
 1999|       |          Then, when we go to pull out packets, we might get more than 255,
 2000|       |           which would overrun our packet buffer.
 2001|       |          We repeat this call until we get any actual packets, since we might
 2002|       |           have buffered multiple out-of-sequence pages with no packets on
 2003|       |           them.*/
 2004|      0|        do total_duration=op_collect_audio_packets(_of,durations);
 2005|      0|        while(total_duration<0);
 2006|      0|        if(!_ignore_holes){
 2007|       |          /*Report the hole to the caller after we finish timestamping the
 2008|       |             packets.*/
 2009|      0|          report_hole=1;
 2010|       |          /*We had lost or damaged pages, so reset our granule position
 2011|       |             tracking.
 2012|       |            This makes holes behave the same as a small raw seek.
 2013|       |            If the next page is the EOS page, we'll discard it (because we
 2014|       |             can't perform end trimming properly), and we'll always discard at
 2015|       |             least 80 ms of audio (to allow decoder state to re-converge).
 2016|       |            We could try to fill in the gap with PLC by looking at timestamps
 2017|       |             in the non-EOS case, but that's complicated and error prone and we
 2018|       |             can't rely on the timestamps being valid.*/
 2019|      0|          _of->prev_packet_gp=-1;
 2020|      0|        }
 2021|      0|      }
 2022|      0|      op_count=_of->op_count;
 2023|       |      /*If we found at least one audio data packet, compute per-packet granule
 2024|       |         positions for them.*/
 2025|      0|      if(op_count>0){
 2026|      0|        ogg_int64_t diff;
 2027|      0|        ogg_int64_t prev_packet_gp;
 2028|      0|        ogg_int64_t cur_packet_gp;
 2029|      0|        ogg_int64_t cur_page_gp;
 2030|      0|        int         cur_page_eos;
 2031|      0|        int         pi;
 2032|      0|        cur_page_gp=_of->op[op_count-1].granulepos;
 2033|      0|        cur_page_eos=_of->op[op_count-1].e_o_s;
 2034|      0|        prev_packet_gp=_of->prev_packet_gp;
 2035|      0|        if(OP_UNLIKELY(prev_packet_gp==-1)){
 2036|      0|          opus_int32 cur_discard_count;
 2037|       |          /*This is the first call after a raw seek.
 2038|       |            Try to reconstruct prev_packet_gp from scratch.*/
 2039|      0|          OP_ASSERT(seekable);
 2040|      0|          if(OP_UNLIKELY(cur_page_eos)){
 2041|       |            /*If the first page we hit after our seek was the EOS page, and
 2042|       |               we didn't start from data_offset or before, we don't have
 2043|       |               enough information to do end-trimming.
 2044|       |              Proceed to the next link, rather than risk playing back some
 2045|       |               samples that shouldn't have been played.*/
 2046|      0|            _of->op_count=0;
 2047|      0|            if(report_hole)return OP_HOLE;
 2048|      0|            continue;
 2049|      0|          }
 2050|       |          /*By default discard 80 ms of data after a seek, unless we seek
 2051|       |             into the pre-skip region.*/
 2052|      0|          cur_discard_count=80*48;
 2053|      0|          cur_page_gp=_of->op[op_count-1].granulepos;
 2054|       |          /*Try to initialize prev_packet_gp.
 2055|       |            If the current page had packets but didn't have a granule
 2056|       |             position, or the granule position it had was too small (both
 2057|       |             illegal), just use the starting granule position for the link.*/
 2058|      0|          prev_packet_gp=links[cur_link].pcm_start;
 2059|      0|          if(OP_LIKELY(cur_page_gp!=-1)){
 2060|      0|            op_granpos_add(&prev_packet_gp,cur_page_gp,-total_duration);
 2061|      0|          }
 2062|      0|          if(OP_LIKELY(!op_granpos_diff(&diff,
 2063|      0|           prev_packet_gp,links[cur_link].pcm_start))){
 2064|      0|            opus_int32 pre_skip;
 2065|       |            /*If we start at the beginning of the pre-skip region, or we're
 2066|       |               at least 80 ms from the end of the pre-skip region, we discard
 2067|       |               to the end of the pre-skip region.
 2068|       |              Otherwise, we still use the 80 ms default, which will discard
 2069|       |               past the end of the pre-skip region.*/
 2070|      0|            pre_skip=links[cur_link].head.pre_skip;
 2071|      0|            if(diff>=0&&diff<=OP_MAX(0,pre_skip-80*48)){
 2072|      0|              cur_discard_count=pre_skip-(int)diff;
 2073|      0|            }
 2074|      0|          }
 2075|      0|          _of->cur_discard_count=cur_discard_count;
 2076|      0|        }
 2077|      0|        if(OP_UNLIKELY(cur_page_gp==-1)){
 2078|       |          /*This page had completed packets but didn't have a valid granule
 2079|       |             position.
 2080|       |            This is illegal, but we'll try to handle it by continuing to count
 2081|       |             forwards from the previous page.*/
 2082|      0|          if(op_granpos_add(&cur_page_gp,prev_packet_gp,total_duration)<0){
 2083|       |            /*The timestamp for this page overflowed.*/
 2084|      0|            cur_page_gp=links[cur_link].pcm_end;
 2085|      0|          }
 2086|      0|        }
 2087|       |        /*If we hit the last page, handle end-trimming.*/
 2088|      0|        if(OP_UNLIKELY(cur_page_eos)
 2089|      0|         &&OP_LIKELY(!op_granpos_diff(&diff,cur_page_gp,prev_packet_gp))
 2090|      0|         &&OP_LIKELY(diff<total_duration)){
 2091|      0|          cur_packet_gp=prev_packet_gp;
 2092|      0|          for(pi=0;pi<op_count;pi++){
 2093|       |            /*Check for overflow.*/
 2094|      0|            if(diff<0&&OP_UNLIKELY(OP_INT64_MAX+diff<durations[pi])){
 2095|      0|              diff=durations[pi]+1;
 2096|      0|            }
 2097|      0|            else diff=durations[pi]-diff;
 2098|       |            /*If we have samples to trim...*/
 2099|      0|            if(diff>0){
 2100|       |              /*If we trimmed the entire packet, stop (the spec says encoders
 2101|       |                 shouldn't do this, but we support it anyway).*/
 2102|      0|              if(OP_UNLIKELY(diff>durations[pi]))break;
 2103|      0|              cur_packet_gp=cur_page_gp;
 2104|       |              /*Move the EOS flag to this packet, if necessary, so we'll trim
 2105|       |                 the samples during decode.*/
 2106|      0|              _of->op[pi].e_o_s=1;
 2107|      0|            }
 2108|      0|            else{
 2109|       |              /*Update the granule position as normal.*/
 2110|      0|              OP_ALWAYS_TRUE(!op_granpos_add(&cur_packet_gp,
 2111|      0|               cur_packet_gp,durations[pi]));
 2112|      0|            }
 2113|      0|            _of->op[pi].granulepos=cur_packet_gp;
 2114|      0|            OP_ALWAYS_TRUE(!op_granpos_diff(&diff,cur_page_gp,cur_packet_gp));
 2115|      0|          }
 2116|      0|        }
 2117|      0|        else{
 2118|       |          /*Propagate timestamps to earlier packets.
 2119|       |            op_granpos_add(&prev_packet_gp,prev_packet_gp,total_duration)
 2120|       |             should succeed and give prev_packet_gp==cur_page_gp.
 2121|       |            But we don't bother to check that, as there isn't much we can do
 2122|       |             if it's not true, and it actually will not be true on the first
 2123|       |             page after a seek, if there was a continued packet.
 2124|       |            The only thing we guarantee is that the start and end granule
 2125|       |             positions of the packets are valid, and that they are monotonic
 2126|       |             within a page.
 2127|       |            They might be completely out of range for this link (we'll check
 2128|       |             that elsewhere), or non-monotonic between pages.*/
 2129|      0|          if(OP_UNLIKELY(op_granpos_add(&prev_packet_gp,
 2130|      0|           cur_page_gp,-total_duration)<0)){
 2131|       |            /*The starting timestamp for the first packet on this page
 2132|       |               underflowed.
 2133|       |              This is illegal, but we ignore it.*/
 2134|      0|            prev_packet_gp=0;
 2135|      0|          }
 2136|      0|          for(pi=0;pi<op_count;pi++){
 2137|      0|            if(OP_UNLIKELY(op_granpos_add(&cur_packet_gp,
 2138|      0|             cur_page_gp,-total_duration)<0)){
 2139|       |              /*The start timestamp for this packet underflowed.
 2140|       |                This is illegal, but we ignore it.*/
 2141|      0|              cur_packet_gp=0;
 2142|      0|            }
 2143|      0|            total_duration-=durations[pi];
 2144|      0|            OP_ASSERT(total_duration>=0);
 2145|      0|            OP_ALWAYS_TRUE(!op_granpos_add(&cur_packet_gp,
 2146|      0|             cur_packet_gp,durations[pi]));
 2147|      0|            _of->op[pi].granulepos=cur_packet_gp;
 2148|      0|          }
 2149|      0|          OP_ASSERT(total_duration==0);
 2150|      0|        }
 2151|      0|        _of->prev_packet_gp=prev_packet_gp;
 2152|      0|        _of->prev_page_offset=_page_offset;
 2153|      0|        _of->op_count=op_count=pi;
 2154|      0|      }
 2155|      0|      if(report_hole)return OP_HOLE;
 2156|       |      /*If end-trimming didn't trim all the packets, we're done.*/
 2157|      0|      if(op_count>0)return 0;
 2158|      0|    }
 2159|      0|  }
 2160|      0|}
 2161|       |
 2162|      0|int op_raw_seek(OggOpusFile *_of,opus_int64 _pos){
 2163|      0|  int ret;
 2164|      0|  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;
 2165|       |  /*Don't dump the decoder state if we can't seek.*/
 2166|      0|  if(OP_UNLIKELY(!_of->seekable))return OP_ENOSEEK;
 2167|      0|  if(OP_UNLIKELY(_pos<0)||OP_UNLIKELY(_pos>_of->end))return OP_EINVAL;
 2168|       |  /*Clear out any buffered, decoded data.*/
 2169|      0|  op_decode_clear(_of);
 2170|      0|  _of->bytes_tracked=0;
 2171|      0|  _of->samples_tracked=0;
 2172|      0|  ret=op_seek_helper(_of,_pos);
 2173|      0|  if(OP_UNLIKELY(ret<0))return OP_EREAD;
 2174|      0|  ret=op_fetch_and_process_page(_of,NULL,-1,1,1);
 2175|       |  /*If we hit EOF, op_fetch_and_process_page() leaves us uninitialized.
 2176|       |    Instead, jump to the end.*/
 2177|      0|  if(ret==OP_EOF){
 2178|      0|    int cur_link;
 2179|      0|    op_decode_clear(_of);
 2180|      0|    cur_link=_of->nlinks-1;
 2181|      0|    _of->cur_link=cur_link;
 2182|      0|    _of->prev_packet_gp=_of->links[cur_link].pcm_end;
 2183|      0|    _of->cur_discard_count=0;
 2184|      0|    ret=0;
 2185|      0|  }
 2186|      0|  return ret;
 2187|      0|}
 2188|       |
 2189|       |/*Convert a PCM offset relative to the start of the whole stream to a granule
 2190|       |   position in an individual link.*/
 2191|       |static ogg_int64_t op_get_granulepos(const OggOpusFile *_of,
 2192|      0| ogg_int64_t _pcm_offset,int *_li){
 2193|      0|  const OggOpusLink *links;
 2194|      0|  ogg_int64_t        duration;
 2195|      0|  ogg_int64_t        pcm_start;
 2196|      0|  opus_int32         pre_skip;
 2197|      0|  int                nlinks;
 2198|      0|  int                li_lo;
 2199|      0|  int                li_hi;
 2200|      0|  OP_ASSERT(_pcm_offset>=0);
 2201|      0|  nlinks=_of->nlinks;
 2202|      0|  links=_of->links;
 2203|      0|  li_lo=0;
 2204|      0|  li_hi=nlinks;
 2205|      0|  do{
 2206|      0|    int li;
 2207|      0|    li=li_lo+(li_hi-li_lo>>1);
 2208|      0|    if(links[li].pcm_file_offset<=_pcm_offset)li_lo=li;
 2209|      0|    else li_hi=li;
 2210|      0|  }
 2211|      0|  while(li_hi-li_lo>1);
 2212|      0|  _pcm_offset-=links[li_lo].pcm_file_offset;
 2213|      0|  pcm_start=links[li_lo].pcm_start;
 2214|      0|  pre_skip=links[li_lo].head.pre_skip;
 2215|      0|  OP_ALWAYS_TRUE(!op_granpos_diff(&duration,links[li_lo].pcm_end,pcm_start));
 2216|      0|  duration-=pre_skip;
 2217|      0|  if(_pcm_offset>=duration)return -1;
 2218|      0|  _pcm_offset+=pre_skip;
 2219|      0|  if(OP_UNLIKELY(pcm_start>OP_INT64_MAX-_pcm_offset)){
 2220|       |    /*Adding this amount to the granule position would overflow the positive
 2221|       |       half of its 64-bit range.
 2222|       |      Since signed overflow is undefined in C, do it in a way the compiler
 2223|       |       isn't allowed to screw up.*/
 2224|      0|    _pcm_offset-=OP_INT64_MAX-pcm_start+1;
 2225|      0|    pcm_start=OP_INT64_MIN;
 2226|      0|  }
 2227|      0|  pcm_start+=_pcm_offset;
 2228|      0|  *_li=li_lo;
 2229|      0|  return pcm_start;
 2230|      0|}
 2231|       |
 2232|       |/*A small helper to determine if an Ogg page contains data that continues onto
 2233|       |   a subsequent page.*/
 2234|      0|static int op_page_continues(const ogg_page *_og){
 2235|      0|  int nlacing;
 2236|      0|  OP_ASSERT(_og->header_len>=27);
 2237|      0|  nlacing=_og->header[26];
 2238|      0|  OP_ASSERT(_og->header_len>=27+nlacing);
 2239|       |  /*This also correctly handles the (unlikely) case of nlacing==0, because
 2240|       |     0!=255.*/
 2241|      0|  return _og->header[27+nlacing-1]==255;
 2242|      0|}
 2243|       |
 2244|       |/*A small helper to buffer the continued packet data from a page.*/
 2245|      0|static void op_buffer_continued_data(OggOpusFile *_of,ogg_page *_og){
 2246|      0|  ogg_packet op;
 2247|      0|  ogg_stream_pagein(&_of->os,_og);
 2248|       |  /*Drain any packets that did end on this page (and ignore holes).
 2249|       |    We only care about the continued packet data.*/
 2250|      0|  while(ogg_stream_packetout(&_of->os,&op));
 2251|      0|}
 2252|       |
 2253|       |/*This controls how close the target has to be to use the current stream
 2254|       |   position to subdivide the initial range.
 2255|       |  Two minutes seems to be a good default.*/
 2256|      0|#define OP_CUR_TIME_THRESH (120*48*(opus_int32)1000)
 2257|       |
 2258|       |/*Note: The OP_SMALL_FOOTPRINT #define doesn't (currently) save much code size,
 2259|       |   but it's meant to serve as documentation for portions of the seeking
 2260|       |   algorithm that are purely optional, to aid others learning from/porting this
 2261|       |   code to other contexts.*/
 2262|       |/*#define OP_SMALL_FOOTPRINT (1)*/
 2263|       |
 2264|       |/*Search within link _li for the page with the highest granule position
 2265|       |   preceding (or equal to) _target_gp.
 2266|       |  There is a danger here: missing pages or incorrect frame number information
 2267|       |   in the bitstream could make our task impossible.
 2268|       |  Account for that (and report it as an error condition).*/
 2269|       |static int op_pcm_seek_page(OggOpusFile *_of,
 2270|      0| ogg_int64_t _target_gp,int _li){
 2271|      0|  const OggOpusLink *link;
 2272|      0|  ogg_page           og;
 2273|      0|  ogg_int64_t        pcm_pre_skip;
 2274|      0|  ogg_int64_t        pcm_start;
 2275|      0|  ogg_int64_t        pcm_end;
 2276|      0|  ogg_int64_t        best_gp;
 2277|      0|  ogg_int64_t        diff;
 2278|      0|  ogg_uint32_t       serialno;
 2279|      0|  opus_int32         pre_skip;
 2280|      0|  opus_int64         begin;
 2281|      0|  opus_int64         end;
 2282|      0|  opus_int64         boundary;
 2283|      0|  opus_int64         best;
 2284|      0|  opus_int64         best_start;
 2285|      0|  opus_int64         page_offset;
 2286|      0|  opus_int64         d0;
 2287|      0|  opus_int64         d1;
 2288|      0|  opus_int64         d2;
 2289|      0|  int                force_bisect;
 2290|      0|  int                buffering;
 2291|      0|  int                ret;
 2292|      0|  _of->bytes_tracked=0;
 2293|      0|  _of->samples_tracked=0;
 2294|      0|  link=_of->links+_li;
 2295|      0|  best_gp=pcm_start=link->pcm_start;
 2296|      0|  pcm_end=link->pcm_end;
 2297|      0|  serialno=link->serialno;
 2298|      0|  best=best_start=begin=link->data_offset;
 2299|      0|  page_offset=-1;
 2300|      0|  buffering=0;
 2301|       |  /*We discard the first 80 ms of data after a seek, so seek back that much
 2302|       |     farther.
 2303|       |    If we can't, simply seek to the beginning of the link.*/
 2304|      0|  if(OP_UNLIKELY(op_granpos_add(&_target_gp,_target_gp,-80*48)<0)
 2305|      0|   ||OP_UNLIKELY(op_granpos_cmp(_target_gp,pcm_start)<0)){
 2306|      0|    _target_gp=pcm_start;
 2307|      0|  }
 2308|       |  /*Special case seeking to the start of the link.*/
 2309|      0|  pre_skip=link->head.pre_skip;
 2310|      0|  OP_ALWAYS_TRUE(!op_granpos_add(&pcm_pre_skip,pcm_start,pre_skip));
 2311|      0|  if(op_granpos_cmp(_target_gp,pcm_pre_skip)<0)end=boundary=begin;
 2312|      0|  else{
 2313|      0|    end=boundary=link->end_offset;
 2314|      0|#if !defined(OP_SMALL_FOOTPRINT)
 2315|       |    /*If we were decoding from this link, we can narrow the range a bit.*/
 2316|      0|    if(_li==_of->cur_link&&_of->ready_state>=OP_INITSET){
 2317|      0|      opus_int64 offset;
 2318|      0|      int        op_count;
 2319|      0|      op_count=_of->op_count;
 2320|       |      /*The only way the offset can be invalid _and_ we can fail the granule
 2321|       |         position checks below is if someone changed the contents of the last
 2322|       |         page since we read it.
 2323|       |        We'd be within our rights to just return OP_EBADLINK in that case, but
 2324|       |         we'll simply ignore the current position instead.*/
 2325|      0|      offset=_of->offset;
 2326|      0|      if(op_count>0&&OP_LIKELY(offset<=end)){
 2327|      0|        ogg_int64_t gp;
 2328|       |        /*Make sure the timestamp is valid.
 2329|       |          The granule position might be -1 if we collected the packets from a
 2330|       |           page without a granule position after reporting a hole.*/
 2331|      0|        gp=_of->op[op_count-1].granulepos;
 2332|      0|        if(OP_LIKELY(gp!=-1)&&OP_LIKELY(op_granpos_cmp(pcm_start,gp)<0)
 2333|      0|         &&OP_LIKELY(op_granpos_cmp(pcm_end,gp)>0)){
 2334|      0|          OP_ALWAYS_TRUE(!op_granpos_diff(&diff,gp,_target_gp));
 2335|       |          /*We only actually use the current time if either
 2336|       |            a) We can cut off at least half the range, or
 2337|       |            b) We're seeking sufficiently close to the current position that
 2338|       |                it's likely to be informative.
 2339|       |            Otherwise it appears using the whole link range to estimate the
 2340|       |             first seek location gives better results, on average.*/
 2341|      0|          if(diff<0){
 2342|      0|            OP_ASSERT(offset>=begin);
 2343|      0|            if(offset-begin>=end-begin>>1||diff>-OP_CUR_TIME_THRESH){
 2344|      0|              best=begin=offset;
 2345|      0|              best_gp=pcm_start=gp;
 2346|       |              /*If we have buffered data from a continued packet, remember the
 2347|       |                 offset of the previous page's start, so that if we do wind up
 2348|       |                 having to seek back here later, we can prime the stream with
 2349|       |                 the continued packet data.
 2350|       |                With no continued packet, we remember the end of the page.*/
 2351|      0|              best_start=_of->os.body_returned<_of->os.body_fill?
 2352|      0|               _of->prev_page_offset:best;
 2353|       |              /*If there's completed packets and data in the stream state,
 2354|       |                 prev_page_offset should always be set.*/
 2355|      0|              OP_ASSERT(best_start>=0);
 2356|       |              /*Buffer any continued packet data starting from here.*/
 2357|      0|              buffering=1;
 2358|      0|            }
 2359|      0|          }
 2360|      0|          else{
 2361|      0|            ogg_int64_t prev_page_gp;
 2362|       |            /*We might get lucky and already have the packet with the target
 2363|       |               buffered.
 2364|       |              Worth checking.
 2365|       |              For very small files (with all of the data in a single page,
 2366|       |               generally 1 second or less), we can loop them continuously
 2367|       |               without seeking at all.*/
 2368|      0|            OP_ALWAYS_TRUE(!op_granpos_add(&prev_page_gp,_of->op[0].granulepos,
 2369|      0|             -op_get_packet_duration(_of->op[0].packet,_of->op[0].bytes)));
 2370|      0|            if(op_granpos_cmp(prev_page_gp,_target_gp)<=0){
 2371|       |              /*Don't call op_decode_clear(), because it will dump our
 2372|       |                 packets.*/
 2373|      0|              _of->op_pos=0;
 2374|      0|              _of->od_buffer_size=0;
 2375|      0|              _of->prev_packet_gp=prev_page_gp;
 2376|       |              /*_of->prev_page_offset already points to the right place.*/
 2377|      0|              _of->ready_state=OP_STREAMSET;
 2378|      0|              return op_make_decode_ready(_of);
 2379|      0|            }
 2380|       |            /*No such luck.
 2381|       |              Check if we can cut off at least half the range, though.*/
 2382|      0|            if(offset-begin<=end-begin>>1||diff<OP_CUR_TIME_THRESH){
 2383|       |              /*We really want the page start here, but this will do.*/
 2384|      0|              end=boundary=offset;
 2385|      0|              pcm_end=gp;
 2386|      0|            }
 2387|      0|          }
 2388|      0|        }
 2389|      0|      }
 2390|      0|    }
 2391|      0|#endif
 2392|      0|  }
 2393|       |  /*This code was originally based on the "new search algorithm by HB (Nicholas
 2394|       |     Vinen)" from libvorbisfile.
 2395|       |    It has been modified substantially since.*/
 2396|      0|  op_decode_clear(_of);
 2397|      0|  if(!buffering)ogg_stream_reset_serialno(&_of->os,serialno);
 2398|      0|  _of->cur_link=_li;
 2399|      0|  _of->ready_state=OP_STREAMSET;
 2400|       |  /*Initialize the interval size history.*/
 2401|      0|  d2=d1=d0=end-begin;
 2402|      0|  force_bisect=0;
 2403|      0|  while(begin<end){
 2404|      0|    opus_int64 bisect;
 2405|      0|    opus_int64 next_boundary;
 2406|      0|    opus_int32 chunk_size;
 2407|      0|    if(end-begin<OP_CHUNK_SIZE)bisect=begin;
 2408|      0|    else{
 2409|       |      /*Update the interval size history.*/
 2410|      0|      d0=d1>>1;
 2411|      0|      d1=d2>>1;
 2412|      0|      d2=end-begin>>1;
 2413|      0|      if(force_bisect)bisect=begin+(end-begin>>1);
 2414|      0|      else{
 2415|      0|        ogg_int64_t diff2;
 2416|      0|        OP_ALWAYS_TRUE(!op_granpos_diff(&diff,_target_gp,pcm_start));
 2417|      0|        OP_ALWAYS_TRUE(!op_granpos_diff(&diff2,pcm_end,pcm_start));
 2418|       |        /*Take a (pretty decent) guess.*/
 2419|      0|        bisect=begin+op_rescale64(diff,diff2,end-begin)-OP_CHUNK_SIZE;
 2420|      0|      }
 2421|      0|      if(bisect-OP_CHUNK_SIZE<begin)bisect=begin;
 2422|      0|      force_bisect=0;
 2423|      0|    }
 2424|      0|    if(bisect!=_of->offset){
 2425|       |      /*Discard any buffered continued packet data.*/
 2426|      0|      if(buffering)ogg_stream_reset(&_of->os);
 2427|      0|      buffering=0;
 2428|      0|      page_offset=-1;
 2429|      0|      ret=op_seek_helper(_of,bisect);
 2430|      0|      if(OP_UNLIKELY(ret<0))return ret;
 2431|      0|    }
 2432|      0|    chunk_size=OP_CHUNK_SIZE;
 2433|      0|    next_boundary=boundary;
 2434|       |    /*Now scan forward and figure out where we landed.
 2435|       |      In the ideal case, we will see a page with a granule position at or
 2436|       |       before our target, followed by a page with a granule position after our
 2437|       |       target (or the end of the search interval).
 2438|       |      Then we can just drop out and will have all of the data we need with no
 2439|       |       additional seeking.
 2440|       |      If we landed too far before, or after, we'll break out and do another
 2441|       |       bisection.*/
 2442|      0|    while(begin<end){
 2443|      0|      page_offset=op_get_next_page(_of,&og,boundary);
 2444|      0|      if(page_offset<0){
 2445|      0|        if(page_offset<OP_FALSE)return (int)page_offset;
 2446|       |        /*There are no more pages in our interval from our stream with a valid
 2447|       |           timestamp that start at position bisect or later.*/
 2448|       |        /*If we scanned the whole interval, we're done.*/
 2449|      0|        if(bisect<=begin+1)end=begin;
 2450|      0|        else{
 2451|       |          /*Otherwise, back up one chunk.
 2452|       |            First, discard any data from a continued packet.*/
 2453|      0|          if(buffering)ogg_stream_reset(&_of->os);
 2454|      0|          buffering=0;
 2455|      0|          bisect=OP_MAX(bisect-chunk_size,begin);
 2456|      0|          ret=op_seek_helper(_of,bisect);
 2457|      0|          if(OP_UNLIKELY(ret<0))return ret;
 2458|       |          /*Bump up the chunk size.*/
 2459|      0|          chunk_size=OP_MIN(2*chunk_size,OP_CHUNK_SIZE_MAX);
 2460|       |          /*If we did find a page from another stream or without a timestamp,
 2461|       |             don't read past it.*/
 2462|      0|          boundary=next_boundary;
 2463|      0|        }
 2464|      0|      }
 2465|      0|      else{
 2466|      0|        ogg_int64_t gp;
 2467|      0|        int         has_packets;
 2468|       |        /*Save the offset of the first page we found after the seek, regardless
 2469|       |           of the stream it came from or whether or not it has a timestamp.*/
 2470|      0|        next_boundary=OP_MIN(page_offset,next_boundary);
 2471|      0|        if(serialno!=(ogg_uint32_t)ogg_page_serialno(&og))continue;
 2472|      0|        has_packets=ogg_page_packets(&og)>0;
 2473|       |        /*Force the gp to -1 (as it should be per spec) if no packets end on
 2474|       |           this page.
 2475|       |          Otherwise we might get confused when we try to pull out a packet
 2476|       |           with that timestamp and can't find it.*/
 2477|      0|        gp=has_packets?ogg_page_granulepos(&og):-1;
 2478|      0|        if(gp==-1){
 2479|      0|          if(buffering){
 2480|      0|            if(OP_LIKELY(!has_packets))ogg_stream_pagein(&_of->os,&og);
 2481|      0|            else{
 2482|       |              /*If packets did end on this page, but we still didn't have a
 2483|       |                 valid granule position (in violation of the spec!), stop
 2484|       |                 buffering continued packet data.
 2485|       |                Otherwise we might continue past the packet we actually
 2486|       |                 wanted.*/
 2487|      0|              ogg_stream_reset(&_of->os);
 2488|      0|              buffering=0;
 2489|      0|            }
 2490|      0|          }
 2491|      0|          continue;
 2492|      0|        }
 2493|      0|        if(op_granpos_cmp(gp,_target_gp)<0){
 2494|       |          /*We found a page that ends before our target.
 2495|       |            Advance to the raw offset of the next page.*/
 2496|      0|          begin=_of->offset;
 2497|      0|          if(OP_UNLIKELY(op_granpos_cmp(pcm_start,gp)>0)
 2498|      0|           ||OP_UNLIKELY(op_granpos_cmp(pcm_end,gp)<0)){
 2499|       |            /*Don't let pcm_start get out of range!
 2500|       |              That could happen with an invalid timestamp.*/
 2501|      0|            break;
 2502|      0|          }
 2503|       |          /*Save the byte offset of the end of the page with this granule
 2504|       |             position.*/
 2505|      0|          best=best_start=begin;
 2506|       |          /*Buffer any data from a continued packet, if necessary.
 2507|       |            This avoids the need to seek back here if the next timestamp we
 2508|       |             encounter while scanning forward lies after our target.*/
 2509|      0|          if(buffering)ogg_stream_reset(&_of->os);
 2510|      0|          if(op_page_continues(&og)){
 2511|      0|            op_buffer_continued_data(_of,&og);
 2512|       |            /*If we have a continued packet, remember the offset of this
 2513|       |               page's start, so that if we do wind up having to seek back here
 2514|       |               later, we can prime the stream with the continued packet data.
 2515|       |              With no continued packet, we remember the end of the page.*/
 2516|      0|            best_start=page_offset;
 2517|      0|          }
 2518|       |          /*Then force buffering on, so that if a packet starts (but does not
 2519|       |             end) on the next page, we still avoid the extra seek back.*/
 2520|      0|          buffering=1;
 2521|      0|          best_gp=pcm_start=gp;
 2522|      0|          OP_ALWAYS_TRUE(!op_granpos_diff(&diff,_target_gp,pcm_start));
 2523|       |          /*If we're more than a second away from our target, break out and
 2524|       |             do another bisection.*/
 2525|      0|          if(diff>48000)break;
 2526|       |          /*Otherwise, keep scanning forward (do NOT use begin+1).*/
 2527|      0|          bisect=begin;
 2528|      0|        }
 2529|      0|        else{
 2530|       |          /*We found a page that ends after our target.*/
 2531|       |          /*If we scanned the whole interval before we found it, we're done.*/
 2532|      0|          if(bisect<=begin+1)end=begin;
 2533|      0|          else{
 2534|      0|            end=bisect;
 2535|       |            /*In later iterations, don't read past the first page we found.*/
 2536|      0|            boundary=next_boundary;
 2537|       |            /*If we're not making much progress shrinking the interval size,
 2538|       |               start forcing straight bisection to limit the worst case.*/
 2539|      0|            force_bisect=end-begin>d0*2;
 2540|       |            /*Don't let pcm_end get out of range!
 2541|       |              That could happen with an invalid timestamp.*/
 2542|      0|            if(OP_LIKELY(op_granpos_cmp(pcm_end,gp)>0)
 2543|      0|             &&OP_LIKELY(op_granpos_cmp(pcm_start,gp)<=0)){
 2544|      0|              pcm_end=gp;
 2545|      0|            }
 2546|      0|            break;
 2547|      0|          }
 2548|      0|        }
 2549|      0|      }
 2550|      0|    }
 2551|      0|  }
 2552|       |  /*Found our page.*/
 2553|      0|  OP_ASSERT(op_granpos_cmp(best_gp,pcm_start)>=0);
 2554|       |  /*Seek, if necessary.
 2555|       |    If we were buffering data from a continued packet, we should be able to
 2556|       |     continue to scan forward to get the rest of the data (even if
 2557|       |     page_offset==-1).
 2558|       |    Otherwise, we need to seek back to best_start.*/
 2559|      0|  if(!buffering){
 2560|      0|    if(best_start!=page_offset){
 2561|      0|      page_offset=-1;
 2562|      0|      ret=op_seek_helper(_of,best_start);
 2563|      0|      if(OP_UNLIKELY(ret<0))return ret;
 2564|      0|    }
 2565|      0|    if(best_start<best){
 2566|       |      /*Retrieve the page at best_start, if we do not already have it.*/
 2567|      0|      if(page_offset<0){
 2568|      0|        page_offset=op_get_next_page(_of,&og,link->end_offset);
 2569|      0|        if(OP_UNLIKELY(page_offset<OP_FALSE))return (int)page_offset;
 2570|      0|        if(OP_UNLIKELY(page_offset!=best_start))return OP_EBADLINK;
 2571|      0|      }
 2572|      0|      op_buffer_continued_data(_of,&og);
 2573|      0|      page_offset=-1;
 2574|      0|    }
 2575|      0|  }
 2576|       |  /*Update prev_packet_gp to allow per-packet granule position assignment.*/
 2577|      0|  _of->prev_packet_gp=best_gp;
 2578|      0|  _of->prev_page_offset=best_start;
 2579|      0|  ret=op_fetch_and_process_page(_of,page_offset<0?NULL:&og,page_offset,0,1);
 2580|      0|  if(OP_UNLIKELY(ret<0))return OP_EBADLINK;
 2581|       |  /*Verify result.*/
 2582|      0|  if(OP_UNLIKELY(op_granpos_cmp(_of->prev_packet_gp,_target_gp)>0)){
 2583|      0|    return OP_EBADLINK;
 2584|      0|  }
 2585|       |  /*Our caller will set cur_discard_count to handle pre-roll.*/
 2586|      0|  return 0;
 2587|      0|}
 2588|       |
 2589|      0|int op_pcm_seek(OggOpusFile *_of,ogg_int64_t _pcm_offset){
 2590|      0|  const OggOpusLink *link;
 2591|      0|  ogg_int64_t        pcm_start;
 2592|      0|  ogg_int64_t        target_gp;
 2593|      0|  ogg_int64_t        prev_packet_gp;
 2594|      0|  ogg_int64_t        skip;
 2595|      0|  ogg_int64_t        diff;
 2596|      0|  int                op_count;
 2597|      0|  int                op_pos;
 2598|      0|  int                ret;
 2599|      0|  int                li;
 2600|      0|  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;
 2601|      0|  if(OP_UNLIKELY(!_of->seekable))return OP_ENOSEEK;
 2602|      0|  if(OP_UNLIKELY(_pcm_offset<0))return OP_EINVAL;
 2603|      0|  target_gp=op_get_granulepos(_of,_pcm_offset,&li);
 2604|      0|  if(OP_UNLIKELY(target_gp==-1))return OP_EINVAL;
 2605|      0|  link=_of->links+li;
 2606|      0|  pcm_start=link->pcm_start;
 2607|      0|  OP_ALWAYS_TRUE(!op_granpos_diff(&_pcm_offset,target_gp,pcm_start));
 2608|      0|#if !defined(OP_SMALL_FOOTPRINT)
 2609|       |  /*For small (90 ms or less) forward seeks within the same link, just decode
 2610|       |     forward.
 2611|       |    This also optimizes the case of seeking to the current position.*/
 2612|      0|  if(li==_of->cur_link&&_of->ready_state>=OP_INITSET){
 2613|      0|    ogg_int64_t gp;
 2614|      0|    gp=_of->prev_packet_gp;
 2615|      0|    if(OP_LIKELY(gp!=-1)){
 2616|      0|      ogg_int64_t discard_count;
 2617|      0|      int         nbuffered;
 2618|      0|      nbuffered=OP_MAX(_of->od_buffer_size-_of->od_buffer_pos,0);
 2619|      0|      OP_ALWAYS_TRUE(!op_granpos_add(&gp,gp,-nbuffered));
 2620|       |      /*We do _not_ add cur_discard_count to gp.
 2621|       |        Otherwise the total amount to discard could grow without bound, and it
 2622|       |         would be better just to do a full seek.*/
 2623|      0|      if(OP_LIKELY(!op_granpos_diff(&discard_count,target_gp,gp))){
 2624|       |        /*We use a threshold of 90 ms instead of 80, since 80 ms is the
 2625|       |           _minimum_ we would have discarded after a full seek.
 2626|       |          Assuming 20 ms frames (the default), we'd discard 90 ms on average.*/
 2627|      0|        if(discard_count>=0&&OP_UNLIKELY(discard_count<90*48)){
 2628|      0|          _of->cur_discard_count=(opus_int32)discard_count;
 2629|      0|          return 0;
 2630|      0|        }
 2631|      0|      }
 2632|      0|    }
 2633|      0|  }
 2634|      0|#endif
 2635|      0|  ret=op_pcm_seek_page(_of,target_gp,li);
 2636|      0|  if(OP_UNLIKELY(ret<0))return ret;
 2637|       |  /*Now skip samples until we actually get to our target.*/
 2638|       |  /*Figure out where we should skip to.*/
 2639|      0|  if(_pcm_offset<=link->head.pre_skip)skip=0;
 2640|      0|  else skip=OP_MAX(_pcm_offset-80*48,0);
 2641|      0|  OP_ASSERT(_pcm_offset-skip>=0);
 2642|      0|  OP_ASSERT(_pcm_offset-skip<OP_INT32_MAX-120*48);
 2643|       |  /*Skip packets until we find one with samples past our skip target.*/
 2644|      0|  for(;;){
 2645|      0|    op_count=_of->op_count;
 2646|      0|    prev_packet_gp=_of->prev_packet_gp;
 2647|      0|    for(op_pos=_of->op_pos;op_pos<op_count;op_pos++){
 2648|      0|      ogg_int64_t cur_packet_gp;
 2649|      0|      cur_packet_gp=_of->op[op_pos].granulepos;
 2650|      0|      if(OP_LIKELY(!op_granpos_diff(&diff,cur_packet_gp,pcm_start))
 2651|      0|       &&diff>skip){
 2652|      0|        break;
 2653|      0|      }
 2654|      0|      prev_packet_gp=cur_packet_gp;
 2655|      0|    }
 2656|      0|    _of->prev_packet_gp=prev_packet_gp;
 2657|      0|    _of->op_pos=op_pos;
 2658|      0|    if(op_pos<op_count)break;
 2659|       |    /*We skipped all the packets on this page.
 2660|       |      Fetch another.*/
 2661|      0|    ret=op_fetch_and_process_page(_of,NULL,-1,0,1);
 2662|      0|    if(OP_UNLIKELY(ret<0))return OP_EBADLINK;
 2663|      0|  }
 2664|       |  /*We skipped too far, or couldn't get within 2 billion samples of the target.
 2665|       |    Either the timestamps were illegal or there was a hole in the data.*/
 2666|      0|  if(op_granpos_diff(&diff,prev_packet_gp,pcm_start)||diff>skip
 2667|      0|   ||_pcm_offset-diff>=OP_INT32_MAX){
 2668|      0|    return OP_EBADLINK;
 2669|      0|  }
 2670|       |  /*TODO: If there are further holes/illegal timestamps, we still won't decode
 2671|       |     to the correct sample.
 2672|       |    However, at least op_pcm_tell() will report the correct value immediately
 2673|       |     after returning.*/
 2674|      0|  _of->cur_discard_count=(opus_int32)(_pcm_offset-diff);
 2675|      0|  return 0;
 2676|      0|}
 2677|       |
 2678|      0|opus_int64 op_raw_tell(const OggOpusFile *_of){
 2679|      0|  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;
 2680|      0|  return _of->offset;
 2681|      0|}
 2682|       |
 2683|       |/*Convert a granule position from a given link to a PCM offset relative to the
 2684|       |   start of the whole stream.
 2685|       |  For unseekable sources, this gets reset to 0 at the beginning of each link.*/
 2686|       |static ogg_int64_t op_get_pcm_offset(const OggOpusFile *_of,
 2687|      0| ogg_int64_t _gp,int _li){
 2688|      0|  const OggOpusLink *links;
 2689|      0|  ogg_int64_t        pcm_offset;
 2690|      0|  links=_of->links;
 2691|      0|  OP_ASSERT(_li>=0&&_li<_of->nlinks);
 2692|      0|  pcm_offset=links[_li].pcm_file_offset;
 2693|      0|  if(_of->seekable&&OP_UNLIKELY(op_granpos_cmp(_gp,links[_li].pcm_end)>0)){
 2694|      0|    _gp=links[_li].pcm_end;
 2695|      0|  }
 2696|      0|  if(OP_LIKELY(op_granpos_cmp(_gp,links[_li].pcm_start)>0)){
 2697|      0|    ogg_int64_t delta;
 2698|      0|    if(OP_UNLIKELY(op_granpos_diff(&delta,_gp,links[_li].pcm_start)<0)){
 2699|       |      /*This means an unseekable stream claimed to have a page from more than
 2700|       |         2 billion days after we joined.*/
 2701|      0|      OP_ASSERT(!_of->seekable);
 2702|      0|      return OP_INT64_MAX;
 2703|      0|    }
 2704|      0|    if(delta<links[_li].head.pre_skip)delta=0;
 2705|      0|    else delta-=links[_li].head.pre_skip;
 2706|       |    /*In the seekable case, _gp was limited by pcm_end.
 2707|       |      In the unseekable case, pcm_offset should be 0.*/
 2708|      0|    OP_ASSERT(pcm_offset<=OP_INT64_MAX-delta);
 2709|      0|    pcm_offset+=delta;
 2710|      0|  }
 2711|      0|  return pcm_offset;
 2712|      0|}
 2713|       |
 2714|      0|ogg_int64_t op_pcm_tell(const OggOpusFile *_of){
 2715|      0|  ogg_int64_t gp;
 2716|      0|  int         nbuffered;
 2717|      0|  int         li;
 2718|      0|  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;
 2719|      0|  gp=_of->prev_packet_gp;
 2720|      0|  if(gp==-1)return 0;
 2721|      0|  nbuffered=OP_MAX(_of->od_buffer_size-_of->od_buffer_pos,0);
 2722|      0|  OP_ALWAYS_TRUE(!op_granpos_add(&gp,gp,-nbuffered));
 2723|      0|  li=_of->seekable?_of->cur_link:0;
 2724|      0|  if(op_granpos_add(&gp,gp,_of->cur_discard_count)<0){
 2725|      0|    gp=_of->links[li].pcm_end;
 2726|      0|  }
 2727|      0|  return op_get_pcm_offset(_of,gp,li);
 2728|      0|}
 2729|       |
 2730|       |void op_set_decode_callback(OggOpusFile *_of,
 2731|      0| op_decode_cb_func _decode_cb,void *_ctx){
 2732|      0|  _of->decode_cb=_decode_cb;
 2733|      0|  _of->decode_cb_ctx=_ctx;
 2734|      0|}
 2735|       |
 2736|       |int op_set_gain_offset(OggOpusFile *_of,
 2737|      0| int _gain_type,opus_int32 _gain_offset_q8){
 2738|      0|  if(_gain_type!=OP_HEADER_GAIN&&_gain_type!=OP_ALBUM_GAIN
 2739|      0|   &&_gain_type!=OP_TRACK_GAIN&&_gain_type!=OP_ABSOLUTE_GAIN){
 2740|      0|    return OP_EINVAL;
 2741|      0|  }
 2742|      0|  _of->gain_type=_gain_type;
 2743|       |  /*The sum of header gain and track gain lies in the range [-65536,65534].
 2744|       |    These bounds allow the offset to set the final value to anywhere in the
 2745|       |     range [-32768,32767], which is what we'll clamp it to before applying.*/
 2746|      0|  _of->gain_offset_q8=OP_CLAMP(-98302,_gain_offset_q8,98303);
 2747|      0|  op_update_gain(_of);
 2748|      0|  return 0;
 2749|      0|}
 2750|       |
 2751|      0|void op_set_dither_enabled(OggOpusFile *_of,int _enabled){
 2752|      0|#if !defined(OP_FIXED_POINT)
 2753|      0|  _of->dither_disabled=!_enabled;
 2754|      0|  if(!_enabled)_of->dither_mute=65;
 2755|      0|#endif
 2756|      0|}
 2757|       |
 2758|       |/*Allocate the decoder scratch buffer.
 2759|       |  This is done lazily, since if the user provides large enough buffers, we'll
 2760|       |   never need it.*/
 2761|      0|static int op_init_buffer(OggOpusFile *_of){
 2762|      0|  int nchannels_max;
 2763|      0|  if(_of->seekable){
 2764|      0|    const OggOpusLink *links;
 2765|      0|    int                nlinks;
 2766|      0|    int                li;
 2767|      0|    links=_of->links;
 2768|      0|    nlinks=_of->nlinks;
 2769|      0|    nchannels_max=1;
 2770|      0|    for(li=0;li<nlinks;li++){
 2771|      0|      nchannels_max=OP_MAX(nchannels_max,links[li].head.channel_count);
 2772|      0|    }
 2773|      0|  }
 2774|      0|  else nchannels_max=OP_NCHANNELS_MAX;
 2775|      0|  _of->od_buffer=(op_sample *)_ogg_malloc(
 2776|      0|   sizeof(*_of->od_buffer)*nchannels_max*120*48);
 2777|      0|  if(_of->od_buffer==NULL)return OP_EFAULT;
 2778|      0|  return 0;
 2779|      0|}
 2780|       |
 2781|       |/*Decode a single packet into the target buffer.*/
 2782|       |static int op_decode(OggOpusFile *_of,op_sample *_pcm,
 2783|      0| const ogg_packet *_op,int _nsamples,int _nchannels){
 2784|      0|  int ret;
 2785|       |  /*First we try using the application-provided decode callback.*/
 2786|      0|  if(_of->decode_cb!=NULL){
 2787|       |#if defined(OP_FIXED_POINT)
 2788|       |    ret=(*_of->decode_cb)(_of->decode_cb_ctx,_of->od,_pcm,_op,
 2789|       |     _nsamples,_nchannels,OP_DEC_FORMAT_SHORT,_of->cur_link);
 2790|       |#else
 2791|      0|    ret=(*_of->decode_cb)(_of->decode_cb_ctx,_of->od,_pcm,_op,
 2792|      0|     _nsamples,_nchannels,OP_DEC_FORMAT_FLOAT,_of->cur_link);
 2793|      0|#endif
 2794|      0|  }
 2795|      0|  else ret=OP_DEC_USE_DEFAULT;
 2796|       |  /*If the application didn't want to handle decoding, do it ourselves.*/
 2797|      0|  if(ret==OP_DEC_USE_DEFAULT){
 2798|       |#if defined(OP_FIXED_POINT)
 2799|       |    ret=opus_multistream_decode(_of->od,
 2800|       |     _op->packet,_op->bytes,_pcm,_nsamples,0);
 2801|       |#else
 2802|      0|    ret=opus_multistream_decode_float(_of->od,
 2803|      0|     _op->packet,_op->bytes,_pcm,_nsamples,0);
 2804|      0|#endif
 2805|      0|    OP_ASSERT(ret<0||ret==_nsamples);
 2806|      0|  }
 2807|       |  /*If the application returned a positive value other than 0 or
 2808|       |     OP_DEC_USE_DEFAULT, fail.*/
 2809|      0|  else if(OP_UNLIKELY(ret>0))return OP_EBADPACKET;
 2810|      0|  if(OP_UNLIKELY(ret<0))return OP_EBADPACKET;
 2811|      0|  return ret;
 2812|      0|}
 2813|       |
 2814|       |/*Read more samples from the stream, using the same API as op_read() or
 2815|       |   op_read_float().*/
 2816|       |static int op_read_native(OggOpusFile *_of,
 2817|      0| op_sample *_pcm,int _buf_size,int *_li){
 2818|      0|  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;
 2819|      0|  for(;;){
 2820|      0|    int ret;
 2821|      0|    if(OP_LIKELY(_of->ready_state>=OP_INITSET)){
 2822|      0|      int nchannels;
 2823|      0|      int od_buffer_pos;
 2824|      0|      int nsamples;
 2825|      0|      int op_pos;
 2826|      0|      nchannels=_of->links[_of->seekable?_of->cur_link:0].head.channel_count;
 2827|      0|      od_buffer_pos=_of->od_buffer_pos;
 2828|      0|      nsamples=_of->od_buffer_size-od_buffer_pos;
 2829|       |      /*If we have buffered samples, return them.*/
 2830|      0|      if(nsamples>0){
 2831|      0|        if(nsamples*nchannels>_buf_size)nsamples=_buf_size/nchannels;
 2832|      0|        OP_ASSERT(_pcm!=NULL||nsamples<=0);
 2833|       |        /*Check nsamples again so we don't pass NULL to memcpy() if _buf_size
 2834|       |           is zero.
 2835|       |          That would technically be undefined behavior, even if the number of
 2836|       |           bytes to copy were zero.*/
 2837|      0|        if(nsamples>0){
 2838|      0|          memcpy(_pcm,_of->od_buffer+nchannels*od_buffer_pos,
 2839|      0|           sizeof(*_pcm)*nchannels*nsamples);
 2840|      0|          od_buffer_pos+=nsamples;
 2841|      0|          _of->od_buffer_pos=od_buffer_pos;
 2842|      0|        }
 2843|      0|        if(_li!=NULL)*_li=_of->cur_link;
 2844|      0|        return nsamples;
 2845|      0|      }
 2846|       |      /*If we have buffered packets, decode one.*/
 2847|      0|      op_pos=_of->op_pos;
 2848|      0|      if(OP_LIKELY(op_pos<_of->op_count)){
 2849|      0|        const ogg_packet *pop;
 2850|      0|        ogg_int64_t       diff;
 2851|      0|        opus_int32        cur_discard_count;
 2852|      0|        int               duration;
 2853|      0|        int               trimmed_duration;
 2854|      0|        pop=_of->op+op_pos++;
 2855|      0|        _of->op_pos=op_pos;
 2856|      0|        cur_discard_count=_of->cur_discard_count;
 2857|      0|        duration=op_get_packet_duration(pop->packet,pop->bytes);
 2858|       |        /*We don't buffer packets with an invalid TOC sequence.*/
 2859|      0|        OP_ASSERT(duration>0);
 2860|      0|        trimmed_duration=duration;
 2861|       |        /*Perform end-trimming.*/
 2862|      0|        if(OP_UNLIKELY(pop->e_o_s)){
 2863|      0|          if(OP_UNLIKELY(op_granpos_cmp(pop->granulepos,
 2864|      0|           _of->prev_packet_gp)<=0)){
 2865|      0|            trimmed_duration=0;
 2866|      0|          }
 2867|      0|          else if(OP_LIKELY(!op_granpos_diff(&diff,
 2868|      0|           pop->granulepos,_of->prev_packet_gp))){
 2869|      0|            trimmed_duration=(int)OP_MIN(diff,trimmed_duration);
 2870|      0|          }
 2871|      0|        }
 2872|      0|        _of->prev_packet_gp=pop->granulepos;
 2873|      0|        if(OP_UNLIKELY(duration*nchannels>_buf_size)){
 2874|      0|          op_sample *buf;
 2875|       |          /*If the user's buffer is too small, decode into a scratch buffer.*/
 2876|      0|          buf=_of->od_buffer;
 2877|      0|          if(OP_UNLIKELY(buf==NULL)){
 2878|      0|            ret=op_init_buffer(_of);
 2879|      0|            if(OP_UNLIKELY(ret<0))return ret;
 2880|      0|            buf=_of->od_buffer;
 2881|      0|          }
 2882|      0|          ret=op_decode(_of,buf,pop,duration,nchannels);
 2883|      0|          if(OP_UNLIKELY(ret<0))return ret;
 2884|       |          /*Perform pre-skip/pre-roll.*/
 2885|      0|          od_buffer_pos=(int)OP_MIN(trimmed_duration,cur_discard_count);
 2886|      0|          cur_discard_count-=od_buffer_pos;
 2887|      0|          _of->cur_discard_count=cur_discard_count;
 2888|      0|          _of->od_buffer_pos=od_buffer_pos;
 2889|      0|          _of->od_buffer_size=trimmed_duration;
 2890|       |          /*Update bitrate tracking based on the actual samples we used from
 2891|       |             what was decoded.*/
 2892|      0|          _of->bytes_tracked+=pop->bytes;
 2893|      0|          _of->samples_tracked+=trimmed_duration-od_buffer_pos;
 2894|      0|        }
 2895|      0|        else{
 2896|      0|          OP_ASSERT(_pcm!=NULL);
 2897|       |          /*Otherwise decode directly into the user's buffer.*/
 2898|      0|          ret=op_decode(_of,_pcm,pop,duration,nchannels);
 2899|      0|          if(OP_UNLIKELY(ret<0))return ret;
 2900|      0|          if(OP_LIKELY(trimmed_duration>0)){
 2901|       |            /*Perform pre-skip/pre-roll.*/
 2902|      0|            od_buffer_pos=(int)OP_MIN(trimmed_duration,cur_discard_count);
 2903|      0|            cur_discard_count-=od_buffer_pos;
 2904|      0|            _of->cur_discard_count=cur_discard_count;
 2905|      0|            trimmed_duration-=od_buffer_pos;
 2906|      0|            if(OP_LIKELY(trimmed_duration>0)
 2907|      0|             &&OP_UNLIKELY(od_buffer_pos>0)){
 2908|      0|              memmove(_pcm,_pcm+od_buffer_pos*nchannels,
 2909|      0|               sizeof(*_pcm)*trimmed_duration*nchannels);
 2910|      0|            }
 2911|       |            /*Update bitrate tracking based on the actual samples we used from
 2912|       |               what was decoded.*/
 2913|      0|            _of->bytes_tracked+=pop->bytes;
 2914|      0|            _of->samples_tracked+=trimmed_duration;
 2915|      0|            if(OP_LIKELY(trimmed_duration>0)){
 2916|      0|              if(_li!=NULL)*_li=_of->cur_link;
 2917|      0|              return trimmed_duration;
 2918|      0|            }
 2919|      0|          }
 2920|      0|        }
 2921|       |        /*Don't grab another page yet.
 2922|       |          This one might have more packets, or might have buffered data now.*/
 2923|      0|        continue;
 2924|      0|      }
 2925|      0|    }
 2926|       |    /*Suck in another page.*/
 2927|      0|    ret=op_fetch_and_process_page(_of,NULL,-1,1,0);
 2928|      0|    if(OP_UNLIKELY(ret==OP_EOF)){
 2929|      0|      if(_li!=NULL)*_li=_of->cur_link;
 2930|      0|      return 0;
 2931|      0|    }
 2932|      0|    if(OP_UNLIKELY(ret<0))return ret;
 2933|      0|  }
 2934|      0|}
 2935|       |
 2936|       |/*A generic filter to apply to the decoded audio data.
 2937|       |  _src is non-const because we will destructively modify the contents of the
 2938|       |   source buffer that we consume in some cases.*/
 2939|       |typedef int (*op_read_filter_func)(OggOpusFile *_of,void *_dst,int _dst_sz,
 2940|       | op_sample *_src,int _nsamples,int _nchannels);
 2941|       |
 2942|       |/*Decode some samples and then apply a custom filter to them.
 2943|       |  This is used to convert to different output formats.*/
 2944|       |static int op_filter_read_native(OggOpusFile *_of,void *_dst,int _dst_sz,
 2945|      0| op_read_filter_func _filter,int *_li){
 2946|      0|  int ret;
 2947|       |  /*Ensure we have some decoded samples in our buffer.*/
 2948|      0|  ret=op_read_native(_of,NULL,0,_li);
 2949|       |  /*Now apply the filter to them.*/
 2950|      0|  if(OP_LIKELY(ret>=0)&&OP_LIKELY(_of->ready_state>=OP_INITSET)){
 2951|      0|    int od_buffer_pos;
 2952|      0|    od_buffer_pos=_of->od_buffer_pos;
 2953|      0|    ret=_of->od_buffer_size-od_buffer_pos;
 2954|      0|    if(OP_LIKELY(ret>0)){
 2955|      0|      int nchannels;
 2956|      0|      nchannels=_of->links[_of->seekable?_of->cur_link:0].head.channel_count;
 2957|      0|      ret=(*_filter)(_of,_dst,_dst_sz,
 2958|      0|       _of->od_buffer+nchannels*od_buffer_pos,ret,nchannels);
 2959|      0|      OP_ASSERT(ret>=0);
 2960|      0|      OP_ASSERT(ret<=_of->od_buffer_size-od_buffer_pos);
 2961|      0|      od_buffer_pos+=ret;
 2962|      0|      _of->od_buffer_pos=od_buffer_pos;
 2963|      0|    }
 2964|      0|  }
 2965|      0|  return ret;
 2966|      0|}
 2967|       |
 2968|       |#if !defined(OP_FIXED_POINT)||!defined(OP_DISABLE_FLOAT_API)
 2969|       |
 2970|       |/*Matrices for downmixing from the supported channel counts to stereo.
 2971|       |  The matrices with 5 or more channels are normalized to a total volume of 2.0,
 2972|       |   since most mixes sound too quiet if normalized to 1.0 (as there is generally
 2973|       |   little volume in the side/rear channels).*/
 2974|       |static const float OP_STEREO_DOWNMIX[OP_NCHANNELS_MAX-2][OP_NCHANNELS_MAX][2]={
 2975|       |  /*3.0*/
 2976|       |  {
 2977|       |    {0.5858F,0.0F},{0.4142F,0.4142F},{0.0F,0.5858F}
 2978|       |  },
 2979|       |  /*quadrophonic*/
 2980|       |  {
 2981|       |    {0.4226F,0.0F},{0.0F,0.4226F},{0.366F,0.2114F},{0.2114F,0.336F}
 2982|       |  },
 2983|       |  /*5.0*/
 2984|       |  {
 2985|       |    {0.651F,0.0F},{0.46F,0.46F},{0.0F,0.651F},{0.5636F,0.3254F},
 2986|       |    {0.3254F,0.5636F}
 2987|       |  },
 2988|       |  /*5.1*/
 2989|       |  {
 2990|       |    {0.529F,0.0F},{0.3741F,0.3741F},{0.0F,0.529F},{0.4582F,0.2645F},
 2991|       |    {0.2645F,0.4582F},{0.3741F,0.3741F}
 2992|       |  },
 2993|       |  /*6.1*/
 2994|       |  {
 2995|       |    {0.4553F,0.0F},{0.322F,0.322F},{0.0F,0.4553F},{0.3943F,0.2277F},
 2996|       |    {0.2277F,0.3943F},{0.2788F,0.2788F},{0.322F,0.322F}
 2997|       |  },
 2998|       |  /*7.1*/
 2999|       |  {
 3000|       |    {0.3886F,0.0F},{0.2748F,0.2748F},{0.0F,0.3886F},{0.3366F,0.1943F},
 3001|       |    {0.1943F,0.3366F},{0.3366F,0.1943F},{0.1943F,0.3366F},{0.2748F,0.2748F}
 3002|       |  }
 3003|       |};
 3004|       |
 3005|       |#endif
 3006|       |
 3007|       |#if defined(OP_FIXED_POINT)
 3008|       |
 3009|       |/*Matrices for downmixing from the supported channel counts to stereo.
 3010|       |  The matrices with 5 or more channels are normalized to a total volume of 2.0,
 3011|       |   since most mixes sound too quiet if normalized to 1.0 (as there is generally
 3012|       |   little volume in the side/rear channels).
 3013|       |  Hence we keep the coefficients in Q14, so the downmix values won't overflow a
 3014|       |   32-bit number.*/
 3015|       |static const opus_int16 OP_STEREO_DOWNMIX_Q14
 3016|       | [OP_NCHANNELS_MAX-2][OP_NCHANNELS_MAX][2]={
 3017|       |  /*3.0*/
 3018|       |  {
 3019|       |    {9598,0},{6786,6786},{0,9598}
 3020|       |  },
 3021|       |  /*quadrophonic*/
 3022|       |  {
 3023|       |    {6924,0},{0,6924},{5996,3464},{3464,5996}
 3024|       |  },
 3025|       |  /*5.0*/
 3026|       |  {
 3027|       |    {10666,0},{7537,7537},{0,10666},{9234,5331},{5331,9234}
 3028|       |  },
 3029|       |  /*5.1*/
 3030|       |  {
 3031|       |    {8668,0},{6129,6129},{0,8668},{7507,4335},{4335,7507},{6129,6129}
 3032|       |  },
 3033|       |  /*6.1*/
 3034|       |  {
 3035|       |    {7459,0},{5275,5275},{0,7459},{6460,3731},{3731,6460},{4568,4568},
 3036|       |    {5275,5275}
 3037|       |  },
 3038|       |  /*7.1*/
 3039|       |  {
 3040|       |    {6368,0},{4502,4502},{0,6368},{5515,3183},{3183,5515},{5515,3183},
 3041|       |    {3183,5515},{4502,4502}
 3042|       |  }
 3043|       |};
 3044|       |
 3045|       |int op_read(OggOpusFile *_of,opus_int16 *_pcm,int _buf_size,int *_li){
 3046|       |  return op_read_native(_of,_pcm,_buf_size,_li);
 3047|       |}
 3048|       |
 3049|       |static int op_stereo_filter(OggOpusFile *_of,void *_dst,int _dst_sz,
 3050|       | op_sample *_src,int _nsamples,int _nchannels){
 3051|       |  (void)_of;
 3052|       |  _nsamples=OP_MIN(_nsamples,_dst_sz>>1);
 3053|       |  if(_nchannels==2)memcpy(_dst,_src,_nsamples*2*sizeof(*_src));
 3054|       |  else{
 3055|       |    opus_int16 *dst;
 3056|       |    int         i;
 3057|       |    dst=(opus_int16 *)_dst;
 3058|       |    if(_nchannels==1){
 3059|       |      for(i=0;i<_nsamples;i++)dst[2*i+0]=dst[2*i+1]=_src[i];
 3060|       |    }
 3061|       |    else{
 3062|       |      for(i=0;i<_nsamples;i++){
 3063|       |        opus_int32 l;
 3064|       |        opus_int32 r;
 3065|       |        int        ci;
 3066|       |        l=r=0;
 3067|       |        for(ci=0;ci<_nchannels;ci++){
 3068|       |          opus_int32 s;
 3069|       |          s=_src[_nchannels*i+ci];
 3070|       |          l+=OP_STEREO_DOWNMIX_Q14[_nchannels-3][ci][0]*s;
 3071|       |          r+=OP_STEREO_DOWNMIX_Q14[_nchannels-3][ci][1]*s;
 3072|       |        }
 3073|       |        /*TODO: For 5 or more channels, we should do soft clipping here.*/
 3074|       |        dst[2*i+0]=(opus_int16)OP_CLAMP(-32768,l+8192>>14,32767);
 3075|       |        dst[2*i+1]=(opus_int16)OP_CLAMP(-32768,r+8192>>14,32767);
 3076|       |      }
 3077|       |    }
 3078|       |  }
 3079|       |  return _nsamples;
 3080|       |}
 3081|       |
 3082|       |int op_read_stereo(OggOpusFile *_of,opus_int16 *_pcm,int _buf_size){
 3083|       |  return op_filter_read_native(_of,_pcm,_buf_size,op_stereo_filter,NULL);
 3084|       |}
 3085|       |
 3086|       |# if !defined(OP_DISABLE_FLOAT_API)
 3087|       |
 3088|       |static int op_short2float_filter(OggOpusFile *_of,void *_dst,int _dst_sz,
 3089|       | op_sample *_src,int _nsamples,int _nchannels){
 3090|       |  float *dst;
 3091|       |  int    i;
 3092|       |  (void)_of;
 3093|       |  dst=(float *)_dst;
 3094|       |  if(OP_UNLIKELY(_nsamples*_nchannels>_dst_sz))_nsamples=_dst_sz/_nchannels;
 3095|       |  _dst_sz=_nsamples*_nchannels;
 3096|       |  for(i=0;i<_dst_sz;i++)dst[i]=(1.0F/32768)*_src[i];
 3097|       |  return _nsamples;
 3098|       |}
 3099|       |
 3100|       |int op_read_float(OggOpusFile *_of,float *_pcm,int _buf_size,int *_li){
 3101|       |  return op_filter_read_native(_of,_pcm,_buf_size,op_short2float_filter,_li);
 3102|       |}
 3103|       |
 3104|       |static int op_short2float_stereo_filter(OggOpusFile *_of,
 3105|       | void *_dst,int _dst_sz,op_sample *_src,int _nsamples,int _nchannels){
 3106|       |  float *dst;
 3107|       |  int    i;
 3108|       |  dst=(float *)_dst;
 3109|       |  _nsamples=OP_MIN(_nsamples,_dst_sz>>1);
 3110|       |  if(_nchannels==1){
 3111|       |    _nsamples=op_short2float_filter(_of,dst,_nsamples,_src,_nsamples,1);
 3112|       |    for(i=_nsamples;i-->0;)dst[2*i+0]=dst[2*i+1]=dst[i];
 3113|       |  }
 3114|       |  else if(_nchannels<5){
 3115|       |    /*For 3 or 4 channels, we can downmix in fixed point without risk of
 3116|       |       clipping.*/
 3117|       |    if(_nchannels>2){
 3118|       |      _nsamples=op_stereo_filter(_of,_src,_nsamples*2,
 3119|       |       _src,_nsamples,_nchannels);
 3120|       |    }
 3121|       |    return op_short2float_filter(_of,dst,_dst_sz,_src,_nsamples,2);
 3122|       |  }
 3123|       |  else{
 3124|       |    /*For 5 or more channels, we convert to floats and then downmix (so that we
 3125|       |       don't risk clipping).*/
 3126|       |    for(i=0;i<_nsamples;i++){
 3127|       |      float l;
 3128|       |      float r;
 3129|       |      int   ci;
 3130|       |      l=r=0;
 3131|       |      for(ci=0;ci<_nchannels;ci++){
 3132|       |        float s;
 3133|       |        s=(1.0F/32768)*_src[_nchannels*i+ci];
 3134|       |        l+=OP_STEREO_DOWNMIX[_nchannels-3][ci][0]*s;
 3135|       |        r+=OP_STEREO_DOWNMIX[_nchannels-3][ci][1]*s;
 3136|       |      }
 3137|       |      dst[2*i+0]=l;
 3138|       |      dst[2*i+1]=r;
 3139|       |    }
 3140|       |  }
 3141|       |  return _nsamples;
 3142|       |}
 3143|       |
 3144|       |int op_read_float_stereo(OggOpusFile *_of,float *_pcm,int _buf_size){
 3145|       |  return op_filter_read_native(_of,_pcm,_buf_size,
 3146|       |   op_short2float_stereo_filter,NULL);
 3147|       |}
 3148|       |
 3149|       |# endif
 3150|       |
 3151|       |#else
 3152|       |
 3153|       |# if defined(OP_HAVE_LRINTF)
 3154|       |#  include <math.h>
 3155|      0|#  define op_float2int(_x) (lrintf(_x))
 3156|       |# else
 3157|       |#  define op_float2int(_x) ((int)((_x)+((_x)<0?-0.5F:0.5F)))
 3158|       |# endif
 3159|       |
 3160|       |/*The dithering code here is adapted from opusdec, part of opus-tools.
 3161|       |  It was originally written by Greg Maxwell.*/
 3162|       |
 3163|      0|static opus_uint32 op_rand(opus_uint32 _seed){
 3164|      0|  return _seed*96314165+907633515&0xFFFFFFFFU;
 3165|      0|}
 3166|       |
 3167|       |/*This implements 16-bit quantization with full triangular dither and IIR noise
 3168|       |   shaping.
 3169|       |  The noise shaping filters were designed by Sebastian Gesemann, and are based
 3170|       |   on the LAME ATH curves with flattening to limit their peak gain to 20 dB.
 3171|       |  Everyone else's noise shaping filters are mildly crazy.
 3172|       |  The 48 kHz version of this filter is just a warped version of the 44.1 kHz
 3173|       |   filter and probably could be improved by shifting the HF shelf up in
 3174|       |   frequency a little bit, since 48 kHz has a bit more room and being more
 3175|       |   conservative against bat-ears is probably more important than more noise
 3176|       |   suppression.
 3177|       |  This process can increase the peak level of the signal (in theory by the peak
 3178|       |   error of 1.5 +20 dB, though that is unobservably rare).
 3179|       |  To avoid clipping, the signal is attenuated by a couple thousandths of a dB.
 3180|       |  Initially, the approach taken here was to only attenuate by the 99.9th
 3181|       |   percentile, making clipping rare but not impossible (like SoX), but the
 3182|       |   limited gain of the filter means that the worst case was only two
 3183|       |   thousandths of a dB more, so this just uses the worst case.
 3184|       |  The attenuation is probably also helpful to prevent clipping in the DAC
 3185|       |   reconstruction filters or downstream resampling, in any case.*/
 3186|       |
 3187|      0|# define OP_GAIN (32753.0F)
 3188|       |
 3189|      0|# define OP_PRNG_GAIN (1.0F/(float)0xFFFFFFFF)
 3190|       |
 3191|       |/*48 kHz noise shaping filter, sd=2.34.*/
 3192|       |
 3193|       |static const float OP_FCOEF_B[4]={
 3194|       |  2.2374F,-0.7339F,-0.1251F,-0.6033F
 3195|       |};
 3196|       |
 3197|       |static const float OP_FCOEF_A[4]={
 3198|       |  0.9030F,0.0116F,-0.5853F,-0.2571F
 3199|       |};
 3200|       |
 3201|       |static int op_float2short_filter(OggOpusFile *_of,void *_dst,int _dst_sz,
 3202|      0| float *_src,int _nsamples,int _nchannels){
 3203|      0|  opus_int16 *dst;
 3204|      0|  int         ci;
 3205|      0|  int         i;
 3206|      0|  dst=(opus_int16 *)_dst;
 3207|      0|  if(OP_UNLIKELY(_nsamples*_nchannels>_dst_sz))_nsamples=_dst_sz/_nchannels;
 3208|      0|# if defined(OP_SOFT_CLIP)
 3209|      0|  if(_of->state_channel_count!=_nchannels){
 3210|      0|    for(ci=0;ci<_nchannels;ci++)_of->clip_state[ci]=0;
 3211|      0|  }
 3212|      0|  opus_pcm_soft_clip(_src,_nsamples,_nchannels,_of->clip_state);
 3213|      0|# endif
 3214|      0|  if(_of->dither_disabled){
 3215|      0|    for(i=0;i<_nchannels*_nsamples;i++){
 3216|      0|      dst[i]=op_float2int(OP_CLAMP(-32768,32768.0F*_src[i],32767));
 3217|      0|    }
 3218|      0|  }
 3219|      0|  else{
 3220|      0|    opus_uint32 seed;
 3221|      0|    int         mute;
 3222|      0|    seed=_of->dither_seed;
 3223|      0|    mute=_of->dither_mute;
 3224|      0|    if(_of->state_channel_count!=_nchannels)mute=65;
 3225|       |    /*In order to avoid replacing digital silence with quiet dither noise, we
 3226|       |       mute if the output has been silent for a while.*/
 3227|      0|    if(mute>64)memset(_of->dither_a,0,sizeof(*_of->dither_a)*4*_nchannels);
 3228|      0|    for(i=0;i<_nsamples;i++){
 3229|      0|      int silent;
 3230|      0|      silent=1;
 3231|      0|      for(ci=0;ci<_nchannels;ci++){
 3232|      0|        float r;
 3233|      0|        float s;
 3234|      0|        float err;
 3235|      0|        int   si;
 3236|      0|        int   j;
 3237|      0|        s=_src[_nchannels*i+ci];
 3238|      0|        silent&=s==0;
 3239|      0|        s*=OP_GAIN;
 3240|      0|        err=0;
 3241|      0|        for(j=0;j<4;j++){
 3242|      0|          err+=OP_FCOEF_B[j]*_of->dither_b[ci*4+j]
 3243|      0|           -OP_FCOEF_A[j]*_of->dither_a[ci*4+j];
 3244|      0|        }
 3245|      0|        for(j=3;j-->0;)_of->dither_a[ci*4+j+1]=_of->dither_a[ci*4+j];
 3246|      0|        for(j=3;j-->0;)_of->dither_b[ci*4+j+1]=_of->dither_b[ci*4+j];
 3247|      0|        _of->dither_a[ci*4]=err;
 3248|      0|        s-=err;
 3249|      0|        if(mute>16)r=0;
 3250|      0|        else{
 3251|      0|          seed=op_rand(seed);
 3252|      0|          r=seed*OP_PRNG_GAIN;
 3253|      0|          seed=op_rand(seed);
 3254|      0|          r-=seed*OP_PRNG_GAIN;
 3255|      0|        }
 3256|       |        /*Clamp in float out of paranoia that the input will be > 96 dBFS and
 3257|       |           wrap if the integer is clamped.*/
 3258|      0|        si=op_float2int(OP_CLAMP(-32768,s+r,32767));
 3259|      0|        dst[_nchannels*i+ci]=(opus_int16)si;
 3260|       |        /*Including clipping in the noise shaping is generally disastrous: the
 3261|       |           futile effort to restore the clipped energy results in more clipping.
 3262|       |          However, small amounts---at the level which could normally be created
 3263|       |           by dither and rounding---are harmless and can even reduce clipping
 3264|       |           somewhat due to the clipping sometimes reducing the dither + rounding
 3265|       |           error.*/
 3266|      0|        _of->dither_b[ci*4]=mute>16?0:OP_CLAMP(-1.5F,si-s,1.5F);
 3267|      0|      }
 3268|      0|      mute++;
 3269|      0|      if(!silent)mute=0;
 3270|      0|    }
 3271|      0|    _of->dither_mute=OP_MIN(mute,65);
 3272|      0|    _of->dither_seed=seed;
 3273|      0|  }
 3274|      0|  _of->state_channel_count=_nchannels;
 3275|      0|  return _nsamples;
 3276|      0|}
 3277|       |
 3278|      0|int op_read(OggOpusFile *_of,opus_int16 *_pcm,int _buf_size,int *_li){
 3279|      0|  return op_filter_read_native(_of,_pcm,_buf_size,op_float2short_filter,_li);
 3280|      0|}
 3281|       |
 3282|      0|int op_read_float(OggOpusFile *_of,float *_pcm,int _buf_size,int *_li){
 3283|      0|  _of->state_channel_count=0;
 3284|      0|  return op_read_native(_of,_pcm,_buf_size,_li);
 3285|      0|}
 3286|       |
 3287|       |static int op_stereo_filter(OggOpusFile *_of,void *_dst,int _dst_sz,
 3288|      0| op_sample *_src,int _nsamples,int _nchannels){
 3289|      0|  (void)_of;
 3290|      0|  _nsamples=OP_MIN(_nsamples,_dst_sz>>1);
 3291|      0|  if(_nchannels==2)memcpy(_dst,_src,_nsamples*2*sizeof(*_src));
 3292|      0|  else{
 3293|      0|    float *dst;
 3294|      0|    int    i;
 3295|      0|    dst=(float *)_dst;
 3296|      0|    if(_nchannels==1){
 3297|      0|      for(i=0;i<_nsamples;i++)dst[2*i+0]=dst[2*i+1]=_src[i];
 3298|      0|    }
 3299|      0|    else{
 3300|      0|      for(i=0;i<_nsamples;i++){
 3301|      0|        float l;
 3302|      0|        float r;
 3303|      0|        int   ci;
 3304|      0|        l=r=0;
 3305|      0|        for(ci=0;ci<_nchannels;ci++){
 3306|      0|          l+=OP_STEREO_DOWNMIX[_nchannels-3][ci][0]*_src[_nchannels*i+ci];
 3307|      0|          r+=OP_STEREO_DOWNMIX[_nchannels-3][ci][1]*_src[_nchannels*i+ci];
 3308|      0|        }
 3309|      0|        dst[2*i+0]=l;
 3310|      0|        dst[2*i+1]=r;
 3311|      0|      }
 3312|      0|    }
 3313|      0|  }
 3314|      0|  return _nsamples;
 3315|      0|}
 3316|       |
 3317|       |static int op_float2short_stereo_filter(OggOpusFile *_of,
 3318|      0| void *_dst,int _dst_sz,op_sample *_src,int _nsamples,int _nchannels){
 3319|      0|  opus_int16 *dst;
 3320|      0|  dst=(opus_int16 *)_dst;
 3321|      0|  if(_nchannels==1){
 3322|      0|    int i;
 3323|      0|    _nsamples=op_float2short_filter(_of,dst,_dst_sz>>1,_src,_nsamples,1);
 3324|      0|    for(i=_nsamples;i-->0;)dst[2*i+0]=dst[2*i+1]=dst[i];
 3325|      0|  }
 3326|      0|  else{
 3327|      0|    if(_nchannels>2){
 3328|      0|      _nsamples=OP_MIN(_nsamples,_dst_sz>>1);
 3329|      0|      _nsamples=op_stereo_filter(_of,_src,_nsamples*2,
 3330|      0|       _src,_nsamples,_nchannels);
 3331|      0|    }
 3332|      0|    _nsamples=op_float2short_filter(_of,dst,_dst_sz,_src,_nsamples,2);
 3333|      0|  }
 3334|      0|  return _nsamples;
 3335|      0|}
 3336|       |
 3337|      0|int op_read_stereo(OggOpusFile *_of,opus_int16 *_pcm,int _buf_size){
 3338|      0|  return op_filter_read_native(_of,_pcm,_buf_size,
 3339|      0|   op_float2short_stereo_filter,NULL);
 3340|      0|}
 3341|       |
 3342|      0|int op_read_float_stereo(OggOpusFile *_of,float *_pcm,int _buf_size){
 3343|      0|  _of->state_channel_count=0;
 3344|      0|  return op_filter_read_native(_of,_pcm,_buf_size,op_stereo_filter,NULL);
 3345|      0|}
 3346|       |
 3347|       |#endif

/home/fyu/Workspace/hapi-client/test/test-api/opusfile/src/stream.c:
    1|       |/********************************************************************
    2|       | *                                                                  *
    3|       | * THIS FILE IS PART OF THE libopusfile SOFTWARE CODEC SOURCE CODE. *
    4|       | * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
    5|       | * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
    6|       | * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
    7|       | *                                                                  *
    8|       | * THE libopusfile SOURCE CODE IS (C) COPYRIGHT 1994-2018           *
    9|       | * by the Xiph.Org Foundation and contributors https://xiph.org/    *
   10|       | *                                                                  *
   11|       | ********************************************************************
   12|       |
   13|       | function: stdio-based convenience library for opening/seeking/decoding
   14|       | last mod: $Id: vorbisfile.c 17573 2010-10-27 14:53:59Z xiphmont $
   15|       |
   16|       | ********************************************************************/
   17|       |#ifdef HAVE_CONFIG_H
   18|       |#include "config.h"
   19|       |#endif
   20|       |
   21|       |#include "internal.h"
   22|       |#include <sys/types.h>
   23|       |#include <stdio.h>
   24|       |#include <stdlib.h>
   25|       |#include <errno.h>
   26|       |#include <string.h>
   27|       |#if defined(_WIN32)
   28|       |# include <io.h>
   29|       |#endif
   30|       |
   31|       |typedef struct OpusMemStream OpusMemStream;
   32|       |
   33|      0|#define OP_MEM_SIZE_MAX (~(size_t)0>>1)
   34|      0|#define OP_MEM_DIFF_MAX ((ptrdiff_t)OP_MEM_SIZE_MAX)
   35|       |
   36|       |/*The context information needed to read from a block of memory as if it were a
   37|       |   file.*/
   38|       |struct OpusMemStream{
   39|       |  /*The block of memory to read from.*/
   40|       |  const unsigned char *data;
   41|       |  /*The total size of the block.
   42|       |    This must be at most OP_MEM_SIZE_MAX to prevent signed overflow while
   43|       |     seeking.*/
   44|       |  ptrdiff_t            size;
   45|       |  /*The current file position.
   46|       |    This is allowed to be set arbitrarily greater than size (i.e., past the end
   47|       |     of the block, though we will not read data past the end of the block), but
   48|       |     is not allowed to be negative (i.e., before the beginning of the block).*/
   49|       |  ptrdiff_t            pos;
   50|       |};
   51|       |
   52|     92|static int op_fread(void *_stream,unsigned char *_ptr,int _buf_size){
   53|     92|  FILE   *stream;
   54|     92|  size_t  ret;
   55|       |  /*Check for empty read.*/
   56|     92|  if(_buf_size<=0)return 0;
   57|     92|  stream=(FILE *)_stream;
   58|     92|  ret=fread(_ptr,1,_buf_size,stream);
   59|     92|  OP_ASSERT(ret<=(size_t)_buf_size);
   60|       |  /*If ret==0 and !feof(stream), there was a read error.*/
   61|     92|  return ret>0||feof(stream)?(int)ret:OP_EREAD;
   62|     92|}
   63|       |
   64|     13|static int op_fseek(void *_stream,opus_int64 _offset,int _whence){
   65|       |#if defined(_WIN32)
   66|       |  /*_fseeki64() is not exposed until MSVCRT80.
   67|       |    This is the default starting with MSVC 2005 (_MSC_VER>=1400), but we want
   68|       |     to allow linking against older MSVCRT versions for compatibility back to
   69|       |     XP without installing extra runtime libraries.
   70|       |    i686-pc-mingw32 does not have fseeko() and requires
   71|       |     __MSVCRT_VERSION__>=0x800 for _fseeki64(), which screws up linking with
   72|       |     other libraries (that don't use MSVCRT80 from MSVC 2005 by default).
   73|       |    i686-w64-mingw32 does have fseeko() and respects _FILE_OFFSET_BITS, but I
   74|       |     don't know how to detect that at compile time.
   75|       |    We could just use fseeko64() (which is available in both), but it's
   76|       |     implemented using fgetpos()/fsetpos() just like this code, except without
   77|       |     the overflow checking, so we prefer our version.*/
   78|       |  opus_int64 pos;
   79|       |  /*We don't use fpos_t directly because it might be a struct if __STDC__ is
   80|       |     non-zero or _INTEGRAL_MAX_BITS < 64.
   81|       |    I'm not certain when the latter is true, but someone could in theory set
   82|       |     the former.
   83|       |    Either way, it should be binary compatible with a normal 64-bit int (this
   84|       |     assumption is not portable, but I believe it is true for MSVCRT).*/
   85|       |  OP_ASSERT(sizeof(pos)==sizeof(fpos_t));
   86|       |  /*Translate the seek to an absolute one.*/
   87|       |  if(_whence==SEEK_CUR){
   88|       |    int ret;
   89|       |    ret=fgetpos((FILE *)_stream,(fpos_t *)&pos);
   90|       |    if(ret)return ret;
   91|       |  }
   92|       |  else if(_whence==SEEK_END)pos=_filelengthi64(_fileno((FILE *)_stream));
   93|       |  else if(_whence==SEEK_SET)pos=0;
   94|       |  else return -1;
   95|       |  /*Check for errors or overflow.*/
   96|       |  if(pos<0||_offset<-pos||_offset>OP_INT64_MAX-pos)return -1;
   97|       |  pos+=_offset;
   98|       |  return fsetpos((FILE *)_stream,(fpos_t *)&pos);
   99|       |#else
  100|       |  /*This function actually conforms to the SUSv2 and POSIX.1-2001, so we prefer
  101|       |     it except on Windows.*/
  102|     13|  return fseeko((FILE *)_stream,(off_t)_offset,_whence);
  103|     13|#endif
  104|     13|}
  105|       |
  106|      7|static opus_int64 op_ftell(void *_stream){
  107|       |#if defined(_WIN32)
  108|       |  /*_ftelli64() is not exposed until MSVCRT80, and ftello()/ftello64() have
  109|       |     the same problems as fseeko()/fseeko64() in MingW.
  110|       |    See above for a more detailed explanation.*/
  111|       |  opus_int64 pos;
  112|       |  OP_ASSERT(sizeof(pos)==sizeof(fpos_t));
  113|       |  return fgetpos((FILE *)_stream,(fpos_t *)&pos)?-1:pos;
  114|       |#else
  115|       |  /*This function actually conforms to the SUSv2 and POSIX.1-2001, so we prefer
  116|       |     it except on Windows.*/
  117|      7|  return ftello((FILE *)_stream);
  118|      7|#endif
  119|      7|}
  120|       |
  121|       |static const OpusFileCallbacks OP_FILE_CALLBACKS={
  122|       |  op_fread,
  123|       |  op_fseek,
  124|       |  op_ftell,
  125|       |  (op_close_func)fclose
  126|       |};
  127|       |
  128|       |#if defined(_WIN32)
  129|       |# include <stddef.h>
  130|       |# include <errno.h>
  131|       |
  132|       |/*Windows doesn't accept UTF-8 by default, and we don't have a wchar_t API,
  133|       |   so if we just pass the path to fopen(), then there'd be no way for a user
  134|       |   of our API to open a Unicode filename.
  135|       |  Instead, we translate from UTF-8 to UTF-16 and use Windows' wchar_t API.
  136|       |  This makes this API more consistent with platforms where the character set
  137|       |   used by fopen is the same as used on disk, which is generally UTF-8, and
  138|       |   with our metadata API, which always uses UTF-8.*/
  139|       |static wchar_t *op_utf8_to_utf16(const char *_src){
  140|       |  wchar_t *dst;
  141|       |  size_t   len;
  142|       |  len=strlen(_src);
  143|       |  /*Worst-case output is 1 wide character per 1 input character.*/
  144|       |  dst=(wchar_t *)_ogg_malloc(sizeof(*dst)*(len+1));
  145|       |  if(dst!=NULL){
  146|       |    size_t si;
  147|       |    size_t di;
  148|       |    for(di=si=0;si<len;si++){
  149|       |      int c0;
  150|       |      c0=(unsigned char)_src[si];
  151|       |      if(!(c0&0x80)){
  152|       |        /*Start byte says this is a 1-byte sequence.*/
  153|       |        dst[di++]=(wchar_t)c0;
  154|       |        continue;
  155|       |      }
  156|       |      else{
  157|       |        int c1;
  158|       |        /*This is safe, because c0 was not 0 and _src is NUL-terminated.*/
  159|       |        c1=(unsigned char)_src[si+1];
  160|       |        if((c1&0xC0)==0x80){
  161|       |          /*Found at least one continuation byte.*/
  162|       |          if((c0&0xE0)==0xC0){
  163|       |            wchar_t w;
  164|       |            /*Start byte says this is a 2-byte sequence.*/
  165|       |            w=(c0&0x1F)<<6|c1&0x3F;
  166|       |            if(w>=0x80U){
  167|       |              /*This is a 2-byte sequence that is not overlong.*/
  168|       |              dst[di++]=w;
  169|       |              si++;
  170|       |              continue;
  171|       |            }
  172|       |          }
  173|       |          else{
  174|       |            int c2;
  175|       |            /*This is safe, because c1 was not 0 and _src is NUL-terminated.*/
  176|       |            c2=(unsigned char)_src[si+2];
  177|       |            if((c2&0xC0)==0x80){
  178|       |              /*Found at least two continuation bytes.*/
  179|       |              if((c0&0xF0)==0xE0){
  180|       |                wchar_t w;
  181|       |                /*Start byte says this is a 3-byte sequence.*/
  182|       |                w=(c0&0xF)<<12|(c1&0x3F)<<6|c2&0x3F;
  183|       |                if(w>=0x800U&&(w<0xD800||w>=0xE000)&&w<0xFFFE){
  184|       |                  /*This is a 3-byte sequence that is not overlong, not a
  185|       |                     UTF-16 surrogate pair value, and not a 'not a character'
  186|       |                     value.*/
  187|       |                  dst[di++]=w;
  188|       |                  si+=2;
  189|       |                  continue;
  190|       |                }
  191|       |              }
  192|       |              else{
  193|       |                int c3;
  194|       |                /*This is safe, because c2 was not 0 and _src is
  195|       |                   NUL-terminated.*/
  196|       |                c3=(unsigned char)_src[si+3];
  197|       |                if((c3&0xC0)==0x80){
  198|       |                  /*Found at least three continuation bytes.*/
  199|       |                  if((c0&0xF8)==0xF0){
  200|       |                    opus_uint32 w;
  201|       |                    /*Start byte says this is a 4-byte sequence.*/
  202|       |                    w=(c0&7)<<18|(c1&0x3F)<<12|(c2&0x3F)<<6&(c3&0x3F);
  203|       |                    if(w>=0x10000U&&w<0x110000U){
  204|       |                      /*This is a 4-byte sequence that is not overlong and not
  205|       |                         greater than the largest valid Unicode code point.
  206|       |                        Convert it to a surrogate pair.*/
  207|       |                      w-=0x10000;
  208|       |                      dst[di++]=(wchar_t)(0xD800+(w>>10));
  209|       |                      dst[di++]=(wchar_t)(0xDC00+(w&0x3FF));
  210|       |                      si+=3;
  211|       |                      continue;
  212|       |                    }
  213|       |                  }
  214|       |                }
  215|       |              }
  216|       |            }
  217|       |          }
  218|       |        }
  219|       |      }
  220|       |      /*If we got here, we encountered an illegal UTF-8 sequence.*/
  221|       |      _ogg_free(dst);
  222|       |      return NULL;
  223|       |    }
  224|       |    OP_ASSERT(di<=len);
  225|       |    dst[di]='\0';
  226|       |  }
  227|       |  return dst;
  228|       |}
  229|       |
  230|       |/*fsetpos() internally dispatches to the win32 API call SetFilePointer().
  231|       |  According to SetFilePointer()'s documentation [0], the behavior is
  232|       |   undefined if you do not call it on "a file stored on a seeking device".
  233|       |  However, none of the MSVCRT seeking functions verify what kind of file is
  234|       |   being used before calling it (which I believe is a bug, since they are
  235|       |   supposed to fail and return an error, but it is a bug that has been there
  236|       |   for multiple decades now).
  237|       |  In practice, SetFilePointer() appears to succeed for things like stdin,
  238|       |   even when you are not just piping in a regular file, which prevents the use
  239|       |   of this API to determine whether it is possible to seek in a file at all.
  240|       |  Therefore, we take the approach recommended by the SetFilePointer()
  241|       |   documentation and confirm the type of file using GetFileType() first.
  242|       |  We do this once, when the file is opened, and return the corresponding
  243|       |   callback in order to avoid an extra win32 API call on every seek in the
  244|       |   common case.
  245|       |  Hopefully the return value of GetFileType() cannot actually change for the
  246|       |   lifetime of a file handle.
  247|       |  [0] https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-setfilepointer
  248|       |*/
  249|       |static int op_fseek_fail(void *_stream,opus_int64 _offset,int _whence){
  250|       |  (void)_stream;
  251|       |  (void)_offset;
  252|       |  (void)_whence;
  253|       |  return -1;
  254|       |}
  255|       |
  256|       |static const OpusFileCallbacks OP_UNSEEKABLE_FILE_CALLBACKS={
  257|       |  op_fread,
  258|       |  op_fseek_fail,
  259|       |  op_ftell,
  260|       |  (op_close_func)fclose
  261|       |};
  262|       |
  263|       |# define WIN32_LEAN_AND_MEAN
  264|       |# define WIN32_EXTRA_LEAN
  265|       |# include <windows.h>
  266|       |
  267|       |static const OpusFileCallbacks *op_get_file_callbacks(FILE *_fp){
  268|       |  intptr_t h_file;
  269|       |  h_file=_get_osfhandle(_fileno(_fp));
  270|       |  if(h_file!=-1
  271|       |   &&(GetFileType((HANDLE)h_file)&~FILE_TYPE_REMOTE)==FILE_TYPE_DISK){
  272|       |    return &OP_FILE_CALLBACKS;
  273|       |  }
  274|       |  return &OP_UNSEEKABLE_FILE_CALLBACKS;
  275|       |}
  276|       |#else
  277|      4|static const OpusFileCallbacks *op_get_file_callbacks(FILE *_fp){
  278|      4|  (void)_fp;
  279|      4|  return &OP_FILE_CALLBACKS;
  280|      4|}
  281|       |#endif
  282|       |
  283|      4|void *op_fopen(OpusFileCallbacks *_cb,const char *_path,const char *_mode){
  284|      4|  FILE *fp;
  285|      4|#if !defined(_WIN32)
  286|      4|  fp=fopen(_path,_mode);
  287|       |#else
  288|       |  fp=NULL;
  289|       |  {
  290|       |    wchar_t *wpath;
  291|       |    wchar_t *wmode;
  292|       |    wpath=op_utf8_to_utf16(_path);
  293|       |    wmode=op_utf8_to_utf16(_mode);
  294|       |    if(wmode==NULL)errno=EINVAL;
  295|       |    else if(wpath==NULL)errno=ENOENT;
  296|       |    else fp=_wfopen(wpath,wmode);
  297|       |    _ogg_free(wmode);
  298|       |    _ogg_free(wpath);
  299|       |  }
  300|       |#endif
  301|      4|  if(fp!=NULL)*_cb=*op_get_file_callbacks(fp);
  302|      4|  return fp;
  303|      4|}
  304|       |
  305|      0|void *op_fdopen(OpusFileCallbacks *_cb,int _fd,const char *_mode){
  306|      0|  FILE *fp;
  307|      0|  fp=fdopen(_fd,_mode);
  308|      0|  if(fp!=NULL)*_cb=*op_get_file_callbacks(fp);
  309|      0|  return fp;
  310|      0|}
  311|       |
  312|       |void *op_freopen(OpusFileCallbacks *_cb,const char *_path,const char *_mode,
  313|      0| void *_stream){
  314|      0|  FILE *fp;
  315|      0|#if !defined(_WIN32)
  316|      0|  fp=freopen(_path,_mode,(FILE *)_stream);
  317|       |#else
  318|       |  fp=NULL;
  319|       |  {
  320|       |    wchar_t *wpath;
  321|       |    wchar_t *wmode;
  322|       |    wpath=op_utf8_to_utf16(_path);
  323|       |    wmode=op_utf8_to_utf16(_mode);
  324|       |    if(wmode==NULL)errno=EINVAL;
  325|       |    else if(wpath==NULL)errno=ENOENT;
  326|       |    else fp=_wfreopen(wpath,wmode,(FILE *)_stream);
  327|       |    _ogg_free(wmode);
  328|       |    _ogg_free(wpath);
  329|       |  }
  330|       |#endif
  331|      0|  if(fp!=NULL)*_cb=*op_get_file_callbacks(fp);
  332|      0|  return fp;
  333|      0|}
  334|       |
  335|      0|static int op_mem_read(void *_stream,unsigned char *_ptr,int _buf_size){
  336|      0|  OpusMemStream *stream;
  337|      0|  ptrdiff_t      size;
  338|      0|  ptrdiff_t      pos;
  339|      0|  stream=(OpusMemStream *)_stream;
  340|       |  /*Check for empty read.*/
  341|      0|  if(_buf_size<=0)return 0;
  342|      0|  size=stream->size;
  343|      0|  pos=stream->pos;
  344|       |  /*Check for EOF.*/
  345|      0|  if(pos>=size)return 0;
  346|       |  /*Check for a short read.*/
  347|      0|  _buf_size=(int)OP_MIN(size-pos,_buf_size);
  348|      0|  memcpy(_ptr,stream->data+pos,_buf_size);
  349|      0|  pos+=_buf_size;
  350|      0|  stream->pos=pos;
  351|      0|  return _buf_size;
  352|      0|}
  353|       |
  354|      0|static int op_mem_seek(void *_stream,opus_int64 _offset,int _whence){
  355|      0|  OpusMemStream *stream;
  356|      0|  ptrdiff_t      pos;
  357|      0|  stream=(OpusMemStream *)_stream;
  358|      0|  pos=stream->pos;
  359|      0|  OP_ASSERT(pos>=0);
  360|      0|  switch(_whence){
  361|      0|    case SEEK_SET:{
  362|       |      /*Check for overflow:*/
  363|      0|      if(_offset<0||_offset>OP_MEM_DIFF_MAX)return -1;
  364|      0|      pos=(ptrdiff_t)_offset;
  365|      0|    }break;
  366|      0|    case SEEK_CUR:{
  367|       |      /*Check for overflow:*/
  368|      0|      if(_offset<-pos||_offset>OP_MEM_DIFF_MAX-pos)return -1;
  369|      0|      pos=(ptrdiff_t)(pos+_offset);
  370|      0|    }break;
  371|      0|    case SEEK_END:{
  372|      0|      ptrdiff_t size;
  373|      0|      size=stream->size;
  374|      0|      OP_ASSERT(size>=0);
  375|       |      /*Check for overflow:*/
  376|      0|      if(_offset<-size||_offset>OP_MEM_DIFF_MAX-size)return -1;
  377|      0|      pos=(ptrdiff_t)(size+_offset);
  378|      0|    }break;
  379|      0|    default:return -1;
  380|      0|  }
  381|      0|  stream->pos=pos;
  382|      0|  return 0;
  383|      0|}
  384|       |
  385|      0|static opus_int64 op_mem_tell(void *_stream){
  386|      0|  OpusMemStream *stream;
  387|      0|  stream=(OpusMemStream *)_stream;
  388|      0|  return (ogg_int64_t)stream->pos;
  389|      0|}
  390|       |
  391|      0|static int op_mem_close(void *_stream){
  392|      0|  _ogg_free(_stream);
  393|      0|  return 0;
  394|      0|}
  395|       |
  396|       |static const OpusFileCallbacks OP_MEM_CALLBACKS={
  397|       |  op_mem_read,
  398|       |  op_mem_seek,
  399|       |  op_mem_tell,
  400|       |  op_mem_close
  401|       |};
  402|       |
  403|       |void *op_mem_stream_create(OpusFileCallbacks *_cb,
  404|      0| const unsigned char *_data,size_t _size){
  405|      0|  OpusMemStream *stream;
  406|      0|  if(_size>OP_MEM_SIZE_MAX)return NULL;
  407|      0|  stream=(OpusMemStream *)_ogg_malloc(sizeof(*stream));
  408|      0|  if(stream!=NULL){
  409|      0|    *_cb=*&OP_MEM_CALLBACKS;
  410|      0|    stream->data=_data;
  411|      0|    stream->size=_size;
  412|      0|    stream->pos=0;
  413|      0|  }
  414|      0|  return stream;
  415|      0|}

/usr/include/opus/opus_defines.h:
    1|       |/* Copyright (c) 2010-2011 Xiph.Org Foundation, Skype Limited
    2|       |   Written by Jean-Marc Valin and Koen Vos */
    3|       |/*
    4|       |   Redistribution and use in source and binary forms, with or without
    5|       |   modification, are permitted provided that the following conditions
    6|       |   are met:
    7|       |
    8|       |   - Redistributions of source code must retain the above copyright
    9|       |   notice, this list of conditions and the following disclaimer.
   10|       |
   11|       |   - Redistributions in binary form must reproduce the above copyright
   12|       |   notice, this list of conditions and the following disclaimer in the
   13|       |   documentation and/or other materials provided with the distribution.
   14|       |
   15|       |   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   16|       |   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   17|       |   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   18|       |   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   19|       |   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   20|       |   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   21|       |   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   22|       |   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   23|       |   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   24|       |   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   25|       |   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   26|       |*/
   27|       |
   28|       |/**
   29|       | * @file opus_defines.h
   30|       | * @brief Opus reference implementation constants
   31|       | */
   32|       |
   33|       |#ifndef OPUS_DEFINES_H
   34|       |#define OPUS_DEFINES_H
   35|       |
   36|       |#include "opus_types.h"
   37|       |
   38|       |#ifdef __cplusplus
   39|       |extern "C" {
   40|       |#endif
   41|       |
   42|       |/** @defgroup opus_errorcodes Error codes
   43|       | * @{
   44|       | */
   45|       |/** No error @hideinitializer*/
   46|       |#define OPUS_OK                0
   47|       |/** One or more invalid/out of range arguments @hideinitializer*/
   48|       |#define OPUS_BAD_ARG          -1
   49|       |/** Not enough bytes allocated in the buffer @hideinitializer*/
   50|       |#define OPUS_BUFFER_TOO_SMALL -2
   51|       |/** An internal error was detected @hideinitializer*/
   52|       |#define OPUS_INTERNAL_ERROR   -3
   53|       |/** The compressed data passed is corrupted @hideinitializer*/
   54|       |#define OPUS_INVALID_PACKET   -4
   55|       |/** Invalid/unsupported request number @hideinitializer*/
   56|       |#define OPUS_UNIMPLEMENTED    -5
   57|       |/** An encoder or decoder structure is invalid or already freed @hideinitializer*/
   58|       |#define OPUS_INVALID_STATE    -6
   59|       |/** Memory allocation has failed @hideinitializer*/
   60|       |#define OPUS_ALLOC_FAIL       -7
   61|       |/**@}*/
   62|       |
   63|       |/** @cond OPUS_INTERNAL_DOC */
   64|       |/**Export control for opus functions */
   65|       |
   66|       |#ifndef OPUS_EXPORT
   67|       |# if defined(WIN32)
   68|       |#  if defined(OPUS_BUILD) && defined(DLL_EXPORT)
   69|       |#   define OPUS_EXPORT __declspec(dllexport)
   70|       |#  else
   71|       |#   define OPUS_EXPORT
   72|       |#  endif
   73|       |# elif defined(__GNUC__) && defined(OPUS_BUILD)
   74|       |#  define OPUS_EXPORT __attribute__ ((visibility ("default")))
   75|       |# else
   76|       |#  define OPUS_EXPORT
   77|       |# endif
   78|       |#endif
   79|       |
   80|       |# if !defined(OPUS_GNUC_PREREQ)
   81|       |#  if defined(__GNUC__)&&defined(__GNUC_MINOR__)
   82|       |#   define OPUS_GNUC_PREREQ(_maj,_min) \
   83|       | ((__GNUC__<<16)+__GNUC_MINOR__>=((_maj)<<16)+(_min))
   84|       |#  else
   85|       |#   define OPUS_GNUC_PREREQ(_maj,_min) 0
   86|       |#  endif
   87|       |# endif
   88|       |
   89|       |#if (!defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L) )
   90|       |# if OPUS_GNUC_PREREQ(3,0)
   91|       |#  define OPUS_RESTRICT __restrict__
   92|       |# elif (defined(_MSC_VER) && _MSC_VER >= 1400)
   93|       |#  define OPUS_RESTRICT __restrict
   94|       |# else
   95|       |#  define OPUS_RESTRICT
   96|       |# endif
   97|       |#else
   98|       |# define OPUS_RESTRICT restrict
   99|       |#endif
  100|       |
  101|       |#if (!defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L) )
  102|       |# if OPUS_GNUC_PREREQ(2,7)
  103|       |#  define OPUS_INLINE __inline__
  104|       |# elif (defined(_MSC_VER))
  105|       |#  define OPUS_INLINE __inline
  106|       |# else
  107|       |#  define OPUS_INLINE
  108|       |# endif
  109|       |#else
  110|       |# define OPUS_INLINE inline
  111|       |#endif
  112|       |
  113|       |/**Warning attributes for opus functions
  114|       |  * NONNULL is not used in OPUS_BUILD to avoid the compiler optimizing out
  115|       |  * some paranoid null checks. */
  116|       |#if defined(__GNUC__) && OPUS_GNUC_PREREQ(3, 4)
  117|       |# define OPUS_WARN_UNUSED_RESULT __attribute__ ((__warn_unused_result__))
  118|       |#else
  119|       |# define OPUS_WARN_UNUSED_RESULT
  120|       |#endif
  121|       |#if !defined(OPUS_BUILD) && defined(__GNUC__) && OPUS_GNUC_PREREQ(3, 4)
  122|       |# define OPUS_ARG_NONNULL(_x)  __attribute__ ((__nonnull__(_x)))
  123|       |#else
  124|       |# define OPUS_ARG_NONNULL(_x)
  125|       |#endif
  126|       |
  127|       |/** These are the actual Encoder CTL ID numbers.
  128|       |  * They should not be used directly by applications.
  129|       |  * In general, SETs should be even and GETs should be odd.*/
  130|       |#define OPUS_SET_APPLICATION_REQUEST         4000
  131|       |#define OPUS_GET_APPLICATION_REQUEST         4001
  132|       |#define OPUS_SET_BITRATE_REQUEST             4002
  133|       |#define OPUS_GET_BITRATE_REQUEST             4003
  134|       |#define OPUS_SET_MAX_BANDWIDTH_REQUEST       4004
  135|       |#define OPUS_GET_MAX_BANDWIDTH_REQUEST       4005
  136|       |#define OPUS_SET_VBR_REQUEST                 4006
  137|       |#define OPUS_GET_VBR_REQUEST                 4007
  138|       |#define OPUS_SET_BANDWIDTH_REQUEST           4008
  139|       |#define OPUS_GET_BANDWIDTH_REQUEST           4009
  140|       |#define OPUS_SET_COMPLEXITY_REQUEST          4010
  141|       |#define OPUS_GET_COMPLEXITY_REQUEST          4011
  142|       |#define OPUS_SET_INBAND_FEC_REQUEST          4012
  143|       |#define OPUS_GET_INBAND_FEC_REQUEST          4013
  144|       |#define OPUS_SET_PACKET_LOSS_PERC_REQUEST    4014
  145|       |#define OPUS_GET_PACKET_LOSS_PERC_REQUEST    4015
  146|       |#define OPUS_SET_DTX_REQUEST                 4016
  147|       |#define OPUS_GET_DTX_REQUEST                 4017
  148|       |#define OPUS_SET_VBR_CONSTRAINT_REQUEST      4020
  149|       |#define OPUS_GET_VBR_CONSTRAINT_REQUEST      4021
  150|       |#define OPUS_SET_FORCE_CHANNELS_REQUEST      4022
  151|       |#define OPUS_GET_FORCE_CHANNELS_REQUEST      4023
  152|       |#define OPUS_SET_SIGNAL_REQUEST              4024
  153|       |#define OPUS_GET_SIGNAL_REQUEST              4025
  154|       |#define OPUS_GET_LOOKAHEAD_REQUEST           4027
  155|       |/* #define OPUS_RESET_STATE 4028 */
  156|       |#define OPUS_GET_SAMPLE_RATE_REQUEST         4029
  157|       |#define OPUS_GET_FINAL_RANGE_REQUEST         4031
  158|       |#define OPUS_GET_PITCH_REQUEST               4033
  159|      3|#define OPUS_SET_GAIN_REQUEST                4034
  160|       |#define OPUS_GET_GAIN_REQUEST                4045 /* Should have been 4035 */
  161|       |#define OPUS_SET_LSB_DEPTH_REQUEST           4036
  162|       |#define OPUS_GET_LSB_DEPTH_REQUEST           4037
  163|       |#define OPUS_GET_LAST_PACKET_DURATION_REQUEST 4039
  164|       |#define OPUS_SET_EXPERT_FRAME_DURATION_REQUEST 4040
  165|       |#define OPUS_GET_EXPERT_FRAME_DURATION_REQUEST 4041
  166|       |#define OPUS_SET_PREDICTION_DISABLED_REQUEST 4042
  167|       |#define OPUS_GET_PREDICTION_DISABLED_REQUEST 4043
  168|       |/* Don't use 4045, it's already taken by OPUS_GET_GAIN_REQUEST */
  169|       |#define OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST 4046
  170|       |#define OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST 4047
  171|       |#define OPUS_GET_IN_DTX_REQUEST              4049
  172|       |
  173|       |/** Defines for the presence of extended APIs. */
  174|       |#define OPUS_HAVE_OPUS_PROJECTION_H
  175|       |
  176|       |/* Macros to trigger compilation errors when the wrong types are provided to a CTL */
  177|      3|#define __opus_check_int(x) (((void)((x) == (opus_int32)0)), (opus_int32)(x))
  178|       |#define __opus_check_int_ptr(ptr) ((ptr) + ((ptr) - (opus_int32*)(ptr)))
  179|       |#define __opus_check_uint_ptr(ptr) ((ptr) + ((ptr) - (opus_uint32*)(ptr)))
  180|       |#define __opus_check_val16_ptr(ptr) ((ptr) + ((ptr) - (opus_val16*)(ptr)))
  181|       |/** @endcond */
  182|       |
  183|       |/** @defgroup opus_ctlvalues Pre-defined values for CTL interface
  184|       |  * @see opus_genericctls, opus_encoderctls
  185|       |  * @{
  186|       |  */
  187|       |/* Values for the various encoder CTLs */
  188|       |#define OPUS_AUTO                           -1000 /**<Auto/default setting @hideinitializer*/
  189|       |#define OPUS_BITRATE_MAX                       -1 /**<Maximum bitrate @hideinitializer*/
  190|       |
  191|       |/** Best for most VoIP/videoconference applications where listening quality and intelligibility matter most
  192|       | * @hideinitializer */
  193|       |#define OPUS_APPLICATION_VOIP                2048
  194|       |/** Best for broadcast/high-fidelity application where the decoded audio should be as close as possible to the input
  195|       | * @hideinitializer */
  196|       |#define OPUS_APPLICATION_AUDIO               2049
  197|       |/** Only use when lowest-achievable latency is what matters most. Voice-optimized modes cannot be used.
  198|       | * @hideinitializer */
  199|       |#define OPUS_APPLICATION_RESTRICTED_LOWDELAY 2051
  200|       |
  201|       |#define OPUS_SIGNAL_VOICE                    3001 /**< Signal being encoded is voice */
  202|       |#define OPUS_SIGNAL_MUSIC                    3002 /**< Signal being encoded is music */
  203|       |#define OPUS_BANDWIDTH_NARROWBAND            1101 /**< 4 kHz bandpass @hideinitializer*/
  204|       |#define OPUS_BANDWIDTH_MEDIUMBAND            1102 /**< 6 kHz bandpass @hideinitializer*/
  205|       |#define OPUS_BANDWIDTH_WIDEBAND              1103 /**< 8 kHz bandpass @hideinitializer*/
  206|       |#define OPUS_BANDWIDTH_SUPERWIDEBAND         1104 /**<12 kHz bandpass @hideinitializer*/
  207|       |#define OPUS_BANDWIDTH_FULLBAND              1105 /**<20 kHz bandpass @hideinitializer*/
  208|       |
  209|       |#define OPUS_FRAMESIZE_ARG                   5000 /**< Select frame size from the argument (default) */
  210|       |#define OPUS_FRAMESIZE_2_5_MS                5001 /**< Use 2.5 ms frames */
  211|       |#define OPUS_FRAMESIZE_5_MS                  5002 /**< Use 5 ms frames */
  212|       |#define OPUS_FRAMESIZE_10_MS                 5003 /**< Use 10 ms frames */
  213|       |#define OPUS_FRAMESIZE_20_MS                 5004 /**< Use 20 ms frames */
  214|       |#define OPUS_FRAMESIZE_40_MS                 5005 /**< Use 40 ms frames */
  215|       |#define OPUS_FRAMESIZE_60_MS                 5006 /**< Use 60 ms frames */
  216|       |#define OPUS_FRAMESIZE_80_MS                 5007 /**< Use 80 ms frames */
  217|       |#define OPUS_FRAMESIZE_100_MS                5008 /**< Use 100 ms frames */
  218|       |#define OPUS_FRAMESIZE_120_MS                5009 /**< Use 120 ms frames */
  219|       |
  220|       |/**@}*/
  221|       |
  222|       |
  223|       |/** @defgroup opus_encoderctls Encoder related CTLs
  224|       |  *
  225|       |  * These are convenience macros for use with the \c opus_encode_ctl
  226|       |  * interface. They are used to generate the appropriate series of
  227|       |  * arguments for that call, passing the correct type, size and so
  228|       |  * on as expected for each particular request.
  229|       |  *
  230|       |  * Some usage examples:
  231|       |  *
  232|       |  * @code
  233|       |  * int ret;
  234|       |  * ret = opus_encoder_ctl(enc_ctx, OPUS_SET_BANDWIDTH(OPUS_AUTO));
  235|       |  * if (ret != OPUS_OK) return ret;
  236|       |  *
  237|       |  * opus_int32 rate;
  238|       |  * opus_encoder_ctl(enc_ctx, OPUS_GET_BANDWIDTH(&rate));
  239|       |  *
  240|       |  * opus_encoder_ctl(enc_ctx, OPUS_RESET_STATE);
  241|       |  * @endcode
  242|       |  *
  243|       |  * @see opus_genericctls, opus_encoder
  244|       |  * @{
  245|       |  */
  246|       |
  247|       |/** Configures the encoder's computational complexity.
  248|       |  * The supported range is 0-10 inclusive with 10 representing the highest complexity.
  249|       |  * @see OPUS_GET_COMPLEXITY
  250|       |  * @param[in] x <tt>opus_int32</tt>: Allowed values: 0-10, inclusive.
  251|       |  *
  252|       |  * @hideinitializer */
  253|       |#define OPUS_SET_COMPLEXITY(x) OPUS_SET_COMPLEXITY_REQUEST, __opus_check_int(x)
  254|       |/** Gets the encoder's complexity configuration.
  255|       |  * @see OPUS_SET_COMPLEXITY
  256|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns a value in the range 0-10,
  257|       |  *                                      inclusive.
  258|       |  * @hideinitializer */
  259|       |#define OPUS_GET_COMPLEXITY(x) OPUS_GET_COMPLEXITY_REQUEST, __opus_check_int_ptr(x)
  260|       |
  261|       |/** Configures the bitrate in the encoder.
  262|       |  * Rates from 500 to 512000 bits per second are meaningful, as well as the
  263|       |  * special values #OPUS_AUTO and #OPUS_BITRATE_MAX.
  264|       |  * The value #OPUS_BITRATE_MAX can be used to cause the codec to use as much
  265|       |  * rate as it can, which is useful for controlling the rate by adjusting the
  266|       |  * output buffer size.
  267|       |  * @see OPUS_GET_BITRATE
  268|       |  * @param[in] x <tt>opus_int32</tt>: Bitrate in bits per second. The default
  269|       |  *                                   is determined based on the number of
  270|       |  *                                   channels and the input sampling rate.
  271|       |  * @hideinitializer */
  272|       |#define OPUS_SET_BITRATE(x) OPUS_SET_BITRATE_REQUEST, __opus_check_int(x)
  273|       |/** Gets the encoder's bitrate configuration.
  274|       |  * @see OPUS_SET_BITRATE
  275|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns the bitrate in bits per second.
  276|       |  *                                      The default is determined based on the
  277|       |  *                                      number of channels and the input
  278|       |  *                                      sampling rate.
  279|       |  * @hideinitializer */
  280|       |#define OPUS_GET_BITRATE(x) OPUS_GET_BITRATE_REQUEST, __opus_check_int_ptr(x)
  281|       |
  282|       |/** Enables or disables variable bitrate (VBR) in the encoder.
  283|       |  * The configured bitrate may not be met exactly because frames must
  284|       |  * be an integer number of bytes in length.
  285|       |  * @see OPUS_GET_VBR
  286|       |  * @see OPUS_SET_VBR_CONSTRAINT
  287|       |  * @param[in] x <tt>opus_int32</tt>: Allowed values:
  288|       |  * <dl>
  289|       |  * <dt>0</dt><dd>Hard CBR. For LPC/hybrid modes at very low bit-rate, this can
  290|       |  *               cause noticeable quality degradation.</dd>
  291|       |  * <dt>1</dt><dd>VBR (default). The exact type of VBR is controlled by
  292|       |  *               #OPUS_SET_VBR_CONSTRAINT.</dd>
  293|       |  * </dl>
  294|       |  * @hideinitializer */
  295|       |#define OPUS_SET_VBR(x) OPUS_SET_VBR_REQUEST, __opus_check_int(x)
  296|       |/** Determine if variable bitrate (VBR) is enabled in the encoder.
  297|       |  * @see OPUS_SET_VBR
  298|       |  * @see OPUS_GET_VBR_CONSTRAINT
  299|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns one of the following values:
  300|       |  * <dl>
  301|       |  * <dt>0</dt><dd>Hard CBR.</dd>
  302|       |  * <dt>1</dt><dd>VBR (default). The exact type of VBR may be retrieved via
  303|       |  *               #OPUS_GET_VBR_CONSTRAINT.</dd>
  304|       |  * </dl>
  305|       |  * @hideinitializer */
  306|       |#define OPUS_GET_VBR(x) OPUS_GET_VBR_REQUEST, __opus_check_int_ptr(x)
  307|       |
  308|       |/** Enables or disables constrained VBR in the encoder.
  309|       |  * This setting is ignored when the encoder is in CBR mode.
  310|       |  * @warning Only the MDCT mode of Opus currently heeds the constraint.
  311|       |  *  Speech mode ignores it completely, hybrid mode may fail to obey it
  312|       |  *  if the LPC layer uses more bitrate than the constraint would have
  313|       |  *  permitted.
  314|       |  * @see OPUS_GET_VBR_CONSTRAINT
  315|       |  * @see OPUS_SET_VBR
  316|       |  * @param[in] x <tt>opus_int32</tt>: Allowed values:
  317|       |  * <dl>
  318|       |  * <dt>0</dt><dd>Unconstrained VBR.</dd>
  319|       |  * <dt>1</dt><dd>Constrained VBR (default). This creates a maximum of one
  320|       |  *               frame of buffering delay assuming a transport with a
  321|       |  *               serialization speed of the nominal bitrate.</dd>
  322|       |  * </dl>
  323|       |  * @hideinitializer */
  324|       |#define OPUS_SET_VBR_CONSTRAINT(x) OPUS_SET_VBR_CONSTRAINT_REQUEST, __opus_check_int(x)
  325|       |/** Determine if constrained VBR is enabled in the encoder.
  326|       |  * @see OPUS_SET_VBR_CONSTRAINT
  327|       |  * @see OPUS_GET_VBR
  328|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns one of the following values:
  329|       |  * <dl>
  330|       |  * <dt>0</dt><dd>Unconstrained VBR.</dd>
  331|       |  * <dt>1</dt><dd>Constrained VBR (default).</dd>
  332|       |  * </dl>
  333|       |  * @hideinitializer */
  334|       |#define OPUS_GET_VBR_CONSTRAINT(x) OPUS_GET_VBR_CONSTRAINT_REQUEST, __opus_check_int_ptr(x)
  335|       |
  336|       |/** Configures mono/stereo forcing in the encoder.
  337|       |  * This can force the encoder to produce packets encoded as either mono or
  338|       |  * stereo, regardless of the format of the input audio. This is useful when
  339|       |  * the caller knows that the input signal is currently a mono source embedded
  340|       |  * in a stereo stream.
  341|       |  * @see OPUS_GET_FORCE_CHANNELS
  342|       |  * @param[in] x <tt>opus_int32</tt>: Allowed values:
  343|       |  * <dl>
  344|       |  * <dt>#OPUS_AUTO</dt><dd>Not forced (default)</dd>
  345|       |  * <dt>1</dt>         <dd>Forced mono</dd>
  346|       |  * <dt>2</dt>         <dd>Forced stereo</dd>
  347|       |  * </dl>
  348|       |  * @hideinitializer */
  349|       |#define OPUS_SET_FORCE_CHANNELS(x) OPUS_SET_FORCE_CHANNELS_REQUEST, __opus_check_int(x)
  350|       |/** Gets the encoder's forced channel configuration.
  351|       |  * @see OPUS_SET_FORCE_CHANNELS
  352|       |  * @param[out] x <tt>opus_int32 *</tt>:
  353|       |  * <dl>
  354|       |  * <dt>#OPUS_AUTO</dt><dd>Not forced (default)</dd>
  355|       |  * <dt>1</dt>         <dd>Forced mono</dd>
  356|       |  * <dt>2</dt>         <dd>Forced stereo</dd>
  357|       |  * </dl>
  358|       |  * @hideinitializer */
  359|       |#define OPUS_GET_FORCE_CHANNELS(x) OPUS_GET_FORCE_CHANNELS_REQUEST, __opus_check_int_ptr(x)
  360|       |
  361|       |/** Configures the maximum bandpass that the encoder will select automatically.
  362|       |  * Applications should normally use this instead of #OPUS_SET_BANDWIDTH
  363|       |  * (leaving that set to the default, #OPUS_AUTO). This allows the
  364|       |  * application to set an upper bound based on the type of input it is
  365|       |  * providing, but still gives the encoder the freedom to reduce the bandpass
  366|       |  * when the bitrate becomes too low, for better overall quality.
  367|       |  * @see OPUS_GET_MAX_BANDWIDTH
  368|       |  * @param[in] x <tt>opus_int32</tt>: Allowed values:
  369|       |  * <dl>
  370|       |  * <dt>OPUS_BANDWIDTH_NARROWBAND</dt>    <dd>4 kHz passband</dd>
  371|       |  * <dt>OPUS_BANDWIDTH_MEDIUMBAND</dt>    <dd>6 kHz passband</dd>
  372|       |  * <dt>OPUS_BANDWIDTH_WIDEBAND</dt>      <dd>8 kHz passband</dd>
  373|       |  * <dt>OPUS_BANDWIDTH_SUPERWIDEBAND</dt><dd>12 kHz passband</dd>
  374|       |  * <dt>OPUS_BANDWIDTH_FULLBAND</dt>     <dd>20 kHz passband (default)</dd>
  375|       |  * </dl>
  376|       |  * @hideinitializer */
  377|       |#define OPUS_SET_MAX_BANDWIDTH(x) OPUS_SET_MAX_BANDWIDTH_REQUEST, __opus_check_int(x)
  378|       |
  379|       |/** Gets the encoder's configured maximum allowed bandpass.
  380|       |  * @see OPUS_SET_MAX_BANDWIDTH
  381|       |  * @param[out] x <tt>opus_int32 *</tt>: Allowed values:
  382|       |  * <dl>
  383|       |  * <dt>#OPUS_BANDWIDTH_NARROWBAND</dt>    <dd>4 kHz passband</dd>
  384|       |  * <dt>#OPUS_BANDWIDTH_MEDIUMBAND</dt>    <dd>6 kHz passband</dd>
  385|       |  * <dt>#OPUS_BANDWIDTH_WIDEBAND</dt>      <dd>8 kHz passband</dd>
  386|       |  * <dt>#OPUS_BANDWIDTH_SUPERWIDEBAND</dt><dd>12 kHz passband</dd>
  387|       |  * <dt>#OPUS_BANDWIDTH_FULLBAND</dt>     <dd>20 kHz passband (default)</dd>
  388|       |  * </dl>
  389|       |  * @hideinitializer */
  390|       |#define OPUS_GET_MAX_BANDWIDTH(x) OPUS_GET_MAX_BANDWIDTH_REQUEST, __opus_check_int_ptr(x)
  391|       |
  392|       |/** Sets the encoder's bandpass to a specific value.
  393|       |  * This prevents the encoder from automatically selecting the bandpass based
  394|       |  * on the available bitrate. If an application knows the bandpass of the input
  395|       |  * audio it is providing, it should normally use #OPUS_SET_MAX_BANDWIDTH
  396|       |  * instead, which still gives the encoder the freedom to reduce the bandpass
  397|       |  * when the bitrate becomes too low, for better overall quality.
  398|       |  * @see OPUS_GET_BANDWIDTH
  399|       |  * @param[in] x <tt>opus_int32</tt>: Allowed values:
  400|       |  * <dl>
  401|       |  * <dt>#OPUS_AUTO</dt>                    <dd>(default)</dd>
  402|       |  * <dt>#OPUS_BANDWIDTH_NARROWBAND</dt>    <dd>4 kHz passband</dd>
  403|       |  * <dt>#OPUS_BANDWIDTH_MEDIUMBAND</dt>    <dd>6 kHz passband</dd>
  404|       |  * <dt>#OPUS_BANDWIDTH_WIDEBAND</dt>      <dd>8 kHz passband</dd>
  405|       |  * <dt>#OPUS_BANDWIDTH_SUPERWIDEBAND</dt><dd>12 kHz passband</dd>
  406|       |  * <dt>#OPUS_BANDWIDTH_FULLBAND</dt>     <dd>20 kHz passband</dd>
  407|       |  * </dl>
  408|       |  * @hideinitializer */
  409|       |#define OPUS_SET_BANDWIDTH(x) OPUS_SET_BANDWIDTH_REQUEST, __opus_check_int(x)
  410|       |
  411|       |/** Configures the type of signal being encoded.
  412|       |  * This is a hint which helps the encoder's mode selection.
  413|       |  * @see OPUS_GET_SIGNAL
  414|       |  * @param[in] x <tt>opus_int32</tt>: Allowed values:
  415|       |  * <dl>
  416|       |  * <dt>#OPUS_AUTO</dt>        <dd>(default)</dd>
  417|       |  * <dt>#OPUS_SIGNAL_VOICE</dt><dd>Bias thresholds towards choosing LPC or Hybrid modes.</dd>
  418|       |  * <dt>#OPUS_SIGNAL_MUSIC</dt><dd>Bias thresholds towards choosing MDCT modes.</dd>
  419|       |  * </dl>
  420|       |  * @hideinitializer */
  421|       |#define OPUS_SET_SIGNAL(x) OPUS_SET_SIGNAL_REQUEST, __opus_check_int(x)
  422|       |/** Gets the encoder's configured signal type.
  423|       |  * @see OPUS_SET_SIGNAL
  424|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns one of the following values:
  425|       |  * <dl>
  426|       |  * <dt>#OPUS_AUTO</dt>        <dd>(default)</dd>
  427|       |  * <dt>#OPUS_SIGNAL_VOICE</dt><dd>Bias thresholds towards choosing LPC or Hybrid modes.</dd>
  428|       |  * <dt>#OPUS_SIGNAL_MUSIC</dt><dd>Bias thresholds towards choosing MDCT modes.</dd>
  429|       |  * </dl>
  430|       |  * @hideinitializer */
  431|       |#define OPUS_GET_SIGNAL(x) OPUS_GET_SIGNAL_REQUEST, __opus_check_int_ptr(x)
  432|       |
  433|       |
  434|       |/** Configures the encoder's intended application.
  435|       |  * The initial value is a mandatory argument to the encoder_create function.
  436|       |  * @see OPUS_GET_APPLICATION
  437|       |  * @param[in] x <tt>opus_int32</tt>: Returns one of the following values:
  438|       |  * <dl>
  439|       |  * <dt>#OPUS_APPLICATION_VOIP</dt>
  440|       |  * <dd>Process signal for improved speech intelligibility.</dd>
  441|       |  * <dt>#OPUS_APPLICATION_AUDIO</dt>
  442|       |  * <dd>Favor faithfulness to the original input.</dd>
  443|       |  * <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>
  444|       |  * <dd>Configure the minimum possible coding delay by disabling certain modes
  445|       |  * of operation.</dd>
  446|       |  * </dl>
  447|       |  * @hideinitializer */
  448|       |#define OPUS_SET_APPLICATION(x) OPUS_SET_APPLICATION_REQUEST, __opus_check_int(x)
  449|       |/** Gets the encoder's configured application.
  450|       |  * @see OPUS_SET_APPLICATION
  451|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns one of the following values:
  452|       |  * <dl>
  453|       |  * <dt>#OPUS_APPLICATION_VOIP</dt>
  454|       |  * <dd>Process signal for improved speech intelligibility.</dd>
  455|       |  * <dt>#OPUS_APPLICATION_AUDIO</dt>
  456|       |  * <dd>Favor faithfulness to the original input.</dd>
  457|       |  * <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>
  458|       |  * <dd>Configure the minimum possible coding delay by disabling certain modes
  459|       |  * of operation.</dd>
  460|       |  * </dl>
  461|       |  * @hideinitializer */
  462|       |#define OPUS_GET_APPLICATION(x) OPUS_GET_APPLICATION_REQUEST, __opus_check_int_ptr(x)
  463|       |
  464|       |/** Gets the total samples of delay added by the entire codec.
  465|       |  * This can be queried by the encoder and then the provided number of samples can be
  466|       |  * skipped on from the start of the decoder's output to provide time aligned input
  467|       |  * and output. From the perspective of a decoding application the real data begins this many
  468|       |  * samples late.
  469|       |  *
  470|       |  * The decoder contribution to this delay is identical for all decoders, but the
  471|       |  * encoder portion of the delay may vary from implementation to implementation,
  472|       |  * version to version, or even depend on the encoder's initial configuration.
  473|       |  * Applications needing delay compensation should call this CTL rather than
  474|       |  * hard-coding a value.
  475|       |  * @param[out] x <tt>opus_int32 *</tt>:   Number of lookahead samples
  476|       |  * @hideinitializer */
  477|       |#define OPUS_GET_LOOKAHEAD(x) OPUS_GET_LOOKAHEAD_REQUEST, __opus_check_int_ptr(x)
  478|       |
  479|       |/** Configures the encoder's use of inband forward error correction (FEC).
  480|       |  * @note This is only applicable to the LPC layer
  481|       |  * @see OPUS_GET_INBAND_FEC
  482|       |  * @param[in] x <tt>opus_int32</tt>: Allowed values:
  483|       |  * <dl>
  484|       |  * <dt>0</dt><dd>Disable inband FEC (default).</dd>
  485|       |  * <dt>1</dt><dd>Enable inband FEC.</dd>
  486|       |  * </dl>
  487|       |  * @hideinitializer */
  488|       |#define OPUS_SET_INBAND_FEC(x) OPUS_SET_INBAND_FEC_REQUEST, __opus_check_int(x)
  489|       |/** Gets encoder's configured use of inband forward error correction.
  490|       |  * @see OPUS_SET_INBAND_FEC
  491|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns one of the following values:
  492|       |  * <dl>
  493|       |  * <dt>0</dt><dd>Inband FEC disabled (default).</dd>
  494|       |  * <dt>1</dt><dd>Inband FEC enabled.</dd>
  495|       |  * </dl>
  496|       |  * @hideinitializer */
  497|       |#define OPUS_GET_INBAND_FEC(x) OPUS_GET_INBAND_FEC_REQUEST, __opus_check_int_ptr(x)
  498|       |
  499|       |/** Configures the encoder's expected packet loss percentage.
  500|       |  * Higher values trigger progressively more loss resistant behavior in the encoder
  501|       |  * at the expense of quality at a given bitrate in the absence of packet loss, but
  502|       |  * greater quality under loss.
  503|       |  * @see OPUS_GET_PACKET_LOSS_PERC
  504|       |  * @param[in] x <tt>opus_int32</tt>:   Loss percentage in the range 0-100, inclusive (default: 0).
  505|       |  * @hideinitializer */
  506|       |#define OPUS_SET_PACKET_LOSS_PERC(x) OPUS_SET_PACKET_LOSS_PERC_REQUEST, __opus_check_int(x)
  507|       |/** Gets the encoder's configured packet loss percentage.
  508|       |  * @see OPUS_SET_PACKET_LOSS_PERC
  509|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns the configured loss percentage
  510|       |  *                                      in the range 0-100, inclusive (default: 0).
  511|       |  * @hideinitializer */
  512|       |#define OPUS_GET_PACKET_LOSS_PERC(x) OPUS_GET_PACKET_LOSS_PERC_REQUEST, __opus_check_int_ptr(x)
  513|       |
  514|       |/** Configures the encoder's use of discontinuous transmission (DTX).
  515|       |  * @note This is only applicable to the LPC layer
  516|       |  * @see OPUS_GET_DTX
  517|       |  * @param[in] x <tt>opus_int32</tt>: Allowed values:
  518|       |  * <dl>
  519|       |  * <dt>0</dt><dd>Disable DTX (default).</dd>
  520|       |  * <dt>1</dt><dd>Enabled DTX.</dd>
  521|       |  * </dl>
  522|       |  * @hideinitializer */
  523|       |#define OPUS_SET_DTX(x) OPUS_SET_DTX_REQUEST, __opus_check_int(x)
  524|       |/** Gets encoder's configured use of discontinuous transmission.
  525|       |  * @see OPUS_SET_DTX
  526|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns one of the following values:
  527|       |  * <dl>
  528|       |  * <dt>0</dt><dd>DTX disabled (default).</dd>
  529|       |  * <dt>1</dt><dd>DTX enabled.</dd>
  530|       |  * </dl>
  531|       |  * @hideinitializer */
  532|       |#define OPUS_GET_DTX(x) OPUS_GET_DTX_REQUEST, __opus_check_int_ptr(x)
  533|       |/** Configures the depth of signal being encoded.
  534|       |  *
  535|       |  * This is a hint which helps the encoder identify silence and near-silence.
  536|       |  * It represents the number of significant bits of linear intensity below
  537|       |  * which the signal contains ignorable quantization or other noise.
  538|       |  *
  539|       |  * For example, OPUS_SET_LSB_DEPTH(14) would be an appropriate setting
  540|       |  * for G.711 u-law input. OPUS_SET_LSB_DEPTH(16) would be appropriate
  541|       |  * for 16-bit linear pcm input with opus_encode_float().
  542|       |  *
  543|       |  * When using opus_encode() instead of opus_encode_float(), or when libopus
  544|       |  * is compiled for fixed-point, the encoder uses the minimum of the value
  545|       |  * set here and the value 16.
  546|       |  *
  547|       |  * @see OPUS_GET_LSB_DEPTH
  548|       |  * @param[in] x <tt>opus_int32</tt>: Input precision in bits, between 8 and 24
  549|       |  *                                   (default: 24).
  550|       |  * @hideinitializer */
  551|       |#define OPUS_SET_LSB_DEPTH(x) OPUS_SET_LSB_DEPTH_REQUEST, __opus_check_int(x)
  552|       |/** Gets the encoder's configured signal depth.
  553|       |  * @see OPUS_SET_LSB_DEPTH
  554|       |  * @param[out] x <tt>opus_int32 *</tt>: Input precision in bits, between 8 and
  555|       |  *                                      24 (default: 24).
  556|       |  * @hideinitializer */
  557|       |#define OPUS_GET_LSB_DEPTH(x) OPUS_GET_LSB_DEPTH_REQUEST, __opus_check_int_ptr(x)
  558|       |
  559|       |/** Configures the encoder's use of variable duration frames.
  560|       |  * When variable duration is enabled, the encoder is free to use a shorter frame
  561|       |  * size than the one requested in the opus_encode*() call.
  562|       |  * It is then the user's responsibility
  563|       |  * to verify how much audio was encoded by checking the ToC byte of the encoded
  564|       |  * packet. The part of the audio that was not encoded needs to be resent to the
  565|       |  * encoder for the next call. Do not use this option unless you <b>really</b>
  566|       |  * know what you are doing.
  567|       |  * @see OPUS_GET_EXPERT_FRAME_DURATION
  568|       |  * @param[in] x <tt>opus_int32</tt>: Allowed values:
  569|       |  * <dl>
  570|       |  * <dt>OPUS_FRAMESIZE_ARG</dt><dd>Select frame size from the argument (default).</dd>
  571|       |  * <dt>OPUS_FRAMESIZE_2_5_MS</dt><dd>Use 2.5 ms frames.</dd>
  572|       |  * <dt>OPUS_FRAMESIZE_5_MS</dt><dd>Use 5 ms frames.</dd>
  573|       |  * <dt>OPUS_FRAMESIZE_10_MS</dt><dd>Use 10 ms frames.</dd>
  574|       |  * <dt>OPUS_FRAMESIZE_20_MS</dt><dd>Use 20 ms frames.</dd>
  575|       |  * <dt>OPUS_FRAMESIZE_40_MS</dt><dd>Use 40 ms frames.</dd>
  576|       |  * <dt>OPUS_FRAMESIZE_60_MS</dt><dd>Use 60 ms frames.</dd>
  577|       |  * <dt>OPUS_FRAMESIZE_80_MS</dt><dd>Use 80 ms frames.</dd>
  578|       |  * <dt>OPUS_FRAMESIZE_100_MS</dt><dd>Use 100 ms frames.</dd>
  579|       |  * <dt>OPUS_FRAMESIZE_120_MS</dt><dd>Use 120 ms frames.</dd>
  580|       |  * </dl>
  581|       |  * @hideinitializer */
  582|       |#define OPUS_SET_EXPERT_FRAME_DURATION(x) OPUS_SET_EXPERT_FRAME_DURATION_REQUEST, __opus_check_int(x)
  583|       |/** Gets the encoder's configured use of variable duration frames.
  584|       |  * @see OPUS_SET_EXPERT_FRAME_DURATION
  585|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns one of the following values:
  586|       |  * <dl>
  587|       |  * <dt>OPUS_FRAMESIZE_ARG</dt><dd>Select frame size from the argument (default).</dd>
  588|       |  * <dt>OPUS_FRAMESIZE_2_5_MS</dt><dd>Use 2.5 ms frames.</dd>
  589|       |  * <dt>OPUS_FRAMESIZE_5_MS</dt><dd>Use 5 ms frames.</dd>
  590|       |  * <dt>OPUS_FRAMESIZE_10_MS</dt><dd>Use 10 ms frames.</dd>
  591|       |  * <dt>OPUS_FRAMESIZE_20_MS</dt><dd>Use 20 ms frames.</dd>
  592|       |  * <dt>OPUS_FRAMESIZE_40_MS</dt><dd>Use 40 ms frames.</dd>
  593|       |  * <dt>OPUS_FRAMESIZE_60_MS</dt><dd>Use 60 ms frames.</dd>
  594|       |  * <dt>OPUS_FRAMESIZE_80_MS</dt><dd>Use 80 ms frames.</dd>
  595|       |  * <dt>OPUS_FRAMESIZE_100_MS</dt><dd>Use 100 ms frames.</dd>
  596|       |  * <dt>OPUS_FRAMESIZE_120_MS</dt><dd>Use 120 ms frames.</dd>
  597|       |  * </dl>
  598|       |  * @hideinitializer */
  599|       |#define OPUS_GET_EXPERT_FRAME_DURATION(x) OPUS_GET_EXPERT_FRAME_DURATION_REQUEST, __opus_check_int_ptr(x)
  600|       |
  601|       |/** If set to 1, disables almost all use of prediction, making frames almost
  602|       |  * completely independent. This reduces quality.
  603|       |  * @see OPUS_GET_PREDICTION_DISABLED
  604|       |  * @param[in] x <tt>opus_int32</tt>: Allowed values:
  605|       |  * <dl>
  606|       |  * <dt>0</dt><dd>Enable prediction (default).</dd>
  607|       |  * <dt>1</dt><dd>Disable prediction.</dd>
  608|       |  * </dl>
  609|       |  * @hideinitializer */
  610|       |#define OPUS_SET_PREDICTION_DISABLED(x) OPUS_SET_PREDICTION_DISABLED_REQUEST, __opus_check_int(x)
  611|       |/** Gets the encoder's configured prediction status.
  612|       |  * @see OPUS_SET_PREDICTION_DISABLED
  613|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns one of the following values:
  614|       |  * <dl>
  615|       |  * <dt>0</dt><dd>Prediction enabled (default).</dd>
  616|       |  * <dt>1</dt><dd>Prediction disabled.</dd>
  617|       |  * </dl>
  618|       |  * @hideinitializer */
  619|       |#define OPUS_GET_PREDICTION_DISABLED(x) OPUS_GET_PREDICTION_DISABLED_REQUEST, __opus_check_int_ptr(x)
  620|       |
  621|       |/**@}*/
  622|       |
  623|       |/** @defgroup opus_genericctls Generic CTLs
  624|       |  *
  625|       |  * These macros are used with the \c opus_decoder_ctl and
  626|       |  * \c opus_encoder_ctl calls to generate a particular
  627|       |  * request.
  628|       |  *
  629|       |  * When called on an \c OpusDecoder they apply to that
  630|       |  * particular decoder instance. When called on an
  631|       |  * \c OpusEncoder they apply to the corresponding setting
  632|       |  * on that encoder instance, if present.
  633|       |  *
  634|       |  * Some usage examples:
  635|       |  *
  636|       |  * @code
  637|       |  * int ret;
  638|       |  * opus_int32 pitch;
  639|       |  * ret = opus_decoder_ctl(dec_ctx, OPUS_GET_PITCH(&pitch));
  640|       |  * if (ret == OPUS_OK) return ret;
  641|       |  *
  642|       |  * opus_encoder_ctl(enc_ctx, OPUS_RESET_STATE);
  643|       |  * opus_decoder_ctl(dec_ctx, OPUS_RESET_STATE);
  644|       |  *
  645|       |  * opus_int32 enc_bw, dec_bw;
  646|       |  * opus_encoder_ctl(enc_ctx, OPUS_GET_BANDWIDTH(&enc_bw));
  647|       |  * opus_decoder_ctl(dec_ctx, OPUS_GET_BANDWIDTH(&dec_bw));
  648|       |  * if (enc_bw != dec_bw) {
  649|       |  *   printf("packet bandwidth mismatch!\n");
  650|       |  * }
  651|       |  * @endcode
  652|       |  *
  653|       |  * @see opus_encoder, opus_decoder_ctl, opus_encoder_ctl, opus_decoderctls, opus_encoderctls
  654|       |  * @{
  655|       |  */
  656|       |
  657|       |/** Resets the codec state to be equivalent to a freshly initialized state.
  658|       |  * This should be called when switching streams in order to prevent
  659|       |  * the back to back decoding from giving different results from
  660|       |  * one at a time decoding.
  661|       |  * @hideinitializer */
  662|      0|#define OPUS_RESET_STATE 4028
  663|       |
  664|       |/** Gets the final state of the codec's entropy coder.
  665|       |  * This is used for testing purposes,
  666|       |  * The encoder and decoder state should be identical after coding a payload
  667|       |  * (assuming no data corruption or software bugs)
  668|       |  *
  669|       |  * @param[out] x <tt>opus_uint32 *</tt>: Entropy coder state
  670|       |  *
  671|       |  * @hideinitializer */
  672|       |#define OPUS_GET_FINAL_RANGE(x) OPUS_GET_FINAL_RANGE_REQUEST, __opus_check_uint_ptr(x)
  673|       |
  674|       |/** Gets the encoder's configured bandpass or the decoder's last bandpass.
  675|       |  * @see OPUS_SET_BANDWIDTH
  676|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns one of the following values:
  677|       |  * <dl>
  678|       |  * <dt>#OPUS_AUTO</dt>                    <dd>(default)</dd>
  679|       |  * <dt>#OPUS_BANDWIDTH_NARROWBAND</dt>    <dd>4 kHz passband</dd>
  680|       |  * <dt>#OPUS_BANDWIDTH_MEDIUMBAND</dt>    <dd>6 kHz passband</dd>
  681|       |  * <dt>#OPUS_BANDWIDTH_WIDEBAND</dt>      <dd>8 kHz passband</dd>
  682|       |  * <dt>#OPUS_BANDWIDTH_SUPERWIDEBAND</dt><dd>12 kHz passband</dd>
  683|       |  * <dt>#OPUS_BANDWIDTH_FULLBAND</dt>     <dd>20 kHz passband</dd>
  684|       |  * </dl>
  685|       |  * @hideinitializer */
  686|       |#define OPUS_GET_BANDWIDTH(x) OPUS_GET_BANDWIDTH_REQUEST, __opus_check_int_ptr(x)
  687|       |
  688|       |/** Gets the sampling rate the encoder or decoder was initialized with.
  689|       |  * This simply returns the <code>Fs</code> value passed to opus_encoder_init()
  690|       |  * or opus_decoder_init().
  691|       |  * @param[out] x <tt>opus_int32 *</tt>: Sampling rate of encoder or decoder.
  692|       |  * @hideinitializer
  693|       |  */
  694|       |#define OPUS_GET_SAMPLE_RATE(x) OPUS_GET_SAMPLE_RATE_REQUEST, __opus_check_int_ptr(x)
  695|       |
  696|       |/** If set to 1, disables the use of phase inversion for intensity stereo,
  697|       |  * improving the quality of mono downmixes, but slightly reducing normal
  698|       |  * stereo quality. Disabling phase inversion in the decoder does not comply
  699|       |  * with RFC 6716, although it does not cause any interoperability issue and
  700|       |  * is expected to become part of the Opus standard once RFC 6716 is updated
  701|       |  * by draft-ietf-codec-opus-update.
  702|       |  * @see OPUS_GET_PHASE_INVERSION_DISABLED
  703|       |  * @param[in] x <tt>opus_int32</tt>: Allowed values:
  704|       |  * <dl>
  705|       |  * <dt>0</dt><dd>Enable phase inversion (default).</dd>
  706|       |  * <dt>1</dt><dd>Disable phase inversion.</dd>
  707|       |  * </dl>
  708|       |  * @hideinitializer */
  709|       |#define OPUS_SET_PHASE_INVERSION_DISABLED(x) OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST, __opus_check_int(x)
  710|       |/** Gets the encoder's configured phase inversion status.
  711|       |  * @see OPUS_SET_PHASE_INVERSION_DISABLED
  712|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns one of the following values:
  713|       |  * <dl>
  714|       |  * <dt>0</dt><dd>Stereo phase inversion enabled (default).</dd>
  715|       |  * <dt>1</dt><dd>Stereo phase inversion disabled.</dd>
  716|       |  * </dl>
  717|       |  * @hideinitializer */
  718|       |#define OPUS_GET_PHASE_INVERSION_DISABLED(x) OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST, __opus_check_int_ptr(x)
  719|       |/** Gets the DTX state of the encoder.
  720|       |  * Returns whether the last encoded frame was either a comfort noise update
  721|       |  * during DTX or not encoded because of DTX.
  722|       |  * @param[out] x <tt>opus_int32 *</tt>: Returns one of the following values:
  723|       |  * <dl>
  724|       |  * <dt>0</dt><dd>The encoder is not in DTX.</dd>
  725|       |  * <dt>1</dt><dd>The encoder is in DTX.</dd>
  726|       |  * </dl>
  727|       |  * @hideinitializer */
  728|       |#define OPUS_GET_IN_DTX(x) OPUS_GET_IN_DTX_REQUEST, __opus_check_int_ptr(x)
  729|       |
  730|       |/**@}*/
  731|       |
  732|       |/** @defgroup opus_decoderctls Decoder related CTLs
  733|       |  * @see opus_genericctls, opus_encoderctls, opus_decoder
  734|       |  * @{
  735|       |  */
  736|       |
  737|       |/** Configures decoder gain adjustment.
  738|       |  * Scales the decoded output by a factor specified in Q8 dB units.
  739|       |  * This has a maximum range of -32768 to 32767 inclusive, and returns
  740|       |  * OPUS_BAD_ARG otherwise. The default is zero indicating no adjustment.
  741|       |  * This setting survives decoder reset.
  742|       |  *
  743|       |  * gain = pow(10, x/(20.0*256))
  744|       |  *
  745|       |  * @param[in] x <tt>opus_int32</tt>:   Amount to scale PCM signal by in Q8 dB units.
  746|       |  * @hideinitializer */
  747|      3|#define OPUS_SET_GAIN(x) OPUS_SET_GAIN_REQUEST, __opus_check_int(x)
  748|       |/** Gets the decoder's configured gain adjustment. @see OPUS_SET_GAIN
  749|       |  *
  750|       |  * @param[out] x <tt>opus_int32 *</tt>: Amount to scale PCM signal by in Q8 dB units.
  751|       |  * @hideinitializer */
  752|       |#define OPUS_GET_GAIN(x) OPUS_GET_GAIN_REQUEST, __opus_check_int_ptr(x)
  753|       |
  754|       |/** Gets the duration (in samples) of the last packet successfully decoded or concealed.
  755|       |  * @param[out] x <tt>opus_int32 *</tt>: Number of samples (at current sampling rate).
  756|       |  * @hideinitializer */
  757|       |#define OPUS_GET_LAST_PACKET_DURATION(x) OPUS_GET_LAST_PACKET_DURATION_REQUEST, __opus_check_int_ptr(x)
  758|       |
  759|       |/** Gets the pitch of the last decoded frame, if available.
  760|       |  * This can be used for any post-processing algorithm requiring the use of pitch,
  761|       |  * e.g. time stretching/shortening. If the last frame was not voiced, or if the
  762|       |  * pitch was not coded in the frame, then zero is returned.
  763|       |  *
  764|       |  * This CTL is only implemented for decoder instances.
  765|       |  *
  766|       |  * @param[out] x <tt>opus_int32 *</tt>: pitch period at 48 kHz (or 0 if not available)
  767|       |  *
  768|       |  * @hideinitializer */
  769|       |#define OPUS_GET_PITCH(x) OPUS_GET_PITCH_REQUEST, __opus_check_int_ptr(x)
  770|       |
  771|       |/**@}*/
  772|       |
  773|       |/** @defgroup opus_libinfo Opus library information functions
  774|       |  * @{
  775|       |  */
  776|       |
  777|       |/** Converts an opus error code into a human readable string.
  778|       |  *
  779|       |  * @param[in] error <tt>int</tt>: Error number
  780|       |  * @returns Error string
  781|       |  */
  782|       |OPUS_EXPORT const char *opus_strerror(int error);
  783|       |
  784|       |/** Gets the libopus version string.
  785|       |  *
  786|       |  * Applications may look for the substring "-fixed" in the version string to
  787|       |  * determine whether they have a fixed-point or floating-point build at
  788|       |  * runtime.
  789|       |  *
  790|       |  * @returns Version string
  791|       |  */
  792|       |OPUS_EXPORT const char *opus_get_version_string(void);
  793|       |/**@}*/
  794|       |
  795|       |#ifdef __cplusplus
  796|       |}
  797|       |#endif
  798|       |
  799|       |#endif /* OPUS_DEFINES_H */

